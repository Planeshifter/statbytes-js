(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// BASE TYPES //

var BTYPES = {
	'int8': Int8Array,
	'uint8': Uint8Array,
	'uint8_clamped': Uint8ClampedArray,
	'int16': Int16Array,
	'uint16': Uint16Array,
	'int32': Int32Array,
	'uint32': Uint32Array,
	'float32': Float32Array,
	'float64': Float64Array
};


// EXPORTS //

module.exports = BTYPES;

},{}],2:[function(require,module,exports){
'use strict';

// MATRIX //

/**
* FUNCTION: Matrix( data, shape, dtype )
*	Matrix constructor.
*
* @constructor
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} data - input typed array
* @param {String} dtype - matrix data type
* @param {Number[]} shape - matrix dimensions/shape
* @param {Number} offset - matrix offset
* @param {Number[]} strides - matrix strides
* @returns {Matrix} Matrix instance
*/
function Matrix( data, dtype, shape, offset, strides ) {
	if ( !( this instanceof Matrix ) ) {
		return new Matrix( data, dtype, shape, offset, strides );
	}
	// Underlying data type:
	Object.defineProperty( this, 'dtype', {
		'value': dtype,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Matrix dimensions:
	Object.defineProperty( this, 'shape', {
		'value': shape,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Matrix strides:
	Object.defineProperty( this, 'strides', {
		'value': strides,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Matrix offset:
	Object.defineProperty( this, 'offset', {
		'value': offset,
		'configurable': false,
		'enumerable': true,
		'writable': true
	});

	// Number of matrix dimensions:
	Object.defineProperty( this, 'ndims', {
		'value': shape.length,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Matrix length:
	Object.defineProperty( this, 'length', {
		'value': data.length,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Number of bytes used by the matrix elements:
	Object.defineProperty( this, 'nbytes', {
		'value': data.byteLength,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	// Matrix data store:
	Object.defineProperty( this, 'data', {
		'value': data,
		'configurable': false,
		'enumerable': true,
		'writable': false
	});

	return this;
} // end FUNCTION Matrix()


// METHODS //

Matrix.prototype.set = require( './set.js' );
Matrix.prototype.iset = require( './iset.js' );
Matrix.prototype.mset = require( './mset.js' );
Matrix.prototype.sset = require( './sset.js' );

Matrix.prototype.get = require( './get.js' );
Matrix.prototype.iget = require( './iget.js' );
Matrix.prototype.mget = require( './mget.js' );
Matrix.prototype.sget = require( './sget.js' );

Matrix.prototype.toString = require( './toString.js' );


// EXPORTS //

module.exports = Matrix;

},{"./get.js":5,"./iget.js":7,"./iset.js":10,"./mget.js":14,"./mset.js":16,"./set.js":24,"./sget.js":26,"./sset.js":28,"./toString.js":30}],3:[function(require,module,exports){
'use strict';

// MATRIX //

/**
* FUNCTION: Matrix( data, shape, dtype )
*	Matrix constructor.
*
* @constructor
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} data - input typed array
* @param {String} dtype - matrix data type
* @param {Number[]} shape - matrix dimensions/shape
* @param {Number} offset - matrix offset
* @param {Number[]} strides - matrix strides
* @returns {Matrix} Matrix instance
*/
function Matrix( data, dtype, shape, offset, strides ) {
	if ( !( this instanceof Matrix ) ) {
		return new Matrix( data, dtype, shape, offset, strides );
	}
	this.dtype = dtype;
	this.shape = shape;
	this.strides = strides;
	this.offset = offset;
	this.ndims = shape.length;
	this.length = data.length;
	this.nbytes = data.byteLength;
	this.data = data;
	return this;
} // end FUNCTION Matrix()


// METHODS //

Matrix.prototype.set = require( './set.raw.js' );
Matrix.prototype.iset = require( './iset.raw.js' );
Matrix.prototype.mset = require( './mset.raw.js' );
Matrix.prototype.sset = require( './sset.raw.js' );

Matrix.prototype.get = require( './get.raw.js' );
Matrix.prototype.iget = require( './iget.raw.js' );
Matrix.prototype.mget = require( './mget.raw.js' );
Matrix.prototype.sget = require( './sget.raw.js' );

Matrix.prototype.toString = require( './toString.js' );


// EXPORTS //

module.exports = Matrix;

},{"./get.raw.js":6,"./iget.raw.js":8,"./iset.raw.js":11,"./mget.raw.js":15,"./mset.raw.js":17,"./set.raw.js":25,"./sget.raw.js":27,"./sset.raw.js":29,"./toString.js":30}],4:[function(require,module,exports){
'use strict';

// DATA TYPES //

var DTYPES = [
	'int8',
	'uint8',
	'uint8_clamped',
	'int16',
	'uint16',
	'int32',
	'uint32',
	'float32',
	'float64'
];


// EXPORTS //

module.exports = DTYPES;

},{}],5:[function(require,module,exports){
'use strict';

// MODULES //

var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// GET //

/**
* FUNCTION: get( i, j )
*	Returns a matrix element based on the provided row and column indices.
*
* @param {Number} i - row index
* @param {Number} j - column index
* @returns {Number|Undefined} matrix element
*/
function get( i, j ) {
	/*jshint validthis:true */
	if ( !isNonNegativeInteger( i ) || !isNonNegativeInteger( j ) ) {
		throw new TypeError( 'get()::invalid input argument. Indices must be nonnegative integers. Values: `[' + i + ','+ j + ']`.' );
	}
	return this.data[ this.offset + i*this.strides[0] + j*this.strides[1] ];
} // end FUNCTION get()


// EXPORTS //

module.exports = get;

},{"validate.io-nonnegative-integer":47}],6:[function(require,module,exports){
'use strict';

/**
* FUNCTION: get( i, j )
*	Returns a matrix element based on the provided row and column indices.
*
* @param {Number} i - row index
* @param {Number} j - column index
* @returns {Number|Undefined} matrix element
*/
function get( i, j ) {
	/*jshint validthis:true */
	return this.data[ this.offset + i*this.strides[0] + j*this.strides[1] ];
} // end FUNCTION get()


// EXPORTS //

module.exports = get;

},{}],7:[function(require,module,exports){
'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer-primitive' );


// IGET //

/**
* FUNCTION: iget( idx )
*	Returns a matrix element located at a specified index.
*
* @param {Number} idx - linear index
* @returns {Number|Undefined} matrix element
*/
function iget( idx ) {
	/*jshint validthis:true */
	var r, j;
	if ( !isInteger( idx ) ) {
		throw new TypeError( 'iget()::invalid input argument. Must provide a integer. Value: `' + idx + '`.' );
	}
	if ( idx < 0 ) {
		idx += this.length;
		if ( idx < 0 ) {
			return;
		}
	}
	j = idx % this.strides[ 0 ];
	r = idx - j;
	if ( this.strides[ 0 ] < 0 ) {
		r = -r;
	}
	return this.data[ this.offset + r + j*this.strides[1] ];
} // end FUNCTION iget()


// EXPORTS //

module.exports = iget;

},{"validate.io-integer-primitive":45}],8:[function(require,module,exports){
'use strict';

/**
* FUNCTION: iget( idx )
*	Returns a matrix element located at a specified index.
*
* @param {Number} idx - linear index
* @returns {Number|Undefined} matrix element
*/
function iget( idx ) {
	/*jshint validthis:true */
	var r, j;
	if ( idx < 0 ) {
		idx += this.length;
		if ( idx < 0 ) {
			return;
		}
	}
	j = idx % this.strides[ 0 ];
	r = idx - j;
	if ( this.strides[ 0 ] < 0 ) {
		r = -r;
	}
	return this.data[ this.offset + r + j*this.strides[1] ];
} // end FUNCTION iget()


// EXPORTS //

module.exports = iget;

},{}],9:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = require( './matrix.js' );
module.exports.raw = require( './matrix.raw.js' );

},{"./matrix.js":12,"./matrix.raw.js":13}],10:[function(require,module,exports){
'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer-primitive' ),
	isNumber = require( 'validate.io-number-primitive' );


// ISET //

/**
* FUNCTION: iset( idx, value )
*	Sets a matrix element located at a specified index.
*
* @param {Number} idx - linear index
* @param {Number} value - value to set
* @returns {Matrix} Matrix instance
*/
function iset( idx, v ) {
	/* jshint validthis: true */
	var r, j;
	if ( !isInteger( idx ) ) {
		throw new TypeError( 'iset()::invalid input argument. An index must be an integer. Value: `' + idx + '`.' );
	}
	if ( !isNumber( v ) ) {
		throw new TypeError( 'iset()::invalid input argument. An input value must be a number primitive. Value: `' + v + '`.' );
	}
	if ( idx < 0 ) {
		idx += this.length;
		if ( idx < 0 ) {
			return this;
		}
	}
	j = idx % this.strides[ 0 ];
	r = idx - j;
	if ( this.strides[ 0 ] < 0 ) {
		r = -r;
	}
	this.data[ this.offset + r + j*this.strides[1] ] = v;
	return this;
} // end FUNCTION iset()


// EXPORTS //

module.exports = iset;

},{"validate.io-integer-primitive":45,"validate.io-number-primitive":50}],11:[function(require,module,exports){
'use strict';

/**
* FUNCTION: iset( idx, value )
*	Sets a matrix element located at a specified index.
*
* @param {Number} idx - linear index
* @param {Number} value - value to set
* @returns {Matrix} Matrix instance
*/
function iset( idx, v ) {
	/* jshint validthis: true */
	var r, j;
	if ( idx < 0 ) {
		idx += this.length;
		if ( idx < 0 ) {
			return this;
		}
	}
	j = idx % this.strides[ 0 ];
	r = idx - j;
	if ( this.strides[ 0 ] < 0 ) {
		r = -r;
	}
	this.data[ this.offset + r + j*this.strides[1] ] = v;
	return this;
} // end FUNCTION iset()


// EXPORTS //

module.exports = iset;

},{}],12:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isNonNegativeIntegerArray = require( 'validate.io-nonnegative-integer-array' ),
	contains = require( 'validate.io-contains' ),
	isArray = require( 'validate.io-array' ),
	cast = require( 'compute-cast-arrays' ),
	getType = require( 'compute-dtype' ),
	Matrix = require( './ctor.js' );


// VARIABLES //

var BTYPES = require( './btypes.js' ),
	DTYPES = require( './dtypes.js' );


// CREATE MATRIX //

/**
* FUNCTION: matrix( [data,] shape[, dtype] )
*	Returns a Matrix instance.
*
* @constructor
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} [data] - input typed array
* @param {Number[]} shape - matrix dimensions/shape
* @param {String} [dtype="float64"] - matrix data type
* @returns {Matrix} Matrix instance
*/
function matrix() {
	var dtype,
		ndims,
		shape,
		data,
		vFLG,
		len,
		dt,
		i;

	// Parse the input arguments (polymorphic interface)...
	if ( arguments.length === 1 ) {
		shape = arguments[ 0 ];
		vFLG = 2; // arg #s
	}
	else if ( arguments.length === 2 ) {
		if ( isString( arguments[ 1 ] ) ) {
			shape = arguments[ 0 ];
			dtype = arguments[ 1 ];
			vFLG = 23; // arg #s
		} else {
			data = arguments[ 0 ];
			shape = arguments[ 1 ];
			vFLG = 12; // arg #s
		}
	}
	else {
		data = arguments[ 0 ];
		shape = arguments[ 1 ];
		dtype = arguments[ 2 ];
		vFLG = 123; // arg #s
	}

	// Input argument validation...
	if ( !isNonNegativeIntegerArray( shape ) ) {
		throw new TypeError( 'matrix()::invalid input argument. A matrix shape must be an array of nonnegative integers. Value: `' + shape + '`.' );
	}
	ndims = shape.length;
	if ( ndims !== 2 ) {
		throw new Error( 'matrix()::invalid input argument. Shape must be a 2-element array. Value: `' + shape + '`.' );
	}
	// If a `dtype` has been provided, validate...
	if ( vFLG === 123 || vFLG === 23 ) {
		if ( !contains( DTYPES, dtype ) ) {
			throw new TypeError( 'matrix()::invalid input argument. Unrecognized/unsupported data type. Value: `' + dtype + '`.' );
		}
	} else {
		dtype = 'float64';
	}
	len = 1;
	for ( i = 0; i < ndims; i++ ) {
		len *= shape[ i ];
	}
	// If a `data` argument has been provided, validate...
	if ( vFLG === 123 || vFLG === 12 ) {
		dt = getType( data );
		if ( !contains( DTYPES, dt ) && !isArray( data ) ) {
			throw new TypeError( 'matrix()::invalid input argument. Input data must be a valid type. Consult the documentation for a list of valid data types. Value: `' + data + '`.' );
		}
		if ( len !== data.length ) {
			throw new Error( 'matrix()::invalid input argument. Matrix shape does not match the input data length.' );
		}
		// Only cast if either 1) both a `data` and `dtype` argument have been provided and they do not agree or 2) when provided a plain Array...
		if ( ( vFLG === 123 && dt !== dtype ) || dt === 'generic' ) {
			data = cast( data, dtype );
		}
	} else {
		// Initialize a zero-filled typed array:
		data = new BTYPES[ dtype ]( len );
	}
	// Return a new Matrix instance:
	return new Matrix( data, dtype, shape, 0, [shape[1],1] );
} // end FUNCTION matrix()


// EXPORTS //

module.exports = matrix;

},{"./btypes.js":1,"./ctor.js":2,"./dtypes.js":4,"compute-cast-arrays":31,"compute-dtype":36,"validate.io-array":41,"validate.io-contains":42,"validate.io-nonnegative-integer-array":46,"validate.io-string-primitive":51}],13:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	contains = require( 'validate.io-contains' ),
	getType = require( 'compute-dtype' ),
	Matrix = require( './ctor.raw.js' );


// VARIABLES //

var BTYPES = require( './btypes.js' ),
	DTYPES = require( './dtypes.js' );


// CREATE MATRIX //

/**
* FUNCTION: matrix( [data,] shape[, dtype] )
*	Returns a Matrix instance.
*
* @constructor
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} [data] - input typed array
* @param {Number[]} shape - matrix dimensions/shape
* @param {String} [dtype="float64"] - matrix data type
* @returns {Matrix} Matrix instance
*/
function matrix() {
	var dtype,
		ndims,
		shape,
		data,
		len,
		i;

	if ( arguments.length === 1 ) {
		shape = arguments[ 0 ];
	}
	else if ( arguments.length === 2 ) {
		if ( isString( arguments[ 1 ] ) ) {
			shape = arguments[ 0 ];
			dtype = arguments[ 1 ];
		} else {
			data = arguments[ 0 ];
			shape = arguments[ 1 ];
		}
	}
	else {
		data = arguments[ 0 ];
		shape = arguments[ 1 ];
		dtype = arguments[ 2 ];
	}
	ndims = shape.length;
	if ( ndims !== 2 ) {
		throw new Error( 'matrix()::invalid input argument. Shape must be a 2-element array. Value: `' + shape + '`.' );
	}
	len = 1;
	for ( i = 0; i < ndims; i++ ) {
		len *= shape[ i ];
	}
	if ( data ) {
		if ( !dtype ) {
			dtype = getType( data );
			if ( !contains( DTYPES, dtype ) ) {
				throw new TypeError( 'matrix()::invalid input argument. Input data must be a valid type. Consult the documentation for a list of valid data types. Value: `' + data + '`.' );
			}
		}
		if ( len !== data.length ) {
			throw new Error( 'matrix()::invalid input argument. Matrix shape does not match the input data length.' );
		}
	} else {
		// Initialize a zero-filled typed array...
		if ( !dtype ) {
			dtype = 'float64';
		}
		data = new BTYPES[ dtype ]( len );
	}
	// Return a new Matrix instance:
	return new Matrix( data, dtype, shape, 0, [shape[1],1] );
} // end FUNCTION matrix()


// EXPORTS //

module.exports = matrix;

},{"./btypes.js":1,"./ctor.raw.js":3,"./dtypes.js":4,"compute-dtype":36,"validate.io-contains":42,"validate.io-string-primitive":51}],14:[function(require,module,exports){
'use strict';

// MODULES //

var isNonNegativeIntegerArray = require( 'validate.io-nonnegative-integer-array' );


// VARIABLES //

var BTYPES = require( './btypes.js' );


// MGET //

/**
* FUNCTION: mget( i[, j] )
*	Returns multiple matrix elements. If provided a single argument, `i` is treated as an array of linear indices.
*
* @param {Number[]|Null} i - linear/row indices
* @param {Number[]|Null} [j] - column indices
* @returns {Matrix} a new Matrix instance
*/
function mget( rows, cols ) {
	/*jshint validthis:true */
	var nRows,
		nCols,
		out,
		sgn,
		d,
		s0, s1, s2, s3,
		o,
		r, dr,
		i, j, m, n;

	s0 = this.strides[ 0 ];
	s1 = this.strides[ 1 ];
	o = this.offset;

	if ( arguments.length < 2 ) {
		if ( !isNonNegativeIntegerArray( rows ) ) {
			throw new TypeError( 'mget()::invalid input argument. Linear indices must be specified as a nonnegative integer array. Value: `' + rows + '`.' );
		}
		// Filter the input indices to ensure within bounds...
		i = [];
		for ( n = 0; n < rows.length; n++ ) {
			if ( rows[ n ] < this.length ) {
				i.push( rows[ n ] );
			}
		}
		m = i.length;

		// Create a row vector (matrix):
		d = new BTYPES[ this.dtype ]( m );
		out = new this.constructor( d, this.dtype, [1,m], 0, [m,1] );

		sgn = ( s0 < 0 ) ? -1 : 1;
		for ( n = 0; n < m; n++ ) {
			j = i[ n ] % s0;
			r = sgn * ( i[n] - j );
			d[ n ] = this.data[ o + r + j*s1 ];
		}
	} else {
		nRows = this.shape[ 0 ];
		if ( rows === null ) {
			i = new Array( nRows );
			for ( n = 0; n < nRows; n++ ) {
				i[ n ] = n;
			}
		}
		else if ( isNonNegativeIntegerArray( rows ) ) {
			i = [];
			for ( n = 0; n < rows.length; n++ ) {
				if ( rows[ n ] < nRows ) {
					i.push( rows[ n ] );
				}
			}
		}
		else {
			throw new TypeError( 'mget()::invalid input argument. Row indices must be specified as a nonnegative integer array. Value: `' + rows + '`.' );
		}

		nCols = this.shape[ 1 ];
		if ( cols === null ) {
			j = new Array( nCols );
			for ( n = 0; n < nCols; n++ ) {
				j[ n ] = n;
			}
		}
		else if ( isNonNegativeIntegerArray( cols ) ) {
			j = [];
			for ( n = 0; n < cols.length; n++ ) {
				if ( cols[ n ] < nCols ) {
					j.push( cols[ n ] );
				}
			}
		}
		else {
			throw new TypeError( 'mget()::invalid input argument. Column indices must be specified as a nonnegative integer array. Value: `' + cols + '`.' );
		}
		nRows = i.length;
		nCols = j.length;

		d = new BTYPES[ this.dtype ]( nRows*nCols );
		out = new this.constructor( d, this.dtype, [nRows,nCols], 0, [nCols,1]);

		s2 = out.strides[ 0 ];
		s3 = out.strides[ 1 ];
		for ( m = 0; m < nRows; m++ ) {
			r = o + i[m]*s0;
			dr = m * s2;
			for ( n = 0; n < nCols; n++ ) {
				d[ dr + n*s3 ] = this.data[ r + j[n]*s1 ];
			}
		}
	}
	return out;
} // end FUNCTION mget()


// EXPORTS //

module.exports = mget;

},{"./btypes.js":1,"validate.io-nonnegative-integer-array":46}],15:[function(require,module,exports){
'use strict';

// VARIABLES //

var BTYPES = require( './btypes.js' );


// MGET //

/**
* FUNCTION: mget( i[, j] )
*	Returns multiple matrix elements. If provided a single argument, `i` is treated as an array of linear indices.
*
* @param {Number[]|Null} i - linear/row indices
* @param {Number[]|Null} [j] - column indices
* @returns {Matrix} a new Matrix instance
*/
function mget( rows, cols ) {
	/*jshint validthis:true */
	var nRows,
		nCols,
		out,
		sgn,
		d,
		s0, s1, s2, s3,
		o,
		r, dr,
		i, j, m, n;

	s0 = this.strides[ 0 ];
	s1 = this.strides[ 1 ];
	o = this.offset;

	if ( arguments.length < 2 ) {
		i = rows;
		m = i.length;

		// Create a row vector (matrix):
		d = new BTYPES[ this.dtype ]( m );
		out = new this.constructor( d, this.dtype, [1,m], 0, [m,1] );

		sgn = ( s0 < 0 ) ? -1 : 1;
		for ( n = 0; n < m; n++ ) {
			j = i[ n ] % s0;
			r = sgn * ( i[n] - j );
			d[ n ] = this.data[ o + r + j*s1 ];
		}
	} else {
		if ( rows === null ) {
			nRows = this.shape[ 0 ];
			i = new Array( nRows );
			for ( n = 0; n < nRows; n++ ) {
				i[ n ] = n;
			}
		} else {
			nRows = rows.length;
			i = rows;
		}

		if ( cols === null ) {
			nCols = this.shape[ 1 ];
			j = new Array( nCols );
			for ( n = 0; n < nCols; n++ ) {
				j[ n ] = n;
			}
		} else {
			nCols = cols.length;
			j = cols;
		}

		d = new BTYPES[ this.dtype ]( nRows*nCols );
		out = new this.constructor( d, this.dtype, [nRows,nCols], 0, [nCols,1] );

		s2 = out.strides[ 0 ];
		s3 = out.strides[ 1 ];
		for ( m = 0; m < nRows; m++ ) {
			r = o + i[m]*s0;
			dr = m * s2;
			for ( n = 0; n < nCols; n++ ) {
				d[ dr + n*s3 ] = this.data[ r + j[n]*s1 ];
			}
		}
	}
	return out;
} // end FUNCTION mget()


// EXPORTS //

module.exports = mget;

},{"./btypes.js":1}],16:[function(require,module,exports){
'use strict';

// MODULES //

var isFunction = require( 'validate.io-function' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isNonNegativeIntegerArray = require( 'validate.io-nonnegative-integer-array' );


// FUNCTIONS //

var mset1 = require( './mset1.js' ),
	mset2 = require( './mset2.js' ),
	mset3 = require( './mset3.js' ),
	mset4 = require( './mset4.js' ),
	mset5 = require( './mset5.js' ),
	mset6 = require( './mset6.js' );

/**
* FUNCTION: getIndices( idx, len )
*	Validates and returns an array of indices.
*
* @private
* @param {Number[]|Null} idx - indices
* @param {Number} len - max index
* @returns {Number[]} indices
*/
function getIndices( idx, len ) {
	var out,
		i;
	if ( idx === null ) {
		out = new Array( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = i;
		}
	}
	else if ( isNonNegativeIntegerArray( idx ) ) {
		out = [];
		for ( i = 0; i < idx.length; i++ ) {
			if ( idx[ i ] < len ) {
				out.push( idx[ i ] );
			}
		}
	}
	else {
		throw new TypeError( 'mset()::invalid input argument. Row and column indices must be arrays of nonnegative integers. Value: `' + idx + '`.' );
	}
	return out;
} // end FUNCTION getIndices()


// MSET //

/**
* FUNCTION: mset( i[, j], value[, thisArg] )
*	Sets multiple matrix elements. If provided a single array, `i` is treated as an array of linear indices.
*
* @param {Number[]|Null} i - linear/row indices
* @param {Number[]|Null} [j] - column indices
* @param {Number|Matrix|Function} value - either a single numeric value, a matrix containing the values to set, or a function which returns a numeric value
* @returns {Matrix} Matrix instance
*/
function mset() {
	/*jshint validthis:true */
	var nargs = arguments.length,
		args,
		rows,
		cols,
		i;

	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}

	// 2 input arguments...
	if ( nargs < 3 ) {
		if ( !isNonNegativeIntegerArray( args[ 0 ] ) ) {
			throw new TypeError( 'mset()::invalid input argument. First argument must be an array of nonnegative integers. Value: `' + args[ 0 ] + '`.' );
		}
		// indices, clbk
		if ( isFunction( args[ 1 ] ) ) {
			mset2( this, args[ 0 ], args[ 1 ] );
		}
		// indices, number
		else if ( isNumber( args[ 1 ] ) ) {
			mset1( this, args[ 0 ], args[ 1 ] );
		}
		// indices, matrix
		else {
			// NOTE: no validation for Matrix instance.
			mset3( this, args[ 0 ], args[ 1 ] );
		}
	}
	// 3 input arguments...
	else if ( nargs === 3 ) {
		// indices, clbk, context
		if ( isFunction( args[ 1 ] ) ) {
			if ( !isNonNegativeIntegerArray( args[ 0 ] ) ) {
				throw new TypeError( 'mset()::invalid input argument. First argument must be an array of nonnegative integers. Value: `' + args[ 0 ] + '`.' );
			}
			mset2( this, args[ 0 ], args[ 1 ], args[ 2 ] );
		}
		// rows, cols, function
		else if ( isFunction( args[ 2 ] ) ) {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );
			mset4( this, rows, cols, args[ 2 ], this );
		}
		// rows, cols, number
		else if ( isNumber( args[ 2 ] ) ) {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );
			mset5( this, rows, cols, args[ 2 ] );
		}
		// rows, cols, matrix
		else {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );

			// NOTE: no validation for Matrix instance.
			mset6( this, rows, cols, args[ 2 ] );
		}
	}
	// 4 input arguments...
	else {
		// rows, cols, function, context
		if ( !isFunction( args[ 2 ] ) ) {
			throw new TypeError( 'mset()::invalid input argument. Callback argument must be a function. Value: `' + args[ 2 ] + '`.' );
		}
		rows = getIndices( args[ 0 ], this.shape[ 0 ] );
		cols = getIndices( args[ 1 ], this.shape[ 1 ] );
		mset4( this, rows, cols, args[ 2 ], args[ 3 ] );
	}
	return this;
} // end FUNCTION mset()


// EXPORTS //

module.exports = mset;

},{"./mset1.js":18,"./mset2.js":19,"./mset3.js":20,"./mset4.js":21,"./mset5.js":22,"./mset6.js":23,"validate.io-function":44,"validate.io-nonnegative-integer-array":46,"validate.io-number-primitive":50}],17:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var mset1 = require( './mset1.js' ),
	mset2 = require( './mset2.js' ),
	mset3 = require( './mset3.js' ),
	mset4 = require( './mset4.js' ),
	mset5 = require( './mset5.js' ),
	mset6 = require( './mset6.js' );

/**
* FUNCTION: getIndices( idx, len )
*	Returns an array of indices.
*
* @private
* @param {Number[]|Null} idx - indices
* @param {Number} len - max index
* @returns {Number[]} indices
*/
function getIndices( idx, len ) {
	var out,
		i;
	if ( idx === null ) {
		out = new Array( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = i;
		}
	} else {
		out = idx;
	}
	return out;
} // end FUNCTION getIndices()


// MSET //

/**
* FUNCTION: mset( i[, j], value[, thisArg] )
*	Sets multiple matrix elements. If provided a single array, `i` is treated as an array of linear indices.
*
* @param {Number[]|Null} i - linear/row indices
* @param {Number[]|Null} [j] - column indices
* @param {Number|Matrix|Function} value - either a single numeric value, a matrix containing the values to set, or a function which returns a numeric value
* @returns {Matrix} Matrix instance
*/
function mset() {
	/*jshint validthis:true */
	var nargs = arguments.length,
		args,
		rows,
		cols,
		i;

	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}

	// 2 input arguments...
	if ( nargs < 3 ) {
		// indices, clbk
		if ( typeof args[ 1 ] === 'function' ) {
			mset2( this, args[ 0 ], args[ 1 ] );
		}
		// indices, number
		else if ( typeof args[ 1 ] === 'number' ) {
			mset1( this, args[ 0 ], args[ 1 ] );
		}
		// indices, matrix
		else {
			mset3( this, args[ 0 ], args[ 1 ] );
		}
	}
	// 3 input arguments...
	else if ( nargs === 3 ) {
		// indices, clbk, context
		if ( typeof args[ 1 ] === 'function' ) {
			mset2( this, args[ 0 ], args[ 1 ], args[ 2 ] );
		}
		// rows, cols, function
		else if ( typeof args[ 2 ] === 'function' ) {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );
			mset4( this, rows, cols, args[ 2 ], this );
		}
		// rows, cols, number
		else if ( typeof args[ 2 ] === 'number' ) {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );
			mset5( this, rows, cols, args[ 2 ] );
		}
		// rows, cols, matrix
		else {
			rows = getIndices( args[ 0 ], this.shape[ 0 ] );
			cols = getIndices( args[ 1 ], this.shape[ 1 ] );
			mset6( this, rows, cols, args[ 2 ] );
		}
	}
	// 4 input arguments...
	else {
		rows = getIndices( args[ 0 ], this.shape[ 0 ] );
		cols = getIndices( args[ 1 ], this.shape[ 1 ] );
		mset4( this, rows, cols, args[ 2 ], args[ 3 ] );
	}
	return this;
} // end FUNCTION mset()


// EXPORTS //

module.exports = mset;

},{"./mset1.js":18,"./mset2.js":19,"./mset3.js":20,"./mset4.js":21,"./mset5.js":22,"./mset6.js":23}],18:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset1( mat, idx, v )
*	Sets multiple matrix elements to a numeric value `v`.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} idx - linear indices
* @param {Number} v - numeric value
*/
function mset1( mat, idx, v ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		len = idx.length,
		o = mat.offset,
		sgn,
		r, j, n;

	sgn = ( s0 < 0 ) ? -1 : 1;
	for ( n = 0; n < len; n++ ) {
		j = idx[ n ] % s0;
		r = sgn * ( idx[n] - j );
		mat.data[ o + r + j*s1 ] = v;
	}
} // end FUNCTION mset1()


// EXPORTS //

module.exports = mset1;

},{}],19:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset2( mat, idx, clbk, ctx )
*	Sets multiple matrix elements using a callback function.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} idx - linear indices
* @param {Function} clbk - callback function
* @param {Object} ctx - `this` context when invoking the provided callback
*/
function mset2( mat, idx, clbk, ctx ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		len = idx.length,
		o = mat.offset,
		sgn,
		r, c,
		i, k, n;

	sgn = ( s0 < 0 ) ? -1 : 1;
	for ( n = 0; n < len; n++ ) {
		// Get the column number:
		c = idx[ n ] % s0;

		// Determine the row offset:
		i = sgn * ( idx[n] - c );

		// Get the row number:
		r = i / s0;

		// Calculate the index:
		k = o + i + c*s1;

		// Set the value:
		mat.data[ k ] = clbk.call( ctx, mat.data[ k ], r, c, k );
	}
} // end FUNCTION mset2()


// EXPORTS //

module.exports = mset2;

},{}],20:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset3( mat, idx, m )
*	Sets multiple matrix elements using elements from another matrix.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} idx - linear indices
* @param {Matrix} m - Matrix instance
*/
function mset3( mat, idx, m ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		s2 = m.strides[ 0 ],
		s3 = m.strides[ 1 ],
		len = idx.length,
		o0 = mat.offset,
		o1 = m.offset,
		sgn0, sgn1,
		r0, r1,
		j0, j1,
		n;

	if ( m.length !== len ) {
		throw new Error( 'mset()::invalid input argument. Number of indices does not match the number of elements in the value matrix.' );
	}
	sgn0 = ( s0 < 0 ) ? -1 : 1;
	sgn1 = ( s2 < 0 ) ? -1 : 1;
	for ( n = 0; n < len; n++ ) {
		// Get the column number and row offset for the first matrix:
		j0 = idx[ n ] % s0;
		r0 = sgn0 * ( idx[n] - j0 );

		// Get the column number and row offset for the value matrix:
		j1 = n % s2;
		r1 = sgn1 * ( n - j1 );

		mat.data[ o0 + r0 + j0*s1 ] = m.data[ o1 + r1 + j1*s3  ];
	}
} // end FUNCTION mset3()


// EXPORTS //

module.exports = mset3;

},{}],21:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset4( mat, rows, cols, clbk, ctx )
*	Sets multiple matrix elements using a callback function.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} rows - row indices
* @param {Number[]} cols - column indices
* @param {Function} clbk - callback function
* @param {Object} ctx - `this` context when invoking the provided callback
*/
function mset4( mat, rows, cols, clbk, ctx ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		nRows = rows.length,
		nCols = cols.length,
		o = mat.offset,
		r,
		i, j, k;

	for ( i = 0; i < nRows; i++ ) {
		r = o + rows[i]*s0;
		for ( j = 0; j < nCols; j++ ) {
			k = r + cols[j]*s1;
			mat.data[ k ] = clbk.call( ctx, mat.data[ k ], rows[ i ], cols[ j ], k );
		}
	}
} // end FUNCTION mset4()


// EXPORTS //

module.exports = mset4;

},{}],22:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset5( mat, rows, cols, v )
*	Sets multiple matrix elements to a numeric value `v`.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} rows - row indices
* @param {Number[]} cols - column indices
* @param {Number} v - numeric value
*/
function mset5( mat, rows, cols, v ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		nRows = rows.length,
		nCols = cols.length,
		o = mat.offset,
		r,
		i, j;

	for ( i = 0; i < nRows; i++ ) {
		r = o + rows[i]*s0;
		for ( j = 0; j < nCols; j++ ) {
			mat.data[ r + cols[j]*s1 ] = v;
		}
	}
} // end FUNCTION mset5()


// EXPORTS //

module.exports = mset5;

},{}],23:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mset6( mat, rows, cols, m )
*	Sets multiple matrix elements using elements from another matrix.
*
* @private
* @param {Matrix} mat - Matrix instance
* @param {Number[]} rows - row indices
* @param {Number[]} cols - column indices
* @param {Matrix} m - Matrix instance
*/
function mset6( mat, rows, cols, m ) {
	var s0 = mat.strides[ 0 ],
		s1 = mat.strides[ 1 ],
		s2 = m.strides[ 0 ],
		s3 = m.strides[ 1 ],
		nRows = rows.length,
		nCols = cols.length,
		o0 = mat.offset,
		o1 = m.offset,
		r0, r1,
		i, j;

	if ( m.shape[ 0 ] !== nRows || m.shape[ 1 ] !== nCols ) {
		throw new Error( 'mset()::invalid input argument. The dimensions given by the row and column indices do not match the value matrix dimensions.' );
	}
	for ( i = 0; i < nRows; i++ ) {
		r0 = o0 + rows[i]*s0;
		r1 = o1 + i*s2;
		for ( j = 0; j < nCols; j++ ) {
			mat.data[ r0 + cols[j]*s1 ] = m.data[ r1 + j*s3 ];
		}
	}
} // end FUNCTION mset6()


// EXPORTS //

module.exports = mset6;

},{}],24:[function(require,module,exports){
'use strict';

// MODULES //

var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' ),
	isNumber = require( 'validate.io-number-primitive' );


// SET //

/**
* FUNCTION: set( i, j, value )
*	Sets a matrix element based on the provided row and column indices.
*
* @param {Number} i - row index
* @param {Number} j - column index
* @param {Number} value - value to set
* @returns {Matrix} Matrix instance
*/
function set( i, j, v ) {
	/* jshint validthis: true */
	if ( !isNonNegativeInteger( i ) || !isNonNegativeInteger( j ) ) {
		throw new TypeError( 'set()::invalid input argument. Row and column indices must be nonnegative integers. Values: `[' + i + ',' + j + ']`.' );
	}
	if ( !isNumber( v ) ) {
		throw new TypeError( 'set()::invalid input argument. An input value must be a number primitive. Value: `' + v + '`.' );
	}
	i = this.offset + i*this.strides[0] + j*this.strides[1];
	if ( i >= 0 ) {
		this.data[ i ] = v;
	}
	return this;
} // end FUNCTION set()


// EXPORTS //

module.exports = set;

},{"validate.io-nonnegative-integer":47,"validate.io-number-primitive":50}],25:[function(require,module,exports){
'use strict';

/**
* FUNCTION: set( i, j, value )
*	Sets a matrix element based on the provided row and column indices.
*
* @param {Number} i - row index
* @param {Number} j - column index
* @param {Number} value - value to set
* @returns {Matrix} Matrix instance
*/
function set( i, j, v ) {
	/* jshint validthis: true */
	i = this.offset + i*this.strides[0] + j*this.strides[1];
	if ( i >= 0 ) {
		this.data[ i ] = v;
	}
	return this;
} // end FUNCTION set()


// EXPORTS //

module.exports = set;

},{}],26:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	ispace = require( 'compute-indexspace' );


// VARIABLES //

var BTYPES = require( './btypes.js' );


// SUBSEQUENCE GET //

/**
* FUNCTION: sget( subsequence )
*	Returns matrix elements according to a specified subsequence.
*
* @param {String} subsequence - subsequence string
* @returns {Matrix} Matrix instance
*/
function sget( seq ) {
	/*jshint validthis:true */
	var nRows,
		nCols,
		rows,
		cols,
		seqs,
		mat,
		len,
		s0, s1,
		o,
		d,
		r, dr,
		i, j;

	if ( !isString( seq ) ) {
		throw new TypeError( 'sget()::invalid input argument. Must provide a string primitive. Value: `' + seq + '`.' );
	}
	seqs = seq.split( ',' );
	if ( seqs.length !== 2 ) {
		throw new Error( 'sget()::invalid input argument. Subsequence string must specify row and column subsequences. Value: `' + seq + '`.' );
	}
	rows = ispace( seqs[ 0 ], this.shape[ 0 ] );
	cols = ispace( seqs[ 1 ], this.shape[ 1 ] );

	nRows = rows.length;
	nCols = cols.length;
	len = nRows * nCols;

	d = new BTYPES[ this.dtype ]( len );
	mat = new this.constructor( d, this.dtype, [nRows,nCols], 0, [nCols,1] );

	if ( len ) {
		s0 = this.strides[ 0 ];
		s1 = this.strides[ 1 ];
		o = this.offset;
		for ( i = 0; i < nRows; i++ ) {
			r = o + rows[i]*s0;
			dr = i * nCols;
			for ( j = 0; j < nCols; j++ ) {
				d[ dr + j ] = this.data[ r + cols[j]*s1 ];
			}
		}
	}
	return mat;
} // end FUNCTION sget()


// EXPORTS //

module.exports = sget;

},{"./btypes.js":1,"compute-indexspace":39,"validate.io-string-primitive":51}],27:[function(require,module,exports){
'use strict';

// MODULES //

var ispace = require( 'compute-indexspace' );


// VARIABLES //

var BTYPES = require( './btypes.js' );


// SUBSEQUENCE GET //

/**
* FUNCTION: sget( subsequence )
*	Returns matrix elements according to a specified subsequence.
*
* @param {String} subsequence - subsequence string
* @returns {Matrix} Matrix instance
*/
function sget( seq ) {
	/*jshint validthis:true */
	var nRows,
		nCols,
		rows,
		cols,
		seqs,
		mat,
		len,
		s0, s1,
		o,
		d,
		r, dr,
		i, j;

	seqs = seq.split( ',' );
	rows = ispace( seqs[ 0 ], this.shape[ 0 ] );
	cols = ispace( seqs[ 1 ], this.shape[ 1 ] );

	nRows = rows.length;
	nCols = cols.length;
	len = nRows * nCols;

	d = new BTYPES[ this.dtype ]( len );
	mat = new this.constructor( d, this.dtype, [nRows,nCols], 0, [nCols,1] );

	if ( len ) {
		s0 = this.strides[ 0 ];
		s1 = this.strides[ 1 ];
		o = this.offset;
		for ( i = 0; i < nRows; i++ ) {
			r = o + rows[i]*s0;
			dr = i * nCols;
			for ( j = 0; j < nCols; j++ ) {
				d[ dr + j ] = this.data[ r + cols[j]*s1 ];
			}
		}
	}
	return mat;
} // end FUNCTION sget()


// EXPORTS //

module.exports = sget;

},{"./btypes.js":1,"compute-indexspace":39}],28:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isFunction = require( 'validate.io-function' ),
	ispace = require( 'compute-indexspace' );


// SUBSEQUENCE SET //

/**
* FUNCTION: sset( subsequence, value[, thisArg] )
*	Sets matrix elements according to a specified subsequence.
*
* @param {String} subsequence - subsequence string
* @param {Number|Matrix|Function} value - either a single numeric value, a matrix containing the values to set, or a function which returns a numeric value
* @param {Object} [thisArg] - `this` context when executing a callback
* @returns {Matrix} Matrix instance
*/
function sset( seq, val, thisArg ) {
	/* jshint validthis: true */
	var nRows,
		nCols,
		clbk,
		rows,
		cols,
		seqs,
		mat,
		ctx,
		s0, s1, s2, s3,
		o0, o1,
		r0, r1,
		i, j, k;

	if ( !isString( seq ) ) {
		throw new TypeError( 'sset()::invalid input argument. Must provide a string primitive. Value: `' + seq + '`.' );
	}
	seqs = seq.split( ',' );
	if ( seqs.length !== 2 ) {
		throw new Error( 'sset()::invalid input argument. Subsequence string must specify row and column subsequences. Value: `' + seq + '`.' );
	}
	if ( isFunction( val ) ) {
		clbk = val;
	}
	else if ( !isNumber( val ) ) {
		mat = val;
	}
	rows = ispace( seqs[ 0 ], this.shape[ 0 ] );
	cols = ispace( seqs[ 1 ], this.shape[ 1 ] );

	nRows = rows.length;
	nCols = cols.length;

	if ( !( nRows && nCols ) ) {
		return this;
	}
	s0 = this.strides[ 0 ];
	s1 = this.strides[ 1 ];
	o0 = this.offset;

	// Callback...
	if ( clbk ) {
		if ( arguments.length > 2 ) {
			ctx = thisArg;
		} else {
			ctx = this;
		}
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			for ( j = 0; j < nCols; j++ ) {
				k = r0 + cols[j]*s1;
				this.data[ k ] = clbk.call( ctx, this.data[ k ], rows[i], cols[j], k );
			}
		}
	}
	// Input matrix...
	else if ( mat ) {
		if ( nRows !== mat.shape[ 0 ] ) {
			throw new Error( 'sset()::invalid input arguments. Row subsequence does not match input matrix dimensions. Expected a [' + nRows + ',' + nCols + '] matrix and instead received a [' + mat.shape.join( ',' ) + '] matrix.' );
		}
		if ( nCols !== mat.shape[ 1 ] ) {
			throw new Error( 'sset()::invalid input arguments. Column subsequence does not match input matrix dimensions. Expected a [' + nRows + ',' + nCols + '] matrix and instead received a [' + mat.shape.join( ',' ) + '] matrix.' );
		}
		s2 = mat.strides[ 0 ];
		s3 = mat.strides[ 1 ];
		o1 = mat.offset;
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			r1 = o1 + i*s2;
			for ( j = 0; j < nCols; j++ ) {
				this.data[ r0 + cols[j]*s1 ] = mat.data[ r1 + j*s3 ];
			}
		}
	}
	// Single numeric value...
	else {
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			for ( j = 0; j < nCols; j++ ) {
				this.data[ r0 + cols[j]*s1 ] = val;
			}
		}
	}
	return this;
} // end FUNCTION sset()


// EXPORTS //

module.exports = sset;

},{"compute-indexspace":39,"validate.io-function":44,"validate.io-number-primitive":50,"validate.io-string-primitive":51}],29:[function(require,module,exports){
'use strict';

// MODULES //

var ispace = require( 'compute-indexspace' );


// SUBSEQUENCE SET //

/**
* FUNCTION: sset( subsequence, value[, thisArg] )
*	Sets matrix elements according to a specified subsequence.
*
* @param {String} subsequence - subsequence string
* @param {Number|Matrix|Function} value - either a single numeric value, a matrix containing the values to set, or a function which returns a numeric value
* @param {Object} [thisArg] - `this` context when executing a callback
* @returns {Matrix} Matrix instance
*/
function sset( seq, val, thisArg ) {
	/* jshint validthis: true */
	var nRows,
		nCols,
		clbk,
		rows,
		cols,
		seqs,
		mat,
		ctx,
		s0, s1, s2, s3,
		o0, o1,
		r0, r1,
		i, j, k;

	seqs = seq.split( ',' );
	if ( typeof val === 'function' ) {
		clbk = val;
	}
	else if ( typeof val !== 'number' ) {
		mat = val;
	}
	rows = ispace( seqs[ 0 ], this.shape[ 0 ] );
	cols = ispace( seqs[ 1 ], this.shape[ 1 ] );

	nRows = rows.length;
	nCols = cols.length;

	if ( !( nRows && nCols ) ) {
		return this;
	}
	s0 = this.strides[ 0 ];
	s1 = this.strides[ 1 ];
	o0 = this.offset;

	// Callback...
	if ( clbk ) {
		if ( arguments.length > 2 ) {
			ctx = thisArg;
		} else {
			ctx = this;
		}
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			for ( j = 0; j < nCols; j++ ) {
				k = r0 + cols[j]*s1;
				this.data[ k ] = clbk.call( ctx, this.data[ k ], rows[i], cols[j], k );
			}
		}
	}
	// Input matrix...
	else if ( mat ) {
		if ( nRows !== mat.shape[ 0 ] ) {
			throw new Error( 'sset()::invalid input arguments. Row subsequence does not match input matrix dimensions. Expected a [' + nRows + ',' + nCols + '] matrix and instead received a [' + mat.shape.join( ',' ) + '] matrix.' );
		}
		if ( nCols !== mat.shape[ 1 ] ) {
			throw new Error( 'sset()::invalid input arguments. Column subsequence does not match input matrix dimensions. Expected a [' + nRows + ',' + nCols + '] matrix and instead received a [' + mat.shape.join( ',' ) + '] matrix.' );
		}
		s2 = mat.strides[ 0 ];
		s3 = mat.strides[ 1 ];
		o1 = mat.offset;
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			r1 = o1 + i*s2;
			for ( j = 0; j < nCols; j++ ) {
				this.data[ r0 + cols[j]*s1 ] = mat.data[ r1 + j*s3 ];
			}
		}
	}
	// Single numeric value...
	else {
		for ( i = 0; i < nRows; i++ ) {
			r0 = o0 + rows[i]*s0;
			for ( j = 0; j < nCols; j++ ) {
				this.data[ r0 + cols[j]*s1 ] = val;
			}
		}
	}
	return this;
} // end FUNCTION sset()


// EXPORTS //

module.exports = sset;

},{"compute-indexspace":39}],30:[function(require,module,exports){
'use strict';

/**
* FUNCTION: toString()
*	Returns a string representation of Matrix elements. Rows are delineated by semicolons. Column values are comma-delimited.
*
* @returns {String} string representation
*/
function toString() {
	/* jshint validthis: true */
	var nRows = this.shape[ 0 ],
		nCols = this.shape[ 1 ],
		s0 = this.strides[ 0 ],
		s1 = this.strides[ 1 ],
		m = nRows - 1,
		n = nCols - 1,
		str = '',
		o,
		i, j;

	for ( i = 0; i < nRows; i++ ) {
		o = this.offset + i*s0;
		for ( j = 0; j < nCols; j++ ) {
			str += this.data[ o + j*s1 ];
			if ( j < n ) {
				str += ',';
			}
		}
		if ( i < m ) {
			str += ';';
		}
	}
	return str;
} // end FUNCTION toString()


// EXPORTS //

module.exports = toString;

},{}],31:[function(require,module,exports){
'use strict';

// MODULES //

var arrayLike = require( 'validate.io-array-like' ),
	typeName = require( 'type-name' );


// VARIABLES //

var DTYPES = require( 'compute-array-dtype/lib/dtypes' ),
	CTORS = require( 'compute-array-constructors/lib/ctors' );


// CAST //

/**
* FUNCTION: cast( x, type )
*	Casts an input array or array-like object to a specified type.
*
* @param {Object|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} x - value to cast
* @param {String|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} type - type to which to cast or a value from which the desired type should be inferred
* @returns {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} casted value
*/
function cast( x, type ) {
	/* jshint newcap:false */
	var ctor,
		len,
		d,
		i;

	if ( !arrayLike( x ) ) {
		throw new TypeError( 'cast()::invalid input argument. First argument must be an array-like object. Value: `' + x + '`.' );
	}
	if ( typeof type === 'string' ) {
		ctor = CTORS[ type ];
	} else {
		ctor = CTORS[ DTYPES[ typeName( type ) ] ];
	}
	if ( ctor === void 0 ) {
		throw new Error( 'cast()::invalid input argument. Unrecognized/unsupported type to which to cast. Value: `' + type + '`.' );
	}
	len = x.length;
	d = new ctor( len );
	for ( i = 0; i < len; i++ ) {
		d[ i ] = x[ i ];
	}
	return d;
} // end FUNCTION cast()


// EXPORTS //

module.exports = cast;

},{"compute-array-constructors/lib/ctors":32,"compute-array-dtype/lib/dtypes":33,"type-name":40,"validate.io-array-like":34}],32:[function(require,module,exports){
'use strict';

var CTORS = {
	'int8': Int8Array,
	'uint8': Uint8Array,
	'uint8_clamped': Uint8ClampedArray,
	'int16': Int16Array,
	'uint16': Uint16Array,
	'int32': Int32Array,
	'uint32': Uint32Array,
	'float32': Float32Array,
	'float64': Float64Array,
	'generic': Array
};


// EXPORTS //

module.exports = CTORS;

},{}],33:[function(require,module,exports){
'use strict';

var DTYPES = {
	'Int8Array': 'int8',
	'Uint8Array': 'uint8',
	'Uint8ClampedArray': 'uint8_clamped',
	'Int16Array': 'int16',
	'Uint16Array': 'uint16',
	'Int32Array': 'int32',
	'Uint32Array': 'uint32',
	'Float32Array': 'float32',
	'Float64Array': 'float64',
	'Array': 'generic'
};


// EXPORTS //

module.exports = DTYPES;

},{}],34:[function(require,module,exports){
'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer-primitive' );


// CONSTANTS //

var MAX = require( 'compute-const-max-safe-integer' );


// IS ARRAY-LIKE //

/**
* FUNCTION: isArrayLike( value )
*	Validates if a value is array-like.
*
* @param {*} value - value to validate
* @param {Boolean} boolean indicating if a value is array-like
*/
function isArrayLike( value ) {
	return value !== void 0 && value !== null && typeof value !== 'function' && isInteger( value.length ) && value.length >= 0 && value.length <= MAX;
} // end FUNCTION isArrayLike()


// EXPORTS //

module.exports = isArrayLike;

},{"compute-const-max-safe-integer":35,"validate.io-integer-primitive":45}],35:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = 9007199254740991; // Math.pow( 2, 53 ) - 1

},{}],36:[function(require,module,exports){
'use strict';

// MODULES //

var typeName = require( 'type-name' ),
	getType = require( 'compute-array-dtype' );


// DTYPE //

/**
* FUNCTION: dtype( value )
*	Determines the data type of an input value.
*
* @param {*} value - input value
* @returns {String} data type
*/
function dtype( value ) {
	var type,
		dt;
	if ( value === null ) {
		return 'null';
	}
	// Check for base types:
	type = typeof value;
	switch ( type ) {
		case 'undefined':
		case 'boolean':
		case 'number':
		case 'string':
		case 'function':
		case 'symbol':
			return type;
	}
	// Resort to slower look-up:
	type = typeName( value );

	// Is value a known array type?
	dt = getType( type );
	if ( dt ) {
		return dt;
	}
	// Is value a buffer object?
	if ( type === 'Buffer' || type === 'ArrayBuffer' ) {
		return 'binary';
	}
	// Assume the value is a generic object (Object|Class instance) which could contain any or multiple data types...
	return 'generic';
} // end FUNCTION dtype()


// EXPORTS //

module.exports = dtype;

},{"compute-array-dtype":38,"type-name":40}],37:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],38:[function(require,module,exports){
'use strict';

// DTYPES //

var DTYPES = require( './dtypes.js' );


// GET DTYPE //

/**
* FUNCTION: getType( name )
*	Returns an array data type corresponding to an array constructor name.
*
* @param {String} name - constructor name
* @returns {String|Null} array data type or null
*/
function getType( name ) {
	return DTYPES[ name ] || null;
} // end FUNCTION getType()


// EXPORTS //

module.exports = getType;

},{"./dtypes.js":37}],39:[function(require,module,exports){
/**
*
*	COMPUTE: indexspace
*
*
*	DESCRIPTION:
*		- Generates a linearly spaced index array from a subsequence string.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// VARIABLES //

var re = /^(?:(?:-(?=\d+))?\d*|end(?:-\d+|\/\d+)?):(?:(?:-(?=\d+))?\d*|end(?:-\d+|\/\d+)?)(?:\:(?=-?\d*)(?:-?\d+)?)?$/;

/**
*	^(...)
*	=> require that the string begin with either a digit (+ or -), an `end` keyword, or a colon
*
*	(?:(?:-(?=\d+))?\d*|end(?:-?\d+|/\\d+)?)
*	=> match but do not capture
*		(?:-(?=\d+))?
*		=> match but do not capture a minus sign but only if followed by one or more digits
*		\d*
*		=> 0 or more digits
*		|
*		=> OR
*		end(?:-\d+|/\d+)?
*		=> the word `end` exactly, which may be followed by either a minus sign and 1 or more digits or a division sign and 1 or more digits
*
*	:
*	=> match a colon exactly
*
*	(?:(?:-(?=\d+))?\d*|end(?:-\d+|/\\d+)?)
*	=> same as above
*
*	(?:\:(?=-?\d*)(?:-?\d+)?)?
*	=> match but do not capture
*		\:(?=-?\d*)
*		=> a colon but only if followed by either a possible minus sign and 0 or more digits
*		(?:-?\d+)?
*		=> match but do not capture a possible minus sign and 1 or more digits
*
*	$
*	=> require that the string end with either a digit, `end` keyword, or a colon.
*
*
* Examples:
*	-	:
*	-	::
*	-	4:
*	-	:4
*	-	::-1
*	-	3::-1
*	-	:10:2
*	-	1:3:1
*	-	9:1:-3
*	-	1:-1
*	-	:-1
*	-	-5:
*	-	1:-5:2
*	-	-9:10:1
*	-	-9:-4:2
*	-	-4:-9:-2
*	-	1:end:2
*	-	:end/2
*	-	end/2:end:5
*/

var reEnd = /^end/,
	reMatch = /(-|\/)(?=\d+)(\d+)?$/;


// INDEXSPACE

/**
* FUNCTION: indexspace( str, len )
*	Generates a linearly spaced index array from a subsequence string.
*
* @param {String} str - subsequence string
* @param {Number} len - reference array length
* @returns {Number[]} array of indices
*/
function indexspace( str, len ) {
	var x1,
		x2,
		tmp,
		inc,
		arr;
	if ( !isString( str ) || !re.test( str ) ) {
		throw new Error( 'indexspace()::invalid input argument. Invalid subsequence syntax. Please consult documentation. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'indexspace()::invalid input argument. Reference array length must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( !len ) {
		return [];
	}
	str = str.split( ':' );
	x1 = str[ 0 ];
	x2 = str[ 1 ];

	if ( str.length === 2 ) {
		inc = 1;
	} else {
		inc = parseInt( str[ 2 ], 10 );
	}
	// Handle zero increment...
	if ( inc === 0 ) {
		throw new Error( 'indexspace()::invalid syntax. Increment must be an integer not equal to 0. Value: `' + inc + '`.' );
	}

	// START //

	// Handle use of 'end' keyword...
	if ( reEnd.test( x1 ) ) {
		tmp = x1.match( reMatch );
		if ( tmp ) {
			if ( tmp[ 1 ] === '-' ) {
				x1 = len - 1 - parseInt( tmp[ 2 ], 10 );
				if ( x1 < 0 ) {
					// WARNING: forgive the user for exceeding the range bounds...
					x1 = 0;
				}
			} else {
				x1 = (len-1) / parseInt( tmp[ 2 ], 10 );
				x1 = Math.ceil( x1 );
			}
		} else {
			x1 = len - 1;
		}
	} else {
		x1 = parseInt( x1, 10 );

		// Handle empty index...
		if ( x1 !== x1 ) {
			// :-?\d*:-?\d+
			if ( inc < 0 ) {
				// Max index:
				x1 = len - 1;
			} else {
				// Min index:
				x1 = 0;
			}
		}
		// Handle negative index...
		else if ( x1 < 0 ) {
			x1 = len + x1; // len-x1
			if ( x1 < 0 ) {
				// WARNING: forgive the user for exceeding index bounds...
				x1 = 0;
			}
		}
		// Handle exceeding bounds...
		else if ( x1 >= len ) {
			return [];
		}
	}

	// END //

	// NOTE: here, we determine an inclusive `end` value; i.e., the last acceptable index value.

	// Handle use of 'end' keyword...
	if ( reEnd.test( x2 ) ) {
		tmp = x2.match( reMatch );
		if ( tmp ) {
			if ( tmp[ 1 ] === '-' ) {
				x2 = len - 1 - parseInt( tmp[ 2 ], 10 );
				if ( x2 < 0 ) {
					// WARNING: forgive the user for exceeding the range bounds...
					x2 = 0;
				}
			} else {
				x2 = (len-1) / parseInt( tmp[ 2 ], 10 );
				x2 = Math.ceil( x2 ) - 1;
			}
		} else {
			x2 = len - 1;
		}
	} else {
		x2 = parseInt( x2, 10 );

		// Handle empty index...
		if ( x2 !== x2 ) {
			// -?\d*::-?\d+
			if ( inc < 0 ) {
				// Min index:
				x2 = 0;
			} else {
				// Max index:
				x2 = len - 1;
			}
		}
		// Handle negative index...
		else if ( x2 < 0 ) {
			x2 = len + x2; // len-x2
			if ( x2 < 0 ) {
				// WARNING: forgive the user for exceeding index bounds...
				x2 = 0;
			}
			if ( inc > 0 ) {
				x2 = x2 - 1;
			}
		}
		// Handle positive index...
		else {
			if ( inc < 0 ) {
				x2 = x2 + 1;
			}
			else if ( x2 >= len ) {
				x2 = len - 1;
			}
			else {
				x2 = x2 - 1;
			}
		}
	}

	// INDICES //

	arr = [];
	if ( inc < 0 ) {
		if ( x2 > x1 ) {
			return arr;
		}
		while ( x1 >= x2 ) {
			arr.push( x1 );
			x1 += inc;
		}
	} else {
		if ( x1 > x2 ) {
			return arr;
		}
		while ( x1 <= x2 ) {
			arr.push( x1 );
			x1 += inc;
		}
	}
	return arr;
} // end FUNCTION indexspace()


// EXPORTS //

module.exports = indexspace;

},{"validate.io-nonnegative-integer":47,"validate.io-string-primitive":51}],40:[function(require,module,exports){
/**
 * type-name - Just a reasonable typeof
 * 
 * https://github.com/twada/type-name
 *
 * Copyright (c) 2014 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/
 */
'use strict';

var toStr = Object.prototype.toString;

function funcName (f) {
    return f.name ? f.name : /^\s*function\s*([^\(]*)/im.exec(f.toString())[1];
}

function ctorName (obj) {
    var strName = toStr.call(obj).slice(8, -1);
    if (strName === 'Object' && obj.constructor) {
        return funcName(obj.constructor);
    }
    return strName;
}

function typeName (val) {
    var type;
    if (val === null) {
        return 'null';
    }
    type = typeof(val);
    if (type === 'object') {
        return ctorName(val);
    }
    return type;
}

module.exports = typeName;

},{}],41:[function(require,module,exports){
'use strict';

/**
* FUNCTION: isArray( value )
*	Validates if a value is an array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an array
*/
function isArray( value ) {
	return Object.prototype.toString.call( value ) === '[object Array]';
} // end FUNCTION isArray()

// EXPORTS //

module.exports = Array.isArray || isArray;

},{}],42:[function(require,module,exports){
/**
*
*	VALIDATE: contains
*
*
*	DESCRIPTION:
*		- Validates if an array contains an input value.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isnan = require( 'validate.io-nan-primitive' );


// CONTAINS //

/**
* FUNCTION: contains( arr, value )
*	Validates if an array contains an input value.
*
* @param {Array} arr - search array
* @param {*} value - search value
* @returns {Boolean} boolean indicating if an array contains an input value
*/
function contains( arr, value ) {
	var len, i;
	if ( !isArray( arr ) ) {
		throw new TypeError( 'contains()::invalid input argument. First argument must be an array. Value: `' + arr + '`.' );
	}
	len = arr.length;
	if ( isnan( value ) ) {
		for ( i = 0; i < len; i++ ) {
			if ( isnan( arr[ i ] ) ) {
				return true;
			}
		}
		return false;
	}
	for ( i = 0; i < len; i++ ) {
		if ( arr[ i ] === value ) {
			return true;
		}
	}
	return false;
} // end FUNCTION contains()


// EXPORTS //

module.exports = contains;

},{"validate.io-array":41,"validate.io-nan-primitive":43}],43:[function(require,module,exports){
/**
*
*	VALIDATE: nan-primitive
*
*
*	DESCRIPTION:
*		- Validates if a value is a NaN primitive.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: nan( value )
*	Validates if a value is a NaN primitive.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether the value is a NaN primitive
*/
function nan( value ) {
	return typeof value === 'number' && value !== value;
} // end FUNCTION nan()


// EXPORTS //

module.exports = nan;

},{}],44:[function(require,module,exports){
/**
*
*	VALIDATE: function
*
*
*	DESCRIPTION:
*		- Validates if a value is a function.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isFunction( value )
*	Validates if a value is a function.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a function
*/
function isFunction( value ) {
	return ( typeof value === 'function' );
} // end FUNCTION isFunction()


// EXPORTS //

module.exports = isFunction;

},{}],45:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' );


// IS INTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is a number primitive, excluding `NaN`, and an integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a integer primitive
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number-primitive":50}],46:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer-array
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// IS NONNEGATIVE INTEGER ARRAY //

/**
* FUNCTION: isNonNegativeIntegerArray( value )
*	Validates if a value is a nonnegative integer array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer array
*/
function isNonNegativeIntegerArray( value ) {
	var len;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( var i = 0; i < len; i++ ) {
		if ( !isNonNegativeInteger( value[i] ) ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isNonNegativeIntegerArray()


// EXPORTS //

module.exports = isNonNegativeIntegerArray;

},{"validate.io-array":41,"validate.io-nonnegative-integer":47}],47:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS NONNEGATIVE INTEGER //

/**
* FUNCTION: isNonNegativeInteger( value )
*	Validates if a value is a nonnegative integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer
*/
function isNonNegativeInteger( value ) {
	return isInteger( value ) && value >= 0;
} // end FUNCTION isNonNegativeInteger()


// EXPORTS //

module.exports = isNonNegativeInteger;

},{"validate.io-integer":48}],48:[function(require,module,exports){
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number":49}],49:[function(require,module,exports){
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],50:[function(require,module,exports){
/**
*
*	VALIDATE: number-primitive
*
*
*	DESCRIPTION:
*		- Validates if a value is a number primitive.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number primitive, excluding `NaN`.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a number primitive
*/
function isNumber( value ) {
	return (typeof value === 'number') && (value === value);
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],51:[function(require,module,exports){
/**
*
*	VALIDATE: string-primitive
*
*
*	DESCRIPTION:
*		- Validates if a value is a string primitive.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: isString( value )
*	Validates if a value is a string primitive.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a string primitive
*/
function isString( value ) {
	return typeof value === 'string';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],52:[function(require,module,exports){
'use strict';

// FLOW //

/**
* FUNCTION: Flow()
*	Flow constructor.
*
* @constructor
* @returns {Flow} Flow instance
*/
function Flow() {
	if ( !(this instanceof Flow) ) {
		return new Flow();
	}
	this._value = null;
	return this;
} // end FUNCTION Flow()

/**
* METHOD: value( [value] )
*	Flow value setter and getter. If no `value` is provided, returns the flow `value`. If a `value` is provided, sets the flow `value`.
*
* @param {*} [value] - flow value
* @returns {Flow|*} Flow instance or value
*/
Flow.prototype.value = function( value ) {
	if ( !arguments.length ) {
		return this._value;
	}
	this._value = value;
	return this;
}; // end METHOD value()

/**
* METHOD: inspect()
*	Logs the current flow value to the console.
*
* @returns {Flow} Flow instance
*/
Flow.prototype.inspect = function() {
	console.log( this._value );
	return this;
}; // end METHOD inspect()


// CREATE INTERFACE //

/**
* FUNCTION: createMethod( name, func )
*	Creates a fluent method.
*
* @param {String} name - method name
* @param {Function} func - method to bind to Flow prototype
*/
function createMethod( name, func ) {
	Flow.prototype[ name ] = function() {
		var args = Array.prototype.slice.call( arguments );
		args.unshift( this._value );
		this._value = func.apply( null, args );
		return this;
	};
} // end FUNCTION createMethod()

/**
* FUNCTION: createFlow( compute )
*	Binds a fluent interface to the compute object.
*
* @param {Object} compute - object containing compute methods
* @returns {Flow} Flow constructor
*/
function createFlow( compute ) {
	var methods = Object.keys( compute ),
		method;

	methods.filter( function filter( method ) {
		return typeof compute[ method ] === 'function';
	});

	for ( var i = 0; i < methods.length; i++ ) {
		method = methods[ i ];
		createMethod( method, compute[ method ] );
	}

	return Flow;
} // end FUNCTION createFlow()


// EXPORTS //

module.exports = createFlow;

},{}],53:[function(require,module,exports){
'use strict';

// MODULES //

var createFlow = require( './flow.js' );


// COMPUTE //

var compute = {};

/**
* Utilities.
*/
compute.polyval = require( 'compute-polynomial' );
compute.find = require( 'compute-find' );
compute.dims = require( 'compute-dims' );
compute.issorted = require( 'compute-issorted' );
compute.flatten = require( 'compute-flatten' );

/**
* Array creation.
*/
compute.linspace = require( 'compute-linspace' );
compute.incrspace = require( 'compute-incrspace' );
compute.indexspace = require( 'compute-indexspace' );
compute.logspace = require( 'compute-logspace' );
compute.datespace = require( 'compute-datespace' );
compute.incrdatespace = require( 'compute-incrdatespace' );
compute.zip = require( 'compute-zip' );
compute.unzip = require( 'compute-unzip' );

/**
* Sorting and reshaping arrays.
*/
compute.reverse = require( 'compute-reverse' );
compute.shuffle = require( 'compute-shuffle' );
compute.circshift = require( 'compute-circshift' );

/**
* Special functions.
*/
compute.abs = require( 'compute-abs' );
compute.sqrt = require( 'compute-sqrt' );
compute.signum = require( 'compute-signum' );
compute.erf = require( 'compute-erf' );
compute.erfc = require( 'compute-erfc' );
compute.erfinv = require( 'compute-erfinv' );
compute.erfcinv = require( 'compute-erfcinv' );

/**
* Arithmetic.
*/
compute.add = require( 'compute-add' );
compute.subtract = require( 'compute-subtract' );
compute.multiply = require( 'compute-multiply' );
compute.divide = require( 'compute-divide' );
compute.roundn = require( 'compute-roundn' );
compute.diff = require( 'compute-diff' );

/**
* Relational Operations.
*/
compute.eq = require( 'compute-eq' );
compute.neq = require( 'compute-neq' );
compute.gt = require( 'compute-gt' );
compute.geq = require( 'compute-geq' );
compute.lt = require( 'compute-lt' );
compute.leq = require( 'compute-leq' );

/**
* Logical Operations.
*/
compute.isnumeric = require( 'compute-isnumeric' );
compute.isnan = require( 'compute-isnan' );
compute.isfinite = require( 'compute-isfinite' );
compute.isinteger = require( 'compute-isinteger' );
compute.isinf = require( 'compute-isinf' );

/**
* Trigonometry.
*/
compute.deg2rad = require( 'compute-deg2rad' );
compute.rad2deg = require( 'compute-rad2deg' );

/**
* Geometry.
*/
compute.hypot = require( 'compute-hypot' );

/**
* Sets.
*/
compute.unique = require( 'compute-unique' );

/**
* Discrete Mathematics.
*/
compute.gcd = require( 'compute-gcd' );
compute.lcm = require( 'compute-lcm' );

/**
* Linear Algebra.
*/
compute.l1norm = require( 'compute-l1norm' );
compute.l2norm = require( 'compute-l2norm' );
compute.linfnorm = require( 'compute-linfnorm' );
compute.lpnorm = require( 'compute-lpnorm' );
compute.dot = require( 'compute-dot' );
compute.cross = require( 'compute-cross' );

/**
* Statistics.
*/
compute.min = require( 'compute-min' );
compute.argmin = require( 'compute-argmin' );
compute.nanmin = require( 'compute-nanmin' );
compute.argnanmin = require( 'compute-argnanmin' );
compute.incrmin = require( 'compute-incrmin' );
compute.mmin = require( 'compute-mmin' );
compute.cmin = require( 'compute-cmin' );
compute.max = require( 'compute-max' );
compute.argmax = require( 'compute-argmax' );
compute.nanmax = require( 'compute-nanmax' );
compute.argnanmax = require( 'compute-argnanmax' );
compute.incrmax = require( 'compute-incrmax' );
compute.mmax = require( 'compute-mmax' );
compute.cmax = require( 'compute-cmax' );
compute.range = require( 'compute-range' );
compute.nanrange = require( 'compute-nanrange' );
compute.sum = require( 'compute-sum' );
compute.nansum = require( 'compute-nansum' );
compute.incrsum = require( 'compute-incrsum' );
compute.msum = require( 'compute-msum' );
compute.incrmsum = require( 'compute-incrmsum' );
compute.csum = require( 'compute-csum' );
compute.prod = require( 'compute-prod' );
compute.nanprod = require( 'compute-nanprod' );
compute.mprod = require( 'compute-mprod' );
compute.cprod = require( 'compute-cprod' );
compute.mean = require( 'compute-mean' );
compute.nanmean = require( 'compute-nanmean' );
compute.incrmean = require( 'compute-incrmean' );
compute.mmean = require( 'compute-mmean' );
compute.incrmmean = require( 'compute-incrmmean' );
compute.wmean = require( 'compute-wmean' );
compute.gmean = require( 'compute-gmean' );
compute.nangmean = require( 'compute-nangmean' );
compute.hmean = require( 'compute-hmean' );
compute.nanhmean = require( 'compute-nanhmean' );
compute.qmean = require( 'compute-qmean' );
compute.nanqmean = require( 'compute-nanqmean' );
compute.variance = require( 'compute-variance' );
compute.nanvariance = require( 'compute-nanvariance' );
compute.incrvariance = require( 'compute-incrvariance' );
compute.mvariance = require( 'compute-mvariance' );
compute.incrmvariance = require( 'compute-incrmvariance' );
compute.stdev = require( 'compute-stdev' );
compute.nanstdev = require( 'compute-nanstdev' );
compute.incrstdev = require( 'compute-incrstdev' );
compute.mstdev = require( 'compute-mstdev' );
compute.incrmstdev = require( 'compute-incrmstdev' );
compute.mode = require( 'compute-mode' );
compute.median = require( 'compute-median' );
compute.nanmedian = require( 'compute-nanmedian' );
compute.quantile = require( 'compute-quantile' );
compute.quantiles = require( 'compute-quantiles' );
compute.nanquantiles = require( 'compute-nanquantiles' );
compute.iqr = require( 'compute-iqr' );
compute.idr = require( 'compute-idr' );
compute.midrange = require( 'compute-midrange' );
compute.midhinge = require( 'compute-midhinge' );
compute.midsummary = require( 'compute-midsummary' );
compute.midmean = require( 'compute-midmean' );
compute.lmidmean = require( 'compute-lmidmean' );
compute.umidmean = require( 'compute-umidmean' );
compute.truncmean = require( 'compute-truncmean' );
compute.trimean = require( 'compute-trimean' );
compute.skewness = require( 'compute-skewness' );
compute.kurtosis = require( 'compute-kurtosis' );
compute.covariance = require( 'compute-covariance' );
compute.pcorr = require( 'compute-pcorr' );

/**
* Information theory.
*/
compute.hamdist = require( 'compute-hamming' );
compute.tversky = require( 'compute-tversky-index' );

/**
* Flow.
*/
compute.flow = createFlow( compute );


// EXPORTS //

module.exports = compute;

},{"./flow.js":52,"compute-abs":57,"compute-add":135,"compute-argmax":141,"compute-argmin":142,"compute-argnanmax":143,"compute-argnanmin":144,"compute-circshift":145,"compute-cmax":148,"compute-cmin":149,"compute-covariance":150,"compute-cprod":153,"compute-cross":158,"compute-csum":159,"compute-datespace":160,"compute-deg2rad":165,"compute-diff":166,"compute-dims":167,"compute-divide":170,"compute-dot":176,"compute-eq":179,"compute-erf":185,"compute-erfc":266,"compute-erfcinv":347,"compute-erfinv":428,"compute-find":506,"compute-flatten":511,"compute-gcd":525,"compute-geq":531,"compute-gmean":538,"compute-gt":541,"compute-hamming":548,"compute-hmean":552,"compute-hypot":553,"compute-idr":555,"compute-incrdatespace":558,"compute-incrmax":561,"compute-incrmean":562,"compute-incrmin":563,"compute-incrmmean":564,"compute-incrmstdev":568,"compute-incrmsum":572,"compute-incrmvariance":576,"compute-incrspace":580,"compute-incrstdev":582,"compute-incrsum":583,"compute-incrvariance":584,"compute-indexspace":585,"compute-iqr":590,"compute-isfinite":593,"compute-isinf":594,"compute-isinteger":595,"compute-isnan":596,"compute-isnumeric":597,"compute-issorted":598,"compute-kurtosis":599,"compute-l1norm":600,"compute-l2norm":601,"compute-lcm":604,"compute-leq":610,"compute-linfnorm":617,"compute-linspace":618,"compute-lmidmean":621,"compute-logspace":622,"compute-lpnorm":625,"compute-lt":628,"compute-max":635,"compute-mean":638,"compute-median":701,"compute-midhinge":706,"compute-midmean":709,"compute-midrange":710,"compute-midsummary":711,"compute-min":714,"compute-mmax":715,"compute-mmean":716,"compute-mmin":724,"compute-mode":725,"compute-mprod":726,"compute-mstdev":731,"compute-msum":732,"compute-multiply":740,"compute-mvariance":741,"compute-nangmean":742,"compute-nanhmean":743,"compute-nanmax":744,"compute-nanmean":745,"compute-nanmedian":746,"compute-nanmin":751,"compute-nanprod":752,"compute-nanqmean":755,"compute-nanquantiles":756,"compute-nanrange":763,"compute-nanstdev":766,"compute-nansum":767,"compute-nanvariance":770,"compute-neq":771,"compute-pcorr":774,"compute-polynomial":775,"compute-prod":784,"compute-qmean":847,"compute-quantile":848,"compute-quantiles":851,"compute-rad2deg":856,"compute-range":857,"compute-reverse":860,"compute-roundn":864,"compute-shuffle":865,"compute-signum":869,"compute-skewness":939,"compute-sqrt":943,"compute-stdev":1021,"compute-subtract":1022,"compute-sum":1030,"compute-trimean":1093,"compute-truncmean":1097,"compute-tversky-index":1106,"compute-umidmean":1114,"compute-unique":1115,"compute-unzip":1116,"compute-variance":1124,"compute-wmean":1188,"compute-zip":1189}],54:[function(require,module,exports){
'use strict';

// FUNCTIONS

var ABS = require( './number.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( out, arr, accessor )
*	Computes an element-wise absolute value using an accessor.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function abs( y, x, clbk ) {
	var len = x.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = ABS( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./number.js":59}],55:[function(require,module,exports){
'use strict';

// FUNCTIONS

var ABS = require( './number.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( out, arr )
*	Computes an absolute value for each array element.
*
* @private
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function abs( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = ABS( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./number.js":59}],56:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	ABS = require( './number.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( arr, path[, sep] )
*	Computes an element-wise absolute value and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function abs( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;

	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[ i ], ABS( v ) );
			} else {
				dset( x[ i ], NaN );
			}
		}
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./number.js":59,"utils-deep-get":112,"utils-deep-set":118}],57:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var abs1 = require( './number.js' ),
	abs2 = require( './array.js' ),
	abs3 = require( './accessor.js' ),
	abs4 = require( './deepset.js' ),
	abs5 = require( './matrix.js' ),
	abs6 = require( './typedarray.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( x[, opts] )
*	Computes the absolute value.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} absolute value(s)
*/
function abs( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return abs1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'abs()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return abs5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'abs()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return abs6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return abs4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new Error( 'abs()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return abs3( out, x, opts.accessor );
		}
		return abs2( out, x );
	}
	return NaN;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./accessor.js":54,"./array.js":55,"./deepset.js":56,"./matrix.js":58,"./number.js":59,"./typedarray.js":60,"./validate.js":61,"compute-array-constructors":63,"dstructs-matrix":72,"validate.io-array-like":121,"validate.io-matrix-like":126,"validate.io-nan":127,"validate.io-number-primitive":128,"validate.io-typed-array-like":132}],58:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ABS = require( './number.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( y, x )
*	Computes an element-wise absolute value.
*
* @param {Matrix} y - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function abs( y, x ) {
	var len = x.length,
		i;
	if ( y.length !== len ) {
		throw new Error( 'abs()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = ABS( x.data[ i ] );
	}
	return y;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./number.js":59}],59:[function(require,module,exports){
'use strict';

/**
* FUNCTION: abs( x )
*	Computes the absolute value of an input value.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	} else if ( x === 0 ) {
		// Handle -0...
		return 0;
	} else {
		return x;
	}
} // end FUNCTION abs


// EXPORTS //

module.exports = abs;

},{}],60:[function(require,module,exports){
'use strict';

// FUNCTIONS

var ABS = require( './number.js' );


// ABSOLUTE VALUE //

/**
* FUNCTION: abs( out, arr )
*	Computes an absolute value for each typed-array element.
*
* @private
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function abs( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = ABS( arr[ i ] );
	}
	return out;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{"./number.js":59}],61:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'abs()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'abs()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'abs()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'abs()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'abs()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'abs()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":124,"validate.io-function":125,"validate.io-object":129,"validate.io-string-primitive":131}],62:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],63:[function(require,module,exports){
'use strict';

// CTORS //

var CTORS = require( './ctors.js' );


// GET CTOR //

/**
* FUNCTION: getCtor( dtype )
*	Returns an array constructor corresponding to an input data type.
*
* @param {String} dtype - data type
* @returns {Function|Null} array constructor or null
*/
function getCtor( dtype ) {
	return CTORS[ dtype ] || null;
} // end FUNCTION getCtor()


// EXPORTS //

module.exports = getCtor;

},{"./ctors.js":62}],64:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],65:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":68,"./iget.js":70,"./iset.js":73,"./mget.js":77,"./mset.js":79,"./set.js":87,"./sget.js":89,"./sset.js":91,"./toString.js":93,"dup":2}],66:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":69,"./iget.raw.js":71,"./iset.raw.js":74,"./mget.raw.js":78,"./mset.raw.js":80,"./set.raw.js":88,"./sget.raw.js":90,"./sset.raw.js":92,"./toString.js":93,"dup":3}],67:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],68:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":106}],69:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],70:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":104}],71:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],72:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":75,"./matrix.raw.js":76,"dup":9}],73:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":104,"validate.io-number-primitive":128}],74:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],75:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":64,"./ctor.js":65,"./dtypes.js":67,"compute-cast-arrays":94,"compute-dtype":97,"dup":12,"validate.io-array":101,"validate.io-contains":102,"validate.io-nonnegative-integer-array":105,"validate.io-string-primitive":131}],76:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":64,"./ctor.raw.js":66,"./dtypes.js":67,"compute-dtype":97,"dup":13,"validate.io-contains":102,"validate.io-string-primitive":131}],77:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":64,"dup":14,"validate.io-nonnegative-integer-array":105}],78:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":64,"dup":15}],79:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":81,"./mset2.js":82,"./mset3.js":83,"./mset4.js":84,"./mset5.js":85,"./mset6.js":86,"dup":16,"validate.io-function":125,"validate.io-nonnegative-integer-array":105,"validate.io-number-primitive":128}],80:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":81,"./mset2.js":82,"./mset3.js":83,"./mset4.js":84,"./mset5.js":85,"./mset6.js":86,"dup":17}],81:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],82:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],83:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],84:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],85:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],86:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],87:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":106,"validate.io-number-primitive":128}],88:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],89:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":64,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":131}],90:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":64,"compute-indexspace":585,"dup":27}],91:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":125,"validate.io-number-primitive":128,"validate.io-string-primitive":131}],92:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],93:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],94:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":62,"compute-array-dtype/lib/dtypes":95,"dup":31,"type-name":96,"validate.io-array-like":121}],95:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],96:[function(require,module,exports){
/**
 * type-name - Just a reasonable typeof
 * 
 * https://github.com/twada/type-name
 *
 * Copyright (c) 2014-2015 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/2014-2015
 */
'use strict';

var toStr = Object.prototype.toString;

function funcName (f) {
    return f.name ? f.name : /^\s*function\s*([^\(]*)/im.exec(f.toString())[1];
}

function ctorName (obj) {
    var strName = toStr.call(obj).slice(8, -1);
    if (strName === 'Object' && obj.constructor) {
        return funcName(obj.constructor);
    }
    return strName;
}

function typeName (val) {
    var type;
    if (val === null) {
        return 'null';
    }
    type = typeof(val);
    if (type === 'object') {
        return ctorName(val);
    }
    return type;
}

module.exports = typeName;

},{}],97:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":99,"dup":36,"type-name":100}],98:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],99:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":98,"dup":38}],100:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],101:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],102:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":101,"validate.io-nan-primitive":103}],103:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],104:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":128}],105:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":101,"validate.io-nonnegative-integer":106}],106:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":107}],107:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":108}],108:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],109:[function(require,module,exports){
'use strict';

/**
* FUNCTION: deepGet( obj, props )
*	Deep get a nested property.
*
* @param {Object|Array} obj - input object
* @param {Array} props - list of properties defining a key path
* @returns {*} nested property value
*/
function deepGet( obj, props ) {
	var len = props.length,
		v = obj,
		i;

	for ( i = 0; i < len; i++ ) {
		if ( typeof v === 'object' && v !== null && v.hasOwnProperty( props[i] ) ) {
			v = v[ props[i] ];
		} else {
			return;
		}
	}
	return v;
} // end FUNCTION deepGet()


// EXPORTS //

module.exports = deepGet;

},{}],110:[function(require,module,exports){
'use strict';

/**
* FUNCTION: defaults()
*	Returns default options.
*
* @returns {Object} default options
*/
function defaults() {
	return {
		'sep': '.'
	};
} // end FUNCTION defaults()


// EXPORTS //

module.exports = defaults;

},{}],111:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isArray = require( 'validate.io-array' ),
	validate = require( './validate.js' ),
	defaults = require( './defaults.js' ),
	dget = require( './deepget.js' );


// FACTORY //

/**
* FUNCTION: factory( path[, opts] )
*	Creates a reusable deep get factory.
*
* @param {String|Array} path - key path
* @param {Object} [opts] - function options
* @param {String} [opts.sep='.'] - key path separator
* @returns {Function} deep get factory
*/
function factory( path, options ) {
	var isStr = isString( path ),
		props,
		opts,
		err;
	if ( !isStr && !isArray( path ) ) {
		throw new TypeError( 'deepGet()::invalid input argument. Key path must be a string primitive or a key array. Value: `' + path + '`.' );
	}
	opts = defaults();
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isStr ) {
		props = path.split( opts.sep );
	} else {
		props = path;
	}
	/**
	* FUNCTION: deepGet( obj )
	*	Deep get a nested property.
	*
	* @param {Object|Array} obj - input object
	* @returns {*} nested property value
	*/
	return function deepGet( obj ) {
		if ( typeof obj !== 'object' || obj === null ) {
			return;
		}
		return dget( obj, props );
	};
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;

},{"./deepget.js":109,"./defaults.js":110,"./validate.js":113,"validate.io-array":114,"validate.io-string-primitive":131}],112:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isArray = require( 'validate.io-array' ),
	validate = require( './validate.js' ),
	defaults = require( './defaults.js' ),
	dget = require( './deepget.js' );


// DEEP GET //

/**
* FUNCTION: deepGet( obj, path[, opts] )
*	Deep get a nested property.
*
* @param {Object|Array} obj - input object
* @param {String|Array} path - key path
* @param {Object} [opts] - function options
* @param {String} [opts.sep='.'] - key path separator
* @returns {*} nested property value
*/
function deepGet( obj, path, options ) {
	var isStr = isString( path ),
		props,
		opts,
		err;
	if ( typeof obj !== 'object' || obj === null ) {
		return;
	}
	if ( !isStr && !isArray( path ) ) {
		throw new TypeError( 'deepGet()::invalid input argument. Key path must be a string primitive or a key array. Value: `' + path + '`.' );
	}
	opts = defaults();
	if ( arguments.length > 2 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isStr ) {
		props = path.split( opts.sep );
	} else {
		props = path;
	}
	return dget( obj, props );
} // end FUNCTION deepGet()


// EXPORTS //

module.exports = deepGet;
module.exports.factory = require( './factory.js' );

},{"./deepget.js":109,"./defaults.js":110,"./factory.js":111,"./validate.js":113,"validate.io-array":114,"validate.io-string-primitive":131}],113:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isObject = require( 'validate.io-object' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for function options
* @param {Object} options - function options
* @param {String} [options.sep] - key path separator
* @returns {Error|Null} error or null
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'deepGet()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'deepGet()::invalid option. Key path separator must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-object":129,"validate.io-string-primitive":131}],114:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],115:[function(require,module,exports){
'use strict';

/**
* FUNCTION: deepSet( obj, props, create, value )
*	Deep sets a nested property.
*
* @param {Object|Array} obj - input object
* @param {Array} props - list of properties defining a key path
* @param {Boolean} create - boolean indicating whether to create a path if the key path does not already exist
* @param {*} value - value to set
* @returns {Boolean} boolean indicating if the property was successfully set
*/
function deepSet( obj, props, create, val ) {
	var len = props.length,
		bool = false,
		v = obj,
		p,
		i;

	for ( i = 0; i < len; i++ ) {
		p = props[ i ];
		if ( typeof v === 'object' && v !== null ) {
			if ( !v.hasOwnProperty( p ) ) {
				if ( create ) {
					v[ p ] = {};
				} else {
					break;
				}
			}
			if ( i === len-1 ) {
				if ( typeof val === 'function' ) {
					v[ p ] = val( v[ p ] );
				} else {
					v[ p ] = val;
				}
				bool = true;
			} else {
				v = v[ p ];
			}
		} else {
			break;
		}
	}
	return bool;
} // end FUNCTION deepSet()


// EXPORTS //

module.exports = deepSet;

},{}],116:[function(require,module,exports){
'use strict';

/**
* FUNCTION: defaults()
*	Returns default options.
*
* @returns {Object} default options
*/
function defaults() {
	return {
		'create': false,
		'sep': '.'
	};
} // end FUNCTION defaults()


// EXPORTS //

module.exports = defaults;

},{}],117:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isArray = require( 'validate.io-array' ),
	validate = require( './validate.js' ),
	defaults = require( './defaults.js' ),
	dset = require( './deepset.js' );


// FACTORY //

/**
* FUNCTION: factory( path[, opts] )
*	Creates a reusable deep set factory.
*
* @param {String|Array} path - key path
* @param {Object} [opts] - function options
* @param {Boolean} [opts.create=false] - boolean indicating whether to create a path if the key path does not already exist
* @param {String} [opts.sep='.'] - key path separator
* @returns {Function} deep set factory
*/
function factory( path, options ) {
	var isStr = isString( path ),
		props,
		opts,
		err;
	if ( !isStr && !isArray( path ) ) {
		throw new TypeError( 'deepSet()::invalid input argument. Key path must be a string primitive or a key array. Value: `' + path + '`.' );
	}
	opts = defaults();
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isStr ) {
		props = path.split( opts.sep );
	} else {
		props = path;
	}
	/**
	* FUNCTION: deepSet( obj, value )
	*	Deep sets a nested property.
	*
	* @param {Object|Array} obj - input object
	* @param {*} value - value to set
	* @returns {Boolean} boolean indicating if the property was successfully set
	*/
	return function deepSet( obj, value ) {
		if ( typeof obj !== 'object' || obj === null ) {
			return false;
		}
		return dset( obj, props, opts.create, value );
	};
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;

},{"./deepset.js":115,"./defaults.js":116,"./validate.js":119,"validate.io-array":120,"validate.io-string-primitive":131}],118:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isArray = require( 'validate.io-array' ),
	validate = require( './validate.js' ),
	defaults = require( './defaults.js' ),
	dset = require( './deepset.js' );


// DEEP SET //

/**
* FUNCTION: deepSet( obj, path, value[, opts] )
*	Deep sets a nested property.
*
* @param {Object|Array} obj - input object
* @param {String|Array} path - key path
* @param {*} value - value to set
* @param {Object} [opts] - function options
* @param {Boolean} [opts.create=false] - boolean indicating whether to create a path if the key path does not already exist
* @param {String} [opts.sep='.'] - key path separator
* @returns {Boolean} boolean indicating if the property was successfully set
*/
function deepSet( obj, path, value, options ) {
	var isStr = isString( path ),
		props,
		opts,
		err;
	if ( typeof obj !== 'object' || obj === null ) {
		return false;
	}
	if ( !isStr && !isArray( path ) ) {
		throw new TypeError( 'deepSet()::invalid input argument. Key path must be a string primitive or a key array. Value: `' + path + '`.' );
	}
	opts = defaults();
	if ( arguments.length > 3 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isStr ) {
		props = path.split( opts.sep );
	} else {
		props = path;
	}
	return dset( obj, props, opts.create, value );
} // end FUNCTION deepSet()


// EXPORTS //

module.exports = deepSet;
module.exports.factory = require( './factory.js' );

},{"./deepset.js":115,"./defaults.js":116,"./factory.js":117,"./validate.js":119,"validate.io-array":120,"validate.io-string-primitive":131}],119:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for function options
* @param {Object} options - function options
* @param {Boolean} [options.create] - boolean indicating whether to create a path if the key path does not already exist
* @param {String} [options.sep] - key path separator
* @returns {Error|Null} error or null
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'deepSet()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'create' ) ) {
		opts.create = options.create;
		if ( !isBoolean( opts.create ) ) {
			return new TypeError( 'deepSet()::invalid option. Create option must be a boolean primitive. Option: `' + opts.create + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'deepSet()::invalid option. Key path separator must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":124,"validate.io-object":129,"validate.io-string-primitive":131}],120:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],121:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":122,"dup":34,"validate.io-integer-primitive":123}],122:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],123:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":128}],124:[function(require,module,exports){
/**
*
*	VALIDATE: boolean-primitive
*
*
*	DESCRIPTION:
*		- Validates if a value is a boolean primitive.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: isBoolean( value )
*	Validates if a value is a boolean primitive.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a boolean primitive
*/
function isBoolean( value ) {
	return value === true || value === false;
} // end FUNCTION isBoolean()


// EXPORTS //

module.exports = isBoolean;

},{}],125:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],126:[function(require,module,exports){
'use strict';

/**
* FUNCTION: matrixLike( value )
*	Validates if a value is matrix-like.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is matrix-like
*/
function matrixLike( v ) {
	return v !== null &&
		typeof v === 'object' &&
		typeof v.data === 'object' &&
		typeof v.shape === 'object' &&
		typeof v.offset === 'number' &&
		typeof v.strides === 'object' &&
		typeof v.dtype === 'string' &&
		typeof v.length === 'number';
} // end FUNCTION matrixLike()


// EXPORTS //

module.exports = matrixLike;

},{}],127:[function(require,module,exports){
/**
*
*	VALIDATE: nan
*
*
*	DESCRIPTION:
*		- Validates if a value is NaN.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: nan( value )
*	Validates if a value is not-a-number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether the value is a NaN
*/
function nan( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() !== value.valueOf();
} // end FUNCTION nan()


// EXPORTS //

module.exports = nan;

},{}],128:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],129:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' );


// ISOBJECT //

/**
* FUNCTION: isObject( value )
*	Validates if a value is a object; e.g., {}.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a object
*/
function isObject( value ) {
	return ( typeof value === 'object' && value !== null && !isArray( value ) );
} // end FUNCTION isObject()


// EXPORTS //

module.exports = isObject;

},{"validate.io-array":130}],130:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],131:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],132:[function(require,module,exports){
'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer-primitive' );


// CONSTANTS //

var MAX = require( 'compute-const-max-safe-integer' );


// IS TYPED-ARRAY-LIKE //

/**
* FUNCTION: isTypedArrayLike( value )
*	Validates if a value is typed-array-like.
*
* @param {*} value - value to validate
* @param {Boolean} boolean indicating if a value is typed-array-like
*/
function isTypedArrayLike( value ) {
	return value !== null &&
		typeof value === 'object' &&
		isInteger( value.length ) &&
		value.length >= 0 &&
		value.length <= MAX &&
		typeof value.BYTES_PER_ELEMENT === 'number' &&
		typeof value.byteOffset === 'number' &&
		typeof value.byteLength === 'number';
} // end FUNCTION isTypedArrayLike()


// EXPORTS //

module.exports = isTypedArrayLike;

},{"compute-const-max-safe-integer":133,"validate.io-integer-primitive":134}],133:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],134:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":128}],135:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isNumber = require( 'validate.io-number-primitive' );


// ADD //

/**
* FUNCTION: add( arr, x[, opts] )
*	Computes an element-wise addition.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number} x - either an array of equal length or a scalar
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} output array
*/
function add( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'add()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) ) {
		throw new TypeError( 'add()::invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'add()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'add()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'add()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: x is an array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'add()::invalid input argument. Array to be added must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i, 0 ) + clbk( x[i], i, 1 );
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i ) + x[ i ];
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = arr[ i ] + x[ i ];
			}
		}
	}
	// Case 2: accessor and scalar
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = clbk( arr[i], i ) + x;
		}
	}
	// Case 3: scalar
	else {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = arr[ i ] + x;
		}
	}
	return out;
} // end FUNCTION add()


// EXPORTS //

module.exports = add;

},{"validate.io-array":136,"validate.io-boolean-primitive":137,"validate.io-function":138,"validate.io-number-primitive":139,"validate.io-object":140}],136:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],137:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],138:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],139:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],140:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":136}],141:[function(require,module,exports){
/**
*
*	COMPUTE: argmax
*
*
*	DESCRIPTION:
*		- Computes the maximum value of a numeric array and returns the corresponding array indices.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: argmax( arr )
*	Computes the maximum value of a numeric array and returns the corresponding array indices.
*
* @param {Array} arr - array of values
* @returns {Array} array indices
*/
function argmax( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'argmax()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		max = arr[ 0 ],
		idx = [ 0 ],
		val;

	for ( var i = 1; i < len; i++ ) {
		val = arr[ i ];
		if ( val > max ) {
			max = val;
			idx.length = 0;
			idx.push( i );
		}
		else if ( val === max ) {
			idx.push( i );
		}
	}
	return idx;
} // end FUNCTION argmax()


// EXPORTS //

module.exports = argmax;

},{}],142:[function(require,module,exports){
/**
*
*	COMPUTE: argmin
*
*
*	DESCRIPTION:
*		- Computes the minimum value of a numeric array and returns the corresponding array indices.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: argmin( arr )
*	Computes the minimum value of a numeric array and returns the corresponding array indices.
*
* @param {Array} arr - array of values
* @returns {Array} array indices
*/
function argmin( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'argmin()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		min = arr[ 0 ],
		idx = [ 0 ],
		val;

	for ( var i = 1; i < len; i++ ) {
		val = arr[ i ];
		if ( val < min ) {
			min = val;
			idx.length = 0;
			idx.push( i );
		}
		else if ( val === min ) {
			idx.push( i );
		}
	}
	return idx;
} // end FUNCTION argmin()


// EXPORTS //

module.exports = argmin;

},{}],143:[function(require,module,exports){
/**
*
*	COMPUTE: argnanmax
*
*
*	DESCRIPTION:
*		- Computes the maximum value of an array ignoring non-numeric values and returns the corresponding array indices.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: argnanmax( arr )
*	Computes the maximum value of an array ignoring non-numeric values and returns the corresponding array indices.
*
* @param {Array} arr - array of values
* @returns {Array} array indices
*/
function argnanmax( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'argnanmax()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		max = Number.NEGATIVE_INFINITY,
		idx = [],
		val;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( typeof val !== 'number' || val !== val ) {
			continue;
		}
		if ( val > max ) {
			max = val;
			idx.length = 0;
			idx.push( i );
		}
		else if ( val === max ) {
			idx.push( i );
		}
	}
	return idx;
} // end FUNCTION argnanmax()


// EXPORTS //

module.exports = argnanmax;

},{}],144:[function(require,module,exports){
/**
*
*	COMPUTE: argnanmin
*
*
*	DESCRIPTION:
*		- Computes the minimum value of an array ignoring non-numeric values and returns the corresponding array indices.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: argnanmin( arr )
*	Computes the minimum value of an array ignoring non-numeric values and returns the corresponding array indices.
*
* @param {Array} arr - array of values
* @returns {Array} array indices
*/
function argnanmin( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'argnanmin()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		min = Number.POSITIVE_INFINITY,
		idx = [],
		val;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( typeof val !== 'number' || val !== val ) {
			continue;
		}
		if ( val < min ) {
			min = val;
			idx.length = 0;
			idx.push( i );
		}
		else if ( val === min ) {
			idx.push( i );
		}
	}
	return idx;
} // end FUNCTION argnanmin()


// EXPORTS //

module.exports = argnanmin;

},{}],145:[function(require,module,exports){
/**
*
*	COMPUTE: circshift
*
*
*	DESCRIPTION:
*		- Shifts array elements (or string characters) circularly.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// CIRCSHIFT //

/**
* FUNCTION: circshift( x, k )
*	Shifts elements/characters circularly.
*
* @param {Array|String} x - array or string to be shifted
* @param {Number} k - integer specifying the number of positions to shift
* @param {Array|String} shifted results
*/
function circshift( x, k ) {
	var type = typeof x,
		dir = 1, // right
		len,
		i;
	if ( !Array.isArray( x ) && type !== 'string' ) {
		throw new TypeError( 'circshift()::invalid input argument. Must provide either an array or string to shift.' );
	}
	if ( !isInteger( k ) ) {
		throw new TypeError( 'circshift()::invalid input argument. Second argument must be an integer.' );
	}
	if ( type === 'string' ) {
		x = x.split( '' );
	}
	len = x.length;
	if ( k < 0 ) {
		// Get the equivalent positive number of positions...
		k = len + k; // len - |x|
	}
	// We only care about the remainder when we circularly shift. k === len means the elements stay in place.
	k = k % len;

	// Determine the direction which requires the fewest operations...
	if ( k > len/2 ) {
		dir = 0; // left
		k = len - k;
	}
	if ( dir ) {
		// Pop an element off the end and move to the front...
		for ( i = 0; i < k; i++ ) {
			x.unshift( x.pop() );
		}
	} else {
		// Shift an element off the front and move to the end...
		for ( i = 0; i < k; i++ ) {
			x.push( x.shift() );
		}
	}
	if ( type === 'string' ) {
		x = x.join( '' );
	}
	return x;
} // end FUNCTION circshift()


// EXPORTS //

module.exports = circshift;

},{"validate.io-integer":146}],146:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":147}],147:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],148:[function(require,module,exports){
/**
*
*	COMPUTE: cmax
*
*
*	DESCRIPTION:
*		- Computes the cumulative maximum of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: cmax( arr )
*	Computes the cumulative maximum of a numeric array.
*
* @param {Array} arr - numeric array
* @returns {Array} cumulative max
*/
function cmax( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'cmax()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		v = new Array( len ),
		max;

	max = arr[ 0 ];
	v[ 0 ] = max;
	for ( var i = 1; i < len; i++ ) {
		if ( arr[ i ] > max ) {
			max = arr[ i ];
		}
		v[ i ] = max;
	}
	return v;
} // end FUNCTION cmax()


// EXPORTS //

module.exports = cmax;

},{}],149:[function(require,module,exports){
/**
*
*	COMPUTE: cmin
*
*
*	DESCRIPTION:
*		- Computes the cumulative minimum of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: cmin( arr )
*	Computes the cumulative minimum of a numeric array.
*
* @param {Array} arr - numeric array
* @returns {Array} cumulative min
*/
function cmin( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'cmin()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		v = new Array( len ),
		min;

	min = arr[ 0 ];
	v[ 0 ] = min;
	for ( var i = 1; i < len; i++ ) {
		if ( arr[ i ] < min ) {
			min = arr[ i ];
		}
		v[ i ] = min;
	}
	return v;
} // end FUNCTION cmin()


// EXPORTS //

module.exports = cmin;

},{}],150:[function(require,module,exports){
/**
*
*	COMPUTE: covariance
*
*
*	DESCRIPTION:
*		- Computes the covariance between one or more numeric arrays.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' );


// COVARIANCE //

/**
* FUNCTION: covariance( arr1[, arr2,...,opts] )
*	Computes the covariance between one or more numeric arrays.
*
* @param {...Array} arr - numeric array
* @param {Object} [opts] - function options
* @param {Boolean} [opts.bias] - boolean indicating whether to calculate a biased or unbiased estimate of the covariance (default: false)
* @returns {Array} covariance matrix
*/
function covariance() {
	var bias = false,
		args,
		opts,
		nArgs,
		len,
		deltas,
		delta,
		means,
		C,
		cov,
		arr,
		N, r, A, B, sum, val,
		i, j, n;

	args = Array.prototype.slice.call( arguments );
	nArgs = args.length;

	if ( isObject( args[nArgs-1] ) ) {
		opts = args.pop();
		nArgs = nArgs - 1;
		if ( opts.hasOwnProperty( 'bias' ) ) {
			if ( typeof opts.bias !== 'boolean' ) {
				throw new TypeError( 'covariance()::invalid input argument. Bias option must be a boolean.' );
			}
			bias = opts.bias;
		}
	}
	if ( !nArgs ) {
		throw new Error( 'covariance()::insufficient input arguments. Must provide array arguments.' );
	}
	for ( i = 0; i < nArgs; i++ ) {
		if ( !Array.isArray( args[i] ) ) {
			throw new TypeError( 'covariance()::invalid input argument. Must provide array arguments.' );
		}
	}
	if ( Array.isArray( args[0][0] ) ) {
		// If the first argument is an array of arrays, calculate the covariance over the nested arrays, disregarding any other arguments...
		args = args[ 0 ];
	}
	nArgs = args.length;
	len = args[ 0 ].length;
	for ( i = 1; i < nArgs; i++ ) {
		if ( args[i].length !== len ) {
			throw new Error( 'covariance()::invalid input argument. All arrays must have equal length.' );
		}
	}
	// [0] Initialization...
	deltas = new Array( nArgs );
	means = new Array( nArgs );
	C = new Array( nArgs );
	cov = new Array( nArgs );
	for ( i = 0; i < nArgs; i++ ) {
		means[ i ] = args[ i ][ 0 ];
		arr = new Array( nArgs );
		for ( j = 0; j < nArgs; j++ ) {
			arr[ j ] = 0;
		}
		C[ i ] = arr;
		cov[ i ] = arr.slice(); // copy!
	}
	if ( len < 2 ) {
		return cov;
	}
	// [1] Compute the covariance...
	for ( n = 1; n < len; n++ ) {

		N = n + 1;
		r = n / N;

		// [a] Extract the values and compute the deltas...
		for ( i = 0; i < nArgs; i++ ) {
			deltas[ i ] = args[ i ][ n ] - means[ i ];
		}

		// [b] Update the covariance between one array and every other array...
		for ( i = 0; i < nArgs; i++ ) {
			arr = C[ i ];
			delta = deltas[ i ];
			for ( j = i; j < nArgs; j++ ) {
				A = arr[ j ];
				B = r * delta * deltas[ j ];
				sum = A + B;
				// Exploit the fact that the covariance matrix is symmetric...
				if ( i !== j ) {
					C[ j ][ i ] = sum;
				}
				arr[ j ] = sum;
			} // end FOR j
		} // end FOR i

		// [c] Update the means...
		for ( i = 0; i < nArgs; i++ ) {
			means[ i ] += deltas[ i ] / N;
		}
	} // end FOR n

	// [2] Normalize the co-moments...
	n = N - 1;
	if ( bias ) {
		n = N;
	}
	for ( i = 0; i < nArgs; i++ ) {
		arr = C[ i ];
		for ( j = i; j < nArgs; j++ ) {
			val = arr[ j ] / n;
			cov[ i ][ j ] = val;
			if ( i !== j ) {
				cov[ j ][ i ] = val;
			}
		}
	}
	return cov;
} // end FUNCTION covariance()


// EXPORTS //

module.exports = covariance;

},{"validate.io-object":151}],151:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":152}],152:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],153:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' );


// CUMULATIVE PRODUCT //

/**
* FUNCTION: cprod( arr[, options] )
*	Computes the cumulative product of an array.
*
* @param {Array} arr - input array
* @param {Object} [options] - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Boolean} [options.copy=true] - boolean indicating whether to return new array
* @returns {Number[]} cumulative product array
*/
function cprod( arr, opts ) {
	var copy = true,
		clbk;
	if ( !isArray( arr ) ) {
		throw new TypeError( 'cprod()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'cprod()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction ( clbk ) ) {
				throw new TypeError( 'cprod()::invalid option. Accessor must be a function. Value: `' + clbk + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'cprod()::invalid option. Copy option must be a boolean primitive. Value: `' + copy + '`.' );
			}
		}
	}
	var len = arr.length,
		out,
		v,
		i;

	if ( copy === true ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	if ( clbk ) {
		out[ 0 ] = clbk( arr[ 0 ], 0 );
		for ( i = 1; i < len; i++ ) {
			v = out[ i-1 ];
			if ( v === 0 ) {
				out[ i ] = 0;
			} else {
				out[ i ] = v * clbk( arr[ i ], i );
			}
		}
	} else {
		out[ 0 ] = arr[ 0 ];
		for ( i = 1; i < len; i++ ) {
			out[ i ] = out[ i-1 ] * arr[ i ];
		}
	}
	return out;
} // end FUNCTION cprod()


// EXPORTS //

module.exports = cprod;

},{"validate.io-array":154,"validate.io-boolean-primitive":155,"validate.io-function":156,"validate.io-object":157}],154:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],155:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],156:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],157:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":154}],158:[function(require,module,exports){
/**
*
*	COMPUTE: cross
*
*
*	DESCRIPTION:
*		- Computes the cross product between two numeric arrays.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// CROSS PRODUCT //

/**
* FUNCTION: cross( x, y )
*	Computes the cross product between two numeric arrays.
*
* @param {Array} x - numeric array
* @param {Array} y - numeric array
* @returns {Number} cross product
*/
function cross( x, y ) {
	if ( !Array.isArray( x ) ) {
		throw new TypeError( 'cross()::invalid input argument. First argument must be an array.' );
	}
	if ( !Array.isArray( y ) ) {
		throw new TypeError( 'cross()::invalid input argument. Second argument must be an array.' );
	}
	if ( x.length !== 3 || y.length !== 3 ) {
		throw new Error( 'cross()::invalid input argument. Input arrays must be of length 3.' );
	}
	return [
		x[1]*y[2]-x[2]*y[1],
		x[2]*y[0]-x[0]*y[2],
		x[0]*y[1]-x[1]*y[0]
	];
} // end FUNCTION cross()


// EXPORTS //

module.exports = cross;

},{}],159:[function(require,module,exports){
/**
*
*	COMPUTE: csum
*
*
*	DESCRIPTION:
*		- Computes the cumulative sum of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: csum( arr )
*	Computes the cumulative sum of a numeric array.
*
* @param {Array} arr - numeric array
* @returns {Array} cumulative sum
*/
function csum( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'csum()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		v = new Array( len );

	v[ 0 ] = arr[ 0 ];
	for ( var i = 1; i < len; i++ ) {
		v[ i ] = v[ i-1 ] + arr[ i ];
	}
	return v;
} // end FUNCTION csum()


// EXPORTS //

module.exports = csum;

},{}],160:[function(require,module,exports){
/**
*
*	COMPUTE: datespace
*
*
*	DESCRIPTION:
*		- Generates an array of linearly spaced dates.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isInteger = require( 'validate.io-integer' );


// VARIABLES //

var timestamp = /^\d{10}$|^\d{13}$/,
	rounders = [ 'floor', 'ceil', 'round' ];


// FUNCTIONS //

/**
* FUNCTION: validDate( value, name )
*	Validates a date parameter.
*
* @private
* @param {*} value - value to be validated
* @param {String} name - name to be used in error messages
* @returns {Date} validated date
*/
function validDate( value, name ) {
	var type;

	type = typeof value;
	if ( type === 'string' ) {
		value = Date.parse( value );
		if ( value !== value ) {
			throw new Error( 'datespace()::invalid input argument. Unable to parse ' +  name.toLowerCase() + ' date.' );
		}
		value = new Date( value );
	}
	if ( type === 'number' ) {
		if ( !timestamp.test( value ) ) {
			throw new Error( 'datespace()::invalid input argument. Numeric ' + name.toLowerCase() + ' date must be either a Unix or Javascript timestamp.' );
		}
		if ( value.toString().length === 10 ) {
			value = value * 1000; // sec to ms
		}
		value = new Date( value );
	}
	if ( !(value instanceof Date) ) {
		throw new TypeError( 'datespace()::invalid input argument. ' + name + ' date must either be a date string, Date object, Unix timestamp, or JavaScript timestamp.' );
	}
	return value;
} // end FUNCTION validDate()


// DATESPACE //

/**
* FUNCTION: datespace( start, stop[, length, options])
*	Generates an array of linearly spaced dates.
*
* @param {Date|Number|String} start - start time as either a `Date` object, Unix timestamp, JavaScript timestamp, or date string
* @param {Data|Number|String} stop - stop time as either a `Date` object, Unix timestamp, JavaScript timestamp, or date string
* @param {Number} [length] - output array length (default: 100)
* @param {Object} [options] - function options
* @param {String} [options.round] - specifies how sub-millisecond times should be rounded: [ 'floor', 'ceil', 'round' ] (default: 'floor' )
* @returns {Array} array of dates
*/
function datespace( start, stop, length, options ) {
	var nArgs = arguments.length,
		opts = {
			'round': 'floor'
		},
		len = 100,
		flg = true,
		round,
		end,
		d,
		tmp,
		arr;

	start = validDate( start, 'Start' );
	stop = validDate( stop, 'Stop' );

	if ( nArgs > 2 ) {
		if ( nArgs === 3 ) {
			if ( isObject( length ) ) {
				opts = length;
			} else {
				len = length;

				// Turn off checking the options object...
				flg = false;
			}
		} else {
			opts = options;
			len = length;
		}
		if ( len === 0 ) {
			return [];
		}
		if ( !isInteger( len ) || len < 0 ) {
			throw new TypeError( 'datespace()::invalid input argument. Length must a positive integer.' );
		}
		if ( flg ) {
			if ( !isObject( opts ) ) {
				throw new TypeError( 'datespace()::invalid input argument. Options must be an object.' );
			}
			if ( opts.hasOwnProperty( 'round' ) ) {
				if ( typeof opts.round !== 'string' ) {
					throw new TypeError( 'datespace()::invalid input argument. Round option must be a string.' );
				}
				if ( rounders.indexOf( opts.round ) === -1 ) {
					throw new Error( 'datespace()::invalid input argument. Unrecognized round option. Must be one of [' + rounders.join( ',' ) + '].' );
				}
			} else {
				opts.round = 'floor';
			}
		}
	}
	round = Math[ opts.round ];

	// Calculate the increment...
	end = len - 1;
	d = ( stop.getTime() - start.getTime() ) / end;

	// Build the output array...
	arr = new Array( len );
	tmp = start;
	arr[ 0 ] = tmp;
	tmp = tmp.getTime();
	for ( var i = 1; i < end; i++ ) {
		tmp += d;
		arr[ i ] = new Date( round( tmp ) );
	}
	arr[ end ] = stop;
	return arr;
} // end FUNCTION datespace()


// EXPORTS //

module.exports = datespace;

},{"validate.io-integer":161,"validate.io-object":163}],161:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":162}],162:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],163:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":164}],164:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],165:[function(require,module,exports){
/**
*
*	COMPUTE: deg2rad
*
*
*	DESCRIPTION:
*		- Converts degrees to radians.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// DEGREES-TO-RADIANS //

/**
* FUNCTION: deg2rad( x )
*	Converts degrees to radians. Note: if provided an array, the array is mutated.
*
* @param {Array|Number} x - value(s) to be converted to radians
* @returns {Array|Number|Null} radian value(s). If `x` is an empty `array`, returns `null`.
*/
function deg2rad( x ) {
	var isArray = Array.isArray( x ),
		len;
	if ( !isArray && ( typeof x !== 'number' || x !== x ) ) {
		throw new TypeError( 'deg2rad()::invalid input argument. Must provide either a single numeric value or a numeric array.' );
	}
	if ( !isArray ) {
		return x * Math.PI / 180;
	}
	len = x.length;
	if ( !len ) {
		return null;
	}
	for ( var i = 0; i < len; i++ ) {
		x[ i ] *= Math.PI / 180;
	}
	return x;
} // end FUNCTION deg2rad()


// EXPORTS //

module.exports = deg2rad;

},{}],166:[function(require,module,exports){
/**
*
*	COMPUTE: diff
*
*
*	DESCRIPTION:
*		- Computes the differences between adjacent elements in an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// DIFF /

	/**
	* FUNCTION: diff( arr )
	*	Calculates the differences between adjacent elements in an array.
	*
	* @param {Array} arr - array of numerical values
	* @returns {Array} array of differences
	*/
	function diff( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'diff()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			d = new Array( len-1 );

		for ( var i = 0; i < len-1; i++ ) {
			d[ i ] = arr[ i ] - arr[ i+1 ];
		}
		return d;
	} // end FUNCTION diff()


	// EXPORTS //

	module.exports = diff;

})();
},{}],167:[function(require,module,exports){
/**
*
*	COMPUTE: dims
*
*
*	DESCRIPTION:
*		- Computes array dimensions.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// DIMS //

/**
* FUNCTION: dims( arr, d, max )
*	Computes array dimensions.
*
* @private
* @param {Array} arr - input array
* @param {Array} d - dimensions array
* @param {Number} max - max number of dimensions
* @returns {Array} dimensions array
*/
function dims( arr, d, max ) {
	if ( max && d.length === max ) {
		return;
	}
	if ( !Array.isArray( arr[0] ) ) {
		return;
	}
	d.push( arr[0].length );
	dims( arr[ 0 ], d, max );
} // end FUNCTION dims()

/**
* FUNCTION: check( arr, d )
*	Checks that all array elements have the same dimensions.
*
* @private
* @param {Array} arr - input array
* @param {Array} d - dimensions array
* @returns {Boolean} boolean indicating if all array elements have the same dimensions
*/
function check( arr, d ) {
	var len = arr.length,
		dim = d.shift(),
		nDims = d.length,
		val,
		flg;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( !Array.isArray( val ) || val.length !== dim ) {
			return false;
		}
		if ( nDims ) {
			flg = check( val, d.slice() );
			if ( !flg ) {
				return false;
			}
		}
	}
	return true;
} // end FUNCTION check()

/**
* FUNCTION: compute( arr[, max] )
*	Computes array dimensions.
*
* @param {Array} arr - input array
* @param {Number} [max] - limits the number of dimensions returned
* @returns {Array|null} array of dimensions or null
*/
function compute( arr, max ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'dims()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isInteger( max ) || max < 1 ) {
			throw new TypeError( 'dims()::invalid input argument. `max` option must be a positive integer.' );
		}
	}
	var d, flg;

	// [0] Initialize the dimensions array:
	d = [ arr.length ];

	// [1] Recursively determine array dimensions:
	dims( arr, d, max );

	// [2] Check that all array element dimensions are consistent...
	if ( d.length > 1 ) {
		flg = check( arr, d.slice( 1 ) );
		if ( !flg ) {
			return null;
		}
	}
	return d;
} // end FUNCTION compute()


// EXPORTS //

module.exports = compute;

},{"validate.io-integer":168}],168:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":169}],169:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],170:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isNumber = require( 'validate.io-number-primitive' );


// DIVIDE //

/**
* FUNCTION: divide( arr, x[, opts] )
*	Computes an element-wise division.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number} x - either an array of equal length or a scalar
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} output array
*/
function divide( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'divide()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) ) {
		throw new TypeError( 'divide()::invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'divide()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'divide()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'divide()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: x is an array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'divide()::invalid input argument. Array to be divideed must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i, 0 ) / clbk( x[i], i, 1 );
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i ) / x[ i ];
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = arr[ i ] / x[ i ];
			}
		}
	}
	// Case 2: accessor and scalar
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = clbk( arr[i], i ) / x;
		}
	}
	// Case 3: scalar
	else {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = arr[ i ] / x;
		}
	}
	return out;
} // end FUNCTION divide()


// EXPORTS //

module.exports = divide;

},{"validate.io-array":171,"validate.io-boolean-primitive":172,"validate.io-function":173,"validate.io-number-primitive":174,"validate.io-object":175}],171:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],172:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],173:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],174:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],175:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":171}],176:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isFunction = require( 'validate.io-function' );


// DOT PRODUCT //

/**
* FUNCTION: dot( x, y[, accessor] )
*	Computes the dot product between two arrays.
*
* @param {Array} x - input array
* @param {Array} y - input array
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Number|Null} dot product
*/
function dot( x, y, clbk ) {
	if ( !isArray( x ) ) {
		throw new TypeError( 'dot()::invalid input argument. First argument must be an array. Value: `' + x + '`.' );
	}
	if ( !isArray( y ) ) {
		throw new TypeError( 'dot()::invalid input argument. Second argument must be an array. Value: `' + y + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'dot()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	var len = x.length,
		sum = 0,
		i;

	if ( len !== y.length ) {
		throw new Error( 'dot()::invalid input argument. Arrays must be of equal length.' );
	}
	if ( !len ) {
		return null;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			sum += clbk( x[ i ], i, 0 ) * clbk( y[ i ], i, 1 );
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			sum += x[ i ] * y[ i ];
		}
	}
	return sum;
} // end FUNCTION dot()


// EXPORTS //

module.exports = dot;

},{"validate.io-array":177,"validate.io-function":178}],177:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],178:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],179:[function(require,module,exports){
/**
*
*	COMPUTE: eq
*
*
*	DESCRIPTION:
*		- Computes an element-wise comparison (equality) of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' );


// EQUAL //

/**
* FUNCTION: eq( arr, x[, opts] )
*	Computes an element-wise comparison (equality) of an array.
*
* @param {Array} arr - input array
* @param {*} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.strict] - option indicating whether to enforce type equality (default: true)
* @param {Boolean} [opts.array] - option indicating whether to not perform element-by-element comparison when provided arrays of equal length (default: false)
* @returns {Array} array of 1s and 0s, where a `1` indicates that an input array element is equal to a compared value and `0` indicates that an input array element is not equal to a compared value
*/
function eq( arr, x, opts ) {
	var isArray = Array.isArray( x ),
		strict = true,
		arrCompare = false,
		out,
		len,
		i;

	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'eq()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'eq()::invalid input argument. Options must be an object.' );
		}
		if ( opts.hasOwnProperty( 'strict' ) ) {
			strict = opts.strict;
			if ( typeof strict !== 'boolean' ) {
				throw new TypeError( 'eq()::invalid input argument. Strict option must be a boolean.' );
			}
		}
		if ( opts.hasOwnProperty( 'array' ) ) {
			arrCompare = opts.array;
			if ( typeof arrCompare !== 'boolean' ) {
				throw new TypeError( 'eq()::invalid input argument. Array option must be a boolean.' );
			}
		}
	}
	len = arr.length;
	out = new Array( len );
	if ( strict ) {
		if ( !isArray || x.length !== len || arrCompare ) {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] === x ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
			return out;
		}
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] === x[ i ] ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
		return out;
	}
	if ( !isArray || x.length !== len || arrCompare ) {
		for ( i = 0; i < len; i++ ) {
			/* jshint eqeqeq:false */
			if ( arr[ i ] == x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
		return out;
	}
	for ( i = 0; i < len; i++ ) {
		/* jshint eqeqeq:false */
		if ( arr[ i ] == x[ i ] ) {
			out[ i ] = 1;
		} else {
			out[ i ] = 0;
		}
	}
	return out;
} // end FUNCTION eq()


// EXPORTS //

module.exports = eq;

},{"validate.io-object":180}],180:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":181}],181:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],182:[function(require,module,exports){
'use strict';

// FUNCTIONS

var ERF = require( './number.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( out, arr, accessor )
*	Computes the error function for each array element using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erf( y, x, clbk ) {
	var len = x.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = ERF( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./number.js":187}],183:[function(require,module,exports){
'use strict';

// MODULES //

var ERF = require( './number.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( out, arr )
*	Computes the error function for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erf( y, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = ERF( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./number.js":187}],184:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	ERF = require( './number.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( arr, path[, sep] )
*	Computes the error function for each array element and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function erf( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[ i ], ERF( v ) );
			} else {
				dset( x[ i ], NaN );
			}
		}
	}
	return x;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./number.js":187,"utils-deep-get":240,"utils-deep-set":246}],185:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var erf1 = require( './number.js' ),
	erf2 = require( './array.js' ),
	erf3 = require( './accessor.js' ),
	erf4 = require( './deepset.js' ),
	erf5 = require( './matrix.js' ),
	erf6 = require( './typedarray.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( x[, opts] )
*	Computes the error function.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} error function value(s)
*/
function erf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return erf1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return erf5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return erf6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return erf4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new Error( 'erf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return erf3( out, x, opts.accessor );
		}
		return erf2( out, x );
	}
	return NaN;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./accessor.js":182,"./array.js":183,"./deepset.js":184,"./matrix.js":186,"./number.js":187,"./typedarray.js":188,"./validate.js":189,"compute-array-constructors":191,"dstructs-matrix":200,"validate.io-array-like":249,"validate.io-matrix-like":254,"validate.io-nan":255,"validate.io-number-primitive":256,"validate.io-typed-array-like":260}],186:[function(require,module,exports){
'use strict';

// MODULES //

var ERF = require( './number.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( out, matrix )
*	Evaluates the error function for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} matrix - input matrix
* @returns {Matrix} output matrix
*/
function erf( y, x ) {
	var len = x.length,
		i;
	if ( y.length !== len ) {
		throw new Error( 'erf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = ERF( x.data[ i ] );
	}
	return y;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./number.js":187}],187:[function(require,module,exports){
'use strict';

/**
* NOTE: the following copyright and license, as well as the long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_erf.c?revision=268523&view=co}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/**
* ===========================
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc business.
* Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved.
* ===========================
*/

/**
* double erf(double x)
*                               x
*                      2       |\
*       erf(x) = -----------   | exp(-t*t)dt
*                   sqrt(pi)  \|
*                              0
*
*		erfc(x) =  1-erf(x)
*   Note that
*		erf(-x) = -erf(x)
*		erfc(-x) = 2 - erfc(x)
*
* Method:
*	1. For |x| in [0, 0.84375)
*       erf(x)  = x + x*R(x^2)
*       erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
*               = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
*       where R = P/Q where P is an odd poly of degree 8 and Q is an odd poly of degree 10.
*                                  -57.90
*           | R - (erf(x)-x)/x | <= 2
*
*
*       Remark. The formula is derived by noting
*           erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
*       and that
*           2/sqrt(pi) = 1.128379167095512573896158903121545171688
*       is close to one. The interval is chosen because the fix point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is near 0.6174), and by some experiment, 0.84375 is chosen to guarantee the error is less than one ulp for erf.
*
*   2. For |x| in [0.84375,1.25), let s = |x| - 1, and c = 0.84506291151 rounded to single (24 bits)
*       erf(x)  = sign(x) * (c + P1(s)/Q1(s))
*       erfc(x) = (1-c) - P1(s)/Q1(s) if x > 0
*           1+(c+P1(s)/Q1(s))         if x < 0
*           |P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
*   Remark: here we use the taylor series expansion at x=1.
*       erf(1+s) = erf(1) + s*Poly(s)
*                = 0.845.. + P1(s)/Q1(s)
*   That is, we use rational approximation to approximate
*       erf(1+s) - (c = (single)0.84506291151)
*   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25] where
*       P1(s) = degree 6 poly in s
*       Q1(s) = degree 6 poly in s
*
*   3. For x in [1.25,1/0.35(~2.857143)),
*       erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
*       erf(x)  = 1 - erfc(x)
*   where
*       R1(z) = degree 7 poly in z, (z=1/x^2)
*       S1(z) = degree 8 poly in z
*
*   4. For x in [1/0.35,28]
*       erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2)       if x > 0
*               = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6 < x < 0
*               = 2.0 - tiny                         if x <= -6
*       erf(x)  = sign(x)*(1.0 - erfc(x))            if x < 6, else
*       erf(x)  = sign(x)*(1.0 - tiny)
*   where
*       R2(z) = degree 6 poly in z, (z=1/x^2)
*       S2(z) = degree 7 poly in z
*
*   Note1:
*       To compute exp(-x*x-0.5625+R/S), let s be a single precision number and s := x; then
*           -x*x = -s*s + (s-x)*(s+x)
*           exp(-x*x-0.5626+R/S) = exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
*   Note2:
*       Here 4 and 5 make use of the asymptotic series
*                   exp(-x*x)
*       erfc(x) ~  ----------- * ( 1 + Poly(1/x^2) )
*                   x*sqrt(pi)
*       We use rational approximation to approximate
*           g(s) = f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
*       Here is the error bound for R1/S1 and R2/S2
*           |R1/S1 - f(x)| < 2**(-62.57)
*           |R2/S2 - f(x)| < 2**(-61.52)
*
*   5. For inf > x >= 28
*       erf(x)  = sign(x) * (1 - tiny)   (raise inexact)
*       erfc(x) = tiny*tiny              (raise underflow) if x > 0
*               = 2 - tiny               if x<0
*
*   6. Special cases:
*       erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
*       erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
*       erfc/erf(NaN) is NaN
*/

// CONSTANTS //

var INF = Number.POSITIVE_INFINITY,
	NINF = Number.NEGATIVE_INFINITY,

	TINY = 1e-300,
	SMALL = 1.0 / (1 << 28 ), /* 2**-28; equiv is Math.pow( 2, -28 ) */
	ERX = 8.45062911510467529297e-1, /* 0x3FEB0AC1, 0x60000000 */

	// Coefficients for approximation to erf on [0, 0.84375)
	EFX = 1.28379167095512586316e-1, /* 0x3FC06EBA, 0x8214DB69 */
	EFX8 = 1.02703333676410069053, /* 0x3FF06EBA, 0x8214DB69 */
	PP0 = 1.28379167095512558561e-1, /* 0x3FC06EBA, 0x8214DB68 */
	PP1 = -3.25042107247001499370e-1, /* 0xBFD4CD7D, 0x691CB913 */
	PP2 = -2.84817495755985104766e-2, /* 0xBF9D2A51, 0xDBD7194F */
	PP3 = -5.77027029648944159157e-3, /* 0xBF77A291, 0x236668E4 */
	PP4 = -2.37630166566501626084e-5, /* 0xBEF8EAD6, 0x120016AC */
	QQ1 = 3.97917223959155352819e-1, /* 0x3FD97779, 0xCDDADC09 */
	QQ2 = 6.50222499887672944485e-2, /* 0x3FB0A54C, 0x5536CEBA */
	QQ3 = 5.08130628187576562776e-3, /* 0x3F74D022, 0xC4D36B0F */
	QQ4 = 1.32494738004321644526e-4, /* 0x3F215DC9, 0x221C1A10 */
	QQ5 = -3.96022827877536812320e-6, /* 0xBED09C43, 0x42A26120 */

	// Coefficients for approximation to erf on [0.84375, 1.25)
	PA0 = -2.36211856075265944077e-3, /* 0xBF6359B8, 0xBEF77538 */
	PA1 = 4.14856118683748331666e-1, /* 0x3FDA8D00, 0xAD92B34D */
	PA2 = -3.72207876035701323847e-1, /* 0xBFD7D240, 0xFBB8C3F1 */
	PA3 = 3.18346619901161753674e-1, /* 0x3FD45FCA, 0x805120E4 */
	PA4 = -1.10894694282396677476e-1, /* 0xBFBC6398, 0x3D3E28EC */
	PA5 = 3.54783043256182359371e-2, /* 0x3FA22A36, 0x599795EB */
	PA6 = -2.16637559486879084300e-3, /* 0xBF61BF38, 0x0A96073F */
	QA1 = 1.06420880400844228286e-1, /* 0x3FBB3E66, 0x18EEE323 */
	QA2 = 5.40397917702171048937e-1, /* 0x3FE14AF0, 0x92EB6F33 */
	QA3 = 7.18286544141962662868e-2, /* 0x3FB2635C, 0xD99FE9A7 */
	QA4 = 1.26171219808761642112e-1, /* 0x3FC02660, 0xE763351F */
	QA5 = 1.36370839120290507362e-2, /* 0x3F8BEDC2, 0x6B51DD1C */
	QA6 = 1.19844998467991074170e-2, /* 0x3F888B54, 0x5735151D */

	// Coefficients for approximation to erfc on [1.25, 1/0.35)
	RA0 = -9.86494403484714822705e-3, /* 0xBF843412, 0x600D6435 */
	RA1 = -6.93858572707181764372e-1, /* 0xBFE63416, 0xE4BA7360 */
	RA2 = -1.05586262253232909814e1, /* 0xC0251E04, 0x41B0E726 */
	RA3 = -6.23753324503260060396e1, /* 0xC04F300A, 0xE4CBA38D */
	RA4 = -1.62396669462573470355e2, /* 0xC0644CB1, 0x84282266 */
	RA5 = -1.84605092906711035994e2, /* 0xC067135C, 0xEBCCABB2 */
	RA6 = -8.12874355063065934246e1, /* 0xC0545265, 0x57E4D2F2 */
	RA7 = -9.81432934416914548592, /* 0xC023A0EF, 0xC69AC25C */
	SA1 = 1.96512716674392571292e1, /* 0x4033A6B9, 0xBD707687 */
	SA2 = 1.37657754143519042600e2, /* 0x4061350C, 0x526AE721 */
	SA3 = 4.34565877475229228821e2, /* 0x407B290D, 0xD58A1A71 */
	SA4 = 6.45387271733267880336e2, /* 0x40842B19, 0x21EC2868 */
	SA5 = 4.29008140027567833386e2, /* 0x407AD021, 0x57700314 */
	SA6 = 1.08635005541779435134e2, /* 0x405B28A3, 0xEE48AE2C */
	SA7 = 6.57024977031928170135, /* 0x401A47EF, 0x8E484A93 */
	SA8 = -6.04244152148580987438e-2, /* 0xBFAEEFF2, 0xEE749A62 */

	// Coefficients for approximation to erfc on [1/0.35, 28]
	RB0 = -9.86494292470009928597e-3, /* 0xBF843412, 0x39E86F4A */
	RB1 = -7.99283237680523006574e-1, /* 0xBFE993BA, 0x70C285DE */
	RB2 = -1.77579549177547519889e1, /* 0xC031C209, 0x555F995A */
	RB3 = -1.60636384855821916062e2, /* 0xC064145D, 0x43C5ED98 */
	RB4 = -6.37566443368389627722e2, /* 0xC083EC88, 0x1375F228 */
	RB5 = -1.02509513161107724954e3, /* 0xC0900461, 0x6A2E5992 */
	RB6 = -4.83519191608651397019e2, /* 0xC07E384E, 0x9BDC383F */
	SB1 = 3.03380607434824582924e1, /* 0x403E568B, 0x261D5190 */
	SB2 = 3.25792512996573918826e2, /* 0x40745CAE, 0x221B9F0A */
	SB3 = 1.53672958608443695994e3, /* 0x409802EB, 0x189D5118 */
	SB4 = 3.19985821950859553908e3, /* 0x40A8FFB7, 0x688C246A */
	SB5 = 2.55305040643316442583e3, /* 0x40A3F219, 0xCEDF3BE6 */
	SB6 = 4.74528541206955367215e2, /* 0x407DA874, 0xE79FE763 */
	SB7 = -2.24409524465858183362e1; /* 0xC03670E2, 0x42712D62 */


// VARIABLES //

var EXP = Math.exp;


// ERF //

/**
* FUNCTION: erf( x )
*	Evaluates the error function for an input value.
*
* @param {Number} x - input value
* @returns {Number} evaluated error function
*/
function erf( x ) {
	var sign = false,
		tmp,
		z, r, s, y, p, q;

	// [1] Special cases...

	// NaN:
	if ( x !== x ) {
		return NaN;
	}
	// Positive infinity:
	if ( x === INF ) {
		return 1;
	}
	// Negative infinity:
	if ( x === NINF ) {
		return -1;
	}

	// [2] Get the sign:
	if ( x < 0 ) {
		x = -x;
		sign = true;
	}

	// [3] |x| < 0.84375
	if ( x < 0.84375 ) {
		if ( x < SMALL ) {
			if ( x < TINY ) {
				// Avoid underflow:
				tmp = 0.125 * (8.0*x + EFX8*x );
			} else {
				tmp = x + EFX*x;
			}
		} else {
			z = x * x;
			// Horner's method: http://en.wikipedia.org/wiki/Horner's_method
			r = PP0 + z*(PP1+z*(PP2+z*(PP3+z*PP4)));
			s = 1.0 + z*(QQ1+z*(QQ2+z*(QQ3+z*(QQ4+z*QQ5))));
			y = r / s;
			tmp = x + x*y;
		}
		if ( sign ) {
			return -tmp;
		}
		return tmp;
	}

	// [4] 0.84375 <= |x| < 1.25
	if ( x < 1.25 ) {
		s = x - 1;
		p = PA0 + s*(PA1+s*(PA2+s*(PA3+s*(PA4+s*(PA5+s*PA6)))));
		q = 1 + s*(QA1+s*(QA2+s*(QA3+s*(QA4+s*(QA5+s*QA6)))));
		if ( sign ) {
			return -ERX - p/q;
		}
		return ERX + p/q;
	}

	// [5] INF > |x| >=6
	if ( x >= 6 ) {
		if ( sign ) {
			return TINY - 1;
		}
		return 1 - TINY;
	}

	s = 1 / (x*x);

	// [6] |x| < 1 / 0.35 ~2.857143
	if ( x < 1/0.35 ) {
		r = RA0 + s*(RA1+s*(RA2+s*(RA3+s*(RA4+s*(RA5+s*(RA6+s*RA7))))));
		s = 1 + s*(SA1+s*(SA2+s*(SA3+s*(SA4+s*(SA5+s*(SA6+s*(SA7+s*SA8)))))));
	} else { // [7] |x| >= 1/0.35 ~2.857143
		r = RB0 + s*(RB1+s*(RB2+s*(RB3+s*(RB4+s*(RB5+s*RB6)))));
		s = 1 + s*(SB1+s*(SB2+s*(SB3+s*(SB4+s*(SB5+s*(SB6+s*SB7))))));
	}
	z = x & 0xffffffff00000000; // pseudo-single (20-bit) precision x;
	r = EXP( -z*z - 0.5625 ) * EXP( (z-x)*(z+x) + r/s );
	if ( sign ) {
		return r/x - 1;
	}
	return 1 - r/x;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{}],188:[function(require,module,exports){
'use strict';

// MODULES //

var ERF = require( './number.js' );


// ERROR FUNCTION //

/**
* FUNCTION: erf( out, arr )
*	Computes the error function for each typed-array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erf( y, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		y[ i ] = ERF( x[ i ] );
	}
	return y;
} // end FUNCTION erf()


// EXPORTS //

module.exports = erf;

},{"./number.js":187}],189:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'erf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'erf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'erf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'erf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'erf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'erf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":252,"validate.io-function":253,"validate.io-object":257,"validate.io-string-primitive":259}],190:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],191:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":190,"dup":63}],192:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],193:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":196,"./iget.js":198,"./iset.js":201,"./mget.js":205,"./mset.js":207,"./set.js":215,"./sget.js":217,"./sset.js":219,"./toString.js":221,"dup":2}],194:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":197,"./iget.raw.js":199,"./iset.raw.js":202,"./mget.raw.js":206,"./mset.raw.js":208,"./set.raw.js":216,"./sget.raw.js":218,"./sset.raw.js":220,"./toString.js":221,"dup":3}],195:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],196:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":234}],197:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],198:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":232}],199:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],200:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":203,"./matrix.raw.js":204,"dup":9}],201:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":232,"validate.io-number-primitive":256}],202:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],203:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":192,"./ctor.js":193,"./dtypes.js":195,"compute-cast-arrays":222,"compute-dtype":225,"dup":12,"validate.io-array":229,"validate.io-contains":230,"validate.io-nonnegative-integer-array":233,"validate.io-string-primitive":259}],204:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":192,"./ctor.raw.js":194,"./dtypes.js":195,"compute-dtype":225,"dup":13,"validate.io-contains":230,"validate.io-string-primitive":259}],205:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":192,"dup":14,"validate.io-nonnegative-integer-array":233}],206:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":192,"dup":15}],207:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":209,"./mset2.js":210,"./mset3.js":211,"./mset4.js":212,"./mset5.js":213,"./mset6.js":214,"dup":16,"validate.io-function":253,"validate.io-nonnegative-integer-array":233,"validate.io-number-primitive":256}],208:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":209,"./mset2.js":210,"./mset3.js":211,"./mset4.js":212,"./mset5.js":213,"./mset6.js":214,"dup":17}],209:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],210:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],211:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],212:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],213:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],214:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],215:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":234,"validate.io-number-primitive":256}],216:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],217:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":192,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":259}],218:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":192,"compute-indexspace":585,"dup":27}],219:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":253,"validate.io-number-primitive":256,"validate.io-string-primitive":259}],220:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],221:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],222:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":190,"compute-array-dtype/lib/dtypes":223,"dup":31,"type-name":224,"validate.io-array-like":249}],223:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],224:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],225:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":227,"dup":36,"type-name":228}],226:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],227:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":226,"dup":38}],228:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],229:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],230:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":229,"validate.io-nan-primitive":231}],231:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],232:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":256}],233:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":229,"validate.io-nonnegative-integer":234}],234:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":235}],235:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":236}],236:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],237:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],238:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],239:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":237,"./defaults.js":238,"./validate.js":241,"dup":111,"validate.io-array":242,"validate.io-string-primitive":259}],240:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":237,"./defaults.js":238,"./factory.js":239,"./validate.js":241,"dup":112,"validate.io-array":242,"validate.io-string-primitive":259}],241:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":257,"validate.io-string-primitive":259}],242:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],243:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],244:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],245:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":243,"./defaults.js":244,"./validate.js":247,"dup":117,"validate.io-array":248,"validate.io-string-primitive":259}],246:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":243,"./defaults.js":244,"./factory.js":245,"./validate.js":247,"dup":118,"validate.io-array":248,"validate.io-string-primitive":259}],247:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":252,"validate.io-object":257,"validate.io-string-primitive":259}],248:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],249:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":250,"dup":34,"validate.io-integer-primitive":251}],250:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],251:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":256}],252:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],253:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],254:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],255:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],256:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],257:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":258}],258:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],259:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],260:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":261,"dup":132,"validate.io-integer-primitive":262}],261:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],262:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":256}],263:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFC = require( './number.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( out, arr, accessor )
*	Computes the complementary error function for each array element using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfc( out, x, clbk ) {
	var len = x.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = ERFC( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./number.js":268}],264:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFC = require( './number.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( out, arr )
*	Computes the complementary error function for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfc( out, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			out[ i ] = ERFC( x[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./number.js":268}],265:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory;


// FUNCTIONS //

var ERFC = require( './number.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( arr, path[, sep] )
*	Computes the complementary error function for each array element and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function erfc( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], ERFC( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./number.js":268,"utils-deep-get":321,"utils-deep-set":327}],266:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var erfc1 = require( './number.js' ),
	erfc2 = require( './array.js' ),
	erfc3 = require( './accessor.js' ),
	erfc4 = require( './deepset.js' ),
	erfc5 = require( './matrix.js' ),
	erfc6 = require( './typedarray.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( x[, opts] )
*	Computes the complementary error function.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} complementary error function value(s)
*/
function erfc( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return erfc1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfc()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return erfc5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfc()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return erfc6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return erfc4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'erfc()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return erfc3( out, x, opts.accessor );
		}
		return erfc2( out, x );
	}
	return NaN;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./accessor.js":263,"./array.js":264,"./deepset.js":265,"./matrix.js":267,"./number.js":268,"./typedarray.js":269,"./validate.js":270,"compute-array-constructors":272,"dstructs-matrix":281,"validate.io-array-like":330,"validate.io-matrix-like":335,"validate.io-nan":336,"validate.io-number-primitive":337,"validate.io-typed-array-like":341}],267:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFC = require( './number.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( out, x )
*	Evaluates the complementary error function for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function erfc( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'erfc()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = ERFC( x.data[ i ] );
	}
	return out;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./number.js":268}],268:[function(require,module,exports){
'use strict';

/**
* NOTE: the following copyright and license, as well as the long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_erf.c?revision=268523&view=co}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/**
* ===========================
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc business.
* Permission to use, copy, modify, and distribute this software is freely granted, provided that this notice is preserved.
* ===========================
*/

/**
* double erfc(double x)
*                               x
*                      2       |\
*       erf(x) = -----------   | exp(-t*t)dt
*                   sqrt(pi)  \|
*                              0
*
*       erfc(x) =  1 - erf(x)
*   Note that
*       erf(-x) = -erf(x)
*       erfc(-x) = 2 - erfc(x)
*
* Method:
*   1. For |x| in [0, 0.84375)
*       erf(x)  = x + x*R(x^2)
*       erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
*               = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
*       where R = P/Q where P is an odd poly of degree 8 and Q is an odd poly of degree 10.
*                                  -57.90
*           | R - (erf(x)-x)/x | <= 2
*
*
*       Remark. The formula is derived by noting
*           erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
*       and that
*           2/sqrt(pi) = 1.128379167095512573896158903121545171688
*       is close to one. The interval is chosen because the fix point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is near 0.6174), and by some experiment, 0.84375 is chosen to guarantee the error is less than one ulp for erf.
*
*   2. For |x| in [0.84375,1.25), let s = |x| - 1, and c = 0.84506291151 rounded to single (24 bits)
*       erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
*       erfc(x) = (1-c) - P1(s)/Q1(s)      if x > 0
*           1+(c+P1(s)/Q1(s))              if x < 0
*           |P1/Q1 - (erf(|x|)-c)|         <= 2**-59.06
*   Remark: here we use the taylor series expansion at x=1.
*       erf(1+s) = erf(1) + s*Poly(s)
*                = 0.845.. + P1(s)/Q1(s)
*   That is, we use rational approximation to approximate
*       erf(1+s) - (c = (single)0.84506291151)
*   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25] where
*       P1(s) = degree 6 poly in s
*       Q1(s) = degree 6 poly in s
*
*   3. For x in [1.25,1/0.35(~2.857143)),
*       erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
*       erf(x)  = 1 - erfc(x)
*   where
*       R1(z) = degree 7 poly in z, (z=1/x^2)
*       S1(z) = degree 8 poly in z
*
*   4. For x in [1/0.35,28]
*       erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2)       if x > 0
*               = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6 < x < 0
*               = 2.0 - tiny                         if x <= -6
*       erf(x)  = sign(x)*(1.0 - erfc(x))            if x < 6, else
*       erf(x)  = sign(x)*(1.0 - tiny)
*   where
*       R2(z) = degree 6 poly in z, (z=1/x^2)
*       S2(z) = degree 7 poly in z
*
*   Note1:
*       To compute exp(-x*x-0.5625+R/S), let s be a single precision number and s := x; then
*           -x*x = -s*s + (s-x)*(s+x)
*           exp(-x*x-0.5626+R/S) = exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
*   Note2:
*       Here 4 and 5 make use of the asymptotic series
*                   exp(-x*x)
*       erfc(x) ~  ----------- * ( 1 + Poly(1/x^2) )
*                   x*sqrt(pi)
*       We use rational approximation to approximate
*           g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
*       Here is the error bound for R1/S1 and R2/S2
*           |R1/S1 - f(x)| < 2**(-62.57)
*           |R2/S2 - f(x)| < 2**(-61.52)
*
*   5. For inf > x >= 28
*       erf(x)  = sign(x) * (1 - tiny)  (raise inexact)
*       erfc(x) = tiny*tiny             (raise underflow) if x > 0
*               = 2 - tiny              if x < 0
*
*   6. Special case:
*       erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
*       erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
*       erfc/erf(NaN) is NaN
*/

// CONSTANTS //

var INF = Number.POSITIVE_INFINITY,
	NINF = Number.NEGATIVE_INFINITY,

	TINY = 1e-300,
	SMALL = 1.0 / (1 << 56 ), /* 2**-56; equiv is Math.pow( 2, -56 ) */
	ERX = 8.45062911510467529297e-1, /* 0x3FEB0AC1, 0x60000000 */

	// Coefficients for approximation to erfc on [0, 0.84375)
	PP0 = 1.28379167095512558561e-1, /* 0x3FC06EBA, 0x8214DB68 */
	PP1 = -3.25042107247001499370e-1, /* 0xBFD4CD7D, 0x691CB913 */
	PP2 = -2.84817495755985104766e-2, /* 0xBF9D2A51, 0xDBD7194F */
	PP3 = -5.77027029648944159157e-3, /* 0xBF77A291, 0x236668E4 */
	PP4 = -2.37630166566501626084e-5, /* 0xBEF8EAD6, 0x120016AC */
	QQ1 = 3.97917223959155352819e-1, /* 0x3FD97779, 0xCDDADC09 */
	QQ2 = 6.50222499887672944485e-2, /* 0x3FB0A54C, 0x5536CEBA */
	QQ3 = 5.08130628187576562776e-3, /* 0x3F74D022, 0xC4D36B0F */
	QQ4 = 1.32494738004321644526e-4, /* 0x3F215DC9, 0x221C1A10 */
	QQ5 = -3.96022827877536812320e-6, /* 0xBED09C43, 0x42A26120 */

	// Coefficients for approximation to erfc on [0.84375, 1.25)
	PA0 = -2.36211856075265944077e-3, /* 0xBF6359B8, 0xBEF77538 */
	PA1 = 4.14856118683748331666e-1, /* 0x3FDA8D00, 0xAD92B34D */
	PA2 = -3.72207876035701323847e-1, /* 0xBFD7D240, 0xFBB8C3F1 */
	PA3 = 3.18346619901161753674e-1, /* 0x3FD45FCA, 0x805120E4 */
	PA4 = -1.10894694282396677476e-1, /* 0xBFBC6398, 0x3D3E28EC */
	PA5 = 3.54783043256182359371e-2, /* 0x3FA22A36, 0x599795EB */
	PA6 = -2.16637559486879084300e-3, /* 0xBF61BF38, 0x0A96073F */
	QA1 = 1.06420880400844228286e-1, /* 0x3FBB3E66, 0x18EEE323 */
	QA2 = 5.40397917702171048937e-1, /* 0x3FE14AF0, 0x92EB6F33 */
	QA3 = 7.18286544141962662868e-2, /* 0x3FB2635C, 0xD99FE9A7 */
	QA4 = 1.26171219808761642112e-1, /* 0x3FC02660, 0xE763351F */
	QA5 = 1.36370839120290507362e-2, /* 0x3F8BEDC2, 0x6B51DD1C */
	QA6 = 1.19844998467991074170e-2, /* 0x3F888B54, 0x5735151D */

	// Coefficients for approximation to erfc on [1.25, 1/0.35)
	RA0 = -9.86494403484714822705e-3, /* 0xBF843412, 0x600D6435 */
	RA1 = -6.93858572707181764372e-1, /* 0xBFE63416, 0xE4BA7360 */
	RA2 = -1.05586262253232909814e1, /* 0xC0251E04, 0x41B0E726 */
	RA3 = -6.23753324503260060396e1, /* 0xC04F300A, 0xE4CBA38D */
	RA4 = -1.62396669462573470355e2, /* 0xC0644CB1, 0x84282266 */
	RA5 = -1.84605092906711035994e2, /* 0xC067135C, 0xEBCCABB2 */
	RA6 = -8.12874355063065934246e1, /* 0xC0545265, 0x57E4D2F2 */
	RA7 = -9.81432934416914548592, /* 0xC023A0EF, 0xC69AC25C */
	SA1 = 1.96512716674392571292e1, /* 0x4033A6B9, 0xBD707687 */
	SA2 = 1.37657754143519042600e2, /* 0x4061350C, 0x526AE721 */
	SA3 = 4.34565877475229228821e2, /* 0x407B290D, 0xD58A1A71 */
	SA4 = 6.45387271733267880336e2, /* 0x40842B19, 0x21EC2868 */
	SA5 = 4.29008140027567833386e2, /* 0x407AD021, 0x57700314 */
	SA6 = 1.08635005541779435134e2, /* 0x405B28A3, 0xEE48AE2C */
	SA7 = 6.57024977031928170135, /* 0x401A47EF, 0x8E484A93 */
	SA8 = -6.04244152148580987438e-2, /* 0xBFAEEFF2, 0xEE749A62 */

	// Coefficients for approximation to erfc on [1/0.35, 28]
	RB0 = -9.86494292470009928597e-3, /* 0xBF843412, 0x39E86F4A */
	RB1 = -7.99283237680523006574e-1, /* 0xBFE993BA, 0x70C285DE */
	RB2 = -1.77579549177547519889e1, /* 0xC031C209, 0x555F995A */
	RB3 = -1.60636384855821916062e2, /* 0xC064145D, 0x43C5ED98 */
	RB4 = -6.37566443368389627722e2, /* 0xC083EC88, 0x1375F228 */
	RB5 = -1.02509513161107724954e3, /* 0xC0900461, 0x6A2E5992 */
	RB6 = -4.83519191608651397019e2, /* 0xC07E384E, 0x9BDC383F */
	SB1 = 3.03380607434824582924e1, /* 0x403E568B, 0x261D5190 */
	SB2 = 3.25792512996573918826e2, /* 0x40745CAE, 0x221B9F0A */
	SB3 = 1.53672958608443695994e3, /* 0x409802EB, 0x189D5118 */
	SB4 = 3.19985821950859553908e3, /* 0x40A8FFB7, 0x688C246A */
	SB5 = 2.55305040643316442583e3, /* 0x40A3F219, 0xCEDF3BE6 */
	SB6 = 4.74528541206955367215e2, /* 0x407DA874, 0xE79FE763 */
	SB7 = -2.24409524465858183362e1; /* 0xC03670E2, 0x42712D62 */


// VARIABLES //

var EXP = Math.exp;


// ERFC //

/**
* FUNCTION: erfc( x )
*	Evaluates the complementary error function for an input value.
*
* @param {Number} x - input value
* @returns {Number} evaluated complementary error function
*/
function erfc( x ) {
	var sign = false,
		tmp,
		z, r, s, y, p, q;

	// [1] Special cases...

	// NaN:
	if ( x !== x ) {
		return NaN;
	}
	// Positive infinity:
	if ( x === INF ) {
		return 0;
	}
	// Negative infinity:
	if ( x === NINF ) {
		return 2;
	}

	// [2] Get the sign:
	if ( x < 0 ) {
		x = -x;
		sign = true;
	}

	// [3] |x| < 0.84375
	if ( x < 0.84375 ) {
		// |x| < 2**-56
		if ( x < SMALL ) {
			tmp = x;
		} else {
			z = x * x;
			r = PP0 + z*(PP1+z*(PP2+z*(PP3+z*PP4)));
			s = 1 + z*(QQ1+z*(QQ2+z*(QQ3+z*(QQ4+z*QQ5))));
			y = r / s;
			if ( x < 0.25 ) { // |x| < 1/4
				tmp = x + x*y;
			} else {
				tmp = 0.5 + (x*y + (x-0.5));
			}
		}
		if ( sign ) {
			return 1 + tmp;
		}
		return 1 - tmp;
	}

	// [4] 0.84375 <= |x| < 1.25
	if ( x < 1.25 ) {
		s = x - 1;
		p = PA0 + s*(PA1+s*(PA2+s*(PA3+s*(PA4+s*(PA5+s*PA6)))));
		q = 1 + s*(QA1+s*(QA2+s*(QA3+s*(QA4+s*(QA5+s*QA6)))));
		if ( sign ) {
			return 1 + ERX + p/q;
		}
		return 1 - ERX - p/q;
	}

	// [5] |x| < 28
	if ( x < 28 ) {
		s = 1 / (x*x);
		// |x| < 1/0.35 ~ 2.857143
		if ( x < 1/0.35 ) {
			r = RA0 + s*(RA1+s*(RA2+s*(RA3+s*(RA4+s*(RA5+s*(RA6+s*RA7))))));
			s = 1 + s*(SA1+s*(SA2+s*(SA3+s*(SA4+s*(SA5+s*(SA6+s*SA7))))));
		} else { // |x| >= 1/0.35 ~ 2.857143
			if ( sign && x > 6 ) { // x < -6
				return 2 - TINY;
			}
			r = RB0 + s*(RB1+s*(RB2+s*(RB3+s*(RB4+s*(RB5+s*RB6)))));
			s = 1 + s*(SB1+s*(SB2+s*(SB3+s*(SB4+s*(SB5+s*(SB6+s*SB7))))));
		}
		z = x & 0xffffffff00000000; // pseudo-single (20-bit) precision x;
		r = EXP( -z*z - 0.5625 ) * EXP( (z-x)*(z+x) + r/s );
		if ( sign ) {
			return 2 - r/x;
		}
		return r/x;
	}

	if ( sign ) {
		return 2 - TINY; // ~2
	}
	return TINY * TINY; // ~0
} // end FUNCTION erfc()


// EXPORTS

module.exports = erfc;

},{}],269:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFC = require( './number.js' );


// COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfc( out, arr )
*	Computes the complementary error function for each typed-array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfc( out, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = ERFC( x[ i ] );
	}
	return out;
} // end FUNCTION erfc()


// EXPORTS //

module.exports = erfc;

},{"./number.js":268}],270:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'erfc()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'erfc()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'erfc()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'erfc()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'erfc()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'erfc()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":333,"validate.io-function":334,"validate.io-object":338,"validate.io-string-primitive":340}],271:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],272:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":271,"dup":63}],273:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],274:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":277,"./iget.js":279,"./iset.js":282,"./mget.js":286,"./mset.js":288,"./set.js":296,"./sget.js":298,"./sset.js":300,"./toString.js":302,"dup":2}],275:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":278,"./iget.raw.js":280,"./iset.raw.js":283,"./mget.raw.js":287,"./mset.raw.js":289,"./set.raw.js":297,"./sget.raw.js":299,"./sset.raw.js":301,"./toString.js":302,"dup":3}],276:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],277:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":315}],278:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],279:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":313}],280:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],281:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":284,"./matrix.raw.js":285,"dup":9}],282:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":313,"validate.io-number-primitive":337}],283:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],284:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":273,"./ctor.js":274,"./dtypes.js":276,"compute-cast-arrays":303,"compute-dtype":306,"dup":12,"validate.io-array":310,"validate.io-contains":311,"validate.io-nonnegative-integer-array":314,"validate.io-string-primitive":340}],285:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":273,"./ctor.raw.js":275,"./dtypes.js":276,"compute-dtype":306,"dup":13,"validate.io-contains":311,"validate.io-string-primitive":340}],286:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":273,"dup":14,"validate.io-nonnegative-integer-array":314}],287:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":273,"dup":15}],288:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":290,"./mset2.js":291,"./mset3.js":292,"./mset4.js":293,"./mset5.js":294,"./mset6.js":295,"dup":16,"validate.io-function":334,"validate.io-nonnegative-integer-array":314,"validate.io-number-primitive":337}],289:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":290,"./mset2.js":291,"./mset3.js":292,"./mset4.js":293,"./mset5.js":294,"./mset6.js":295,"dup":17}],290:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],291:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],292:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],293:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],294:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],295:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],296:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":315,"validate.io-number-primitive":337}],297:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],298:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":273,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":340}],299:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":273,"compute-indexspace":585,"dup":27}],300:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":334,"validate.io-number-primitive":337,"validate.io-string-primitive":340}],301:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],302:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],303:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":271,"compute-array-dtype/lib/dtypes":304,"dup":31,"type-name":305,"validate.io-array-like":330}],304:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],305:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],306:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":308,"dup":36,"type-name":309}],307:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],308:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":307,"dup":38}],309:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],310:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],311:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":310,"validate.io-nan-primitive":312}],312:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],313:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":337}],314:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":310,"validate.io-nonnegative-integer":315}],315:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":316}],316:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":317}],317:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],318:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],319:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],320:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":318,"./defaults.js":319,"./validate.js":322,"dup":111,"validate.io-array":323,"validate.io-string-primitive":340}],321:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":318,"./defaults.js":319,"./factory.js":320,"./validate.js":322,"dup":112,"validate.io-array":323,"validate.io-string-primitive":340}],322:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":338,"validate.io-string-primitive":340}],323:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],324:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],325:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],326:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":324,"./defaults.js":325,"./validate.js":328,"dup":117,"validate.io-array":329,"validate.io-string-primitive":340}],327:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":324,"./defaults.js":325,"./factory.js":326,"./validate.js":328,"dup":118,"validate.io-array":329,"validate.io-string-primitive":340}],328:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":333,"validate.io-object":338,"validate.io-string-primitive":340}],329:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],330:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":331,"dup":34,"validate.io-integer-primitive":332}],331:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],332:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":337}],333:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],334:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],335:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],336:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],337:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],338:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":339}],339:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],340:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],341:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":342,"dup":132,"validate.io-integer-primitive":343}],342:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],343:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":337}],344:[function(require,module,exports){
'use strict';

// MODULES //

var ERFCINV = require( './number.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( out, arr, accessor )
*	Computes the inverse complementary error function for each array element using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfcinv( out, x, clbk ) {
	var len = x.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = ERFCINV( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./number.js":349}],345:[function(require,module,exports){
'use strict';

// MODULES //

var ERFCINV = require( './number.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( out, arr )
*	Computes the inverse complementary error function for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfcinv( out, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			out[ i ] = ERFCINV( x[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./number.js":349}],346:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	ERFCINV = require( './number.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( arr, path[, sep] )
*	Computes the inverse complementary error function for each array element and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function erfcinv( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[ i ], ERFCINV( v ) );
			} else {
				dset( x[ i ], NaN );
			}
		}
	}
	return x;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./number.js":349,"utils-deep-get":402,"utils-deep-set":408}],347:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var erfcinv1 = require( './number.js' ),
	erfcinv2 = require( './array.js' ),
	erfcinv3 = require( './accessor.js' ),
	erfcinv4 = require( './deepset.js' ),
	erfcinv5 = require( './matrix.js' ),
	erfcinv6 = require( './typedarray.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( x[, opts] )
*	Computes the inverse complementary error function.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated complementary inverse error function value(s)
*/
function erfcinv( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return erfcinv1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfcinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return erfcinv5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfcinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return erfcinv6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return erfcinv4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'erfcinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return erfcinv3( out, x, opts.accessor );
		}
		return erfcinv2( out, x );
	}
	return NaN;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./accessor.js":344,"./array.js":345,"./deepset.js":346,"./matrix.js":348,"./number.js":349,"./typedarray.js":350,"./validate.js":351,"compute-array-constructors":353,"dstructs-matrix":362,"validate.io-array-like":411,"validate.io-matrix-like":416,"validate.io-nan":417,"validate.io-number-primitive":418,"validate.io-typed-array-like":422}],348:[function(require,module,exports){
'use strict';

// MODULES //

var ERFCINV = require( './number.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( out, x )
*	Evaluates the inverse complementary error function for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function erfcinv( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'erfcinv()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = ERFCINV( x.data[ i ] );
	}
	return out;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./number.js":349}],349:[function(require,module,exports){
'use strict';

/**
* erfcinv( x )
*
* Method:
*	1. For `|x| <= 0.5`, evaluate inverse erf using the rational approximation:
*
*		`erfcinv = x(x+10)(Y+R(x))`
*
*	where `Y` is a constant and `R(x)` is optimized for a low absolute error compared to `|Y|`. Max error `~2e-18`.
*
*	2. For `0.5 > 1-|x| >= 0`, evaluate inverse erf using the rational approximation:
*
*		`erfcinv = sqrt(-2*log(1-x)) / (Y + R(1-x))`
*
*	where `Y `is a constant, and R(q) is optimised for a low absolute error compared to `Y`. Max error `~7e-17`.
*
*	3. For `1-|x| < 0.25`, we have a series of rational approximations all of the general form:
*
*		`p = sqrt(-log(1-x))`
*
*	Then the result is given by:
*
*		`erfcinv = p(Y+R(p-B))`
*
*	where `Y` is a constant, `B` is the lowest value of `p` for which the approximation is valid, and `R(x-B)` is optimized for a low absolute error compared to `Y`.
*
*	Note that almost all code will really go through the first or maybe second approximation.  After than we are dealing with very small input values.
*
*	If `p < 3`, max error `~1e-20`.
*	If `p < 6`, max error `~8e-21`.
*	If `p < 18`, max error `~1e-19`.
*	If `p < 44`, max error `~6e-20`.
*	If `p >= 44`, max error `~1e-20`.
*/

// MODULES //

var polyval = require( 'compute-polynomial' );


// CONSTANTS //

var // Coefficients for erfcinv on [0, 0.5]:
	Y1 = 8.91314744949340820313e-2,
	P1 = [
		-5.38772965071242932965e-3,
		8.22687874676915743155e-3,
		2.19878681111168899165e-2,
		-3.65637971411762664006e-2,
		-1.26926147662974029034e-2,
		3.34806625409744615033e-2,
		-8.36874819741736770379e-3,
		-5.08781949658280665617e-4
	],
	Q1 = [
		8.86216390456424707504e-4,
		-2.33393759374190016776e-3,
		7.95283687341571680018e-2,
		-5.27396382340099713954e-2,
		-7.1228902341542847553e-1,
		6.62328840472002992063e-1,
		1.56221558398423026363,
		-1.56574558234175846809,
		-9.70005043303290640362e-1,
		1
	],

	// Coefficients for erfcinv for 0.5 > 1-x >= 0:
	Y2 = 2.249481201171875,
	P2 = [
		-3.67192254707729348546,
		2.11294655448340526258e1,
		1.7445385985570866523e1,
		-4.46382324441786960818e1,
		-1.88510648058714251895e1,
		1.76447298408374015486e1,
		8.37050328343119927838,
		1.05264680699391713268e-1,
		-2.02433508355938759655e-1
	],
	Q2 = [
		1.72114765761200282724,
		2.26436933413139721736e1,
		1.08268667355460159008e1,
		4.85609213108739935468e1,
		-2.01432634680485188801e1,
		-2.86608180499800029974e1,
		3.9713437953343869095,
		6.24264124854247537712,
		1
	],

	// Coefficients for erfcinv for sqrt( -log(1-x)):
	Y3 = 8.07220458984375e-1,
	P3 = [
		-6.81149956853776992068e-10,
		2.85225331782217055858e-8,
		-6.79465575181126350155e-7,
		2.14558995388805277169e-3,
		2.90157910005329060432e-2,
		1.42869534408157156766e-1,
		3.37785538912035898924e-1,
		3.87079738972604337464e-1,
		1.17030156341995252019e-1,
		-1.63794047193317060787e-1,
		-1.31102781679951906451e-1
	],
	Q3 = [
		1.105924229346489121e-2,
		1.52264338295331783612e-1,
		8.48854343457902036425e-1,
		2.59301921623620271374,
		4.77846592945843778382,
		5.38168345707006855425,
		3.46625407242567245975,
		1
	],

	Y4 = 9.3995571136474609375e-1,
	P4 = [
		2.66339227425782031962e-12,
		-2.30404776911882601748e-10,
		4.60469890584317994083e-6,
		1.57544617424960554631e-4,
		1.87123492819559223345e-3,
		9.50804701325919603619e-3,
		1.85573306514231072324e-2,
		-2.22426529213447927281e-3,
		-3.50353787183177984712e-2
	],
	Q4 = [
		7.64675292302794483503e-5,
		2.63861676657015992959e-3,
		3.41589143670947727934e-2,
		2.20091105764131249824e-1,
		7.62059164553623404043e-1,
		1.3653349817554063097,
		1
	],

	Y5 = 9.8362827301025390625e-1,
	P5 = [
		9.9055709973310326855e-17,
		-2.81128735628831791805e-14,
        4.62596163522878599135e-9,
        4.49696789927706453732e-7,
        1.49624783758342370182e-5,
        2.09386317487588078668e-4,
        1.05628862152492910091e-3,
        -1.12951438745580278863e-3,
		-1.67431005076633737133e-2
	],
	Q5 = [
		2.82243172016108031869e-7,
		2.75335474764726041141e-5,
        9.64011807005165528527e-4,
        1.60746087093676504695e-2,
        1.38151865749083321638e-1,
        5.91429344886417493481e-1,
        1
	];


// FUNCTIONS //

/**
* FUNCTION: calc( x, v, P, Q, Y )
*	Calculates a rational approximation.
*
* @private
* @param {Number} x
* @param {Number} v
* @param {Array} P - array of polynomial coefficients
* @param {Array} Q - array of polynomial coefficients
* @param {Number} Y
* @returns {Number} rational approximation
*/
function calc( x, v, P, Q, Y ) {
	var s, r;
	s = x - v;
	r = polyval( P, s ) / polyval( Q, s );
	return Y*x + r*x;
} // end FUNCTION calc()


// ERFINV //

/**
* FUNCTION: erfcinv( x )
*	Evaluates the complementary inverse error function for an input value.
*
* @private
* @param {Number} x - input value
* @returns {Number} evaluated complementary inverse error function
*/
function erfcinv( x ) {
	var sign = false,
		val,
		q, g, r;

	// [1] Special cases...

	// NaN:
	if ( x !== x ) {
		return NaN;
	}
	// x not on the interval: [0,2]
	if ( x < 0 || x > 2 ) {
		throw new RangeError ( 'erfcinv()::invalid input argument. Value must be on the interval [0,2]. Value: `' + x + '`.' );
	}
	if ( x === 0 ) {
		return Number.POSITIVE_INFINITY;
	}
	if ( x === 2 ) {
		return Number.NEGATIVE_INFINITY;
	}
	if ( x === 1 ) {
		return 0;
	}
	// [2] Get the sign and make use of `erfc` reflection formula: `erfc(-z) = 2 - erfc(z)`...
	if ( x > 1 ) {
		q = 2 - x;
		x = 1 - q;
		sign = true;
	} else {
		q = x;
		x = 1 - x;
	}
	// [3] |x| <= 0.5
	if ( x <= 0.5 ) {
		g = x * (x+10);
		r = polyval( P1, x ) / polyval( Q1, x );
		val = g*Y1 + g*r;
		return ( sign ) ? -val : val;
	}

	// [4] 1-|x| >= 0.25
	if ( q >= 0.25 ) {
		g = Math.sqrt( -2 * Math.log( q ) );
		q = q - 0.25;
		r = polyval( P2, q ) / polyval( Q2, q );
		val = g / (Y2+r);
		return ( sign ) ? -val : val;
	}
	q = Math.sqrt( -Math.log( q ) );

	// [5] q < 3
	if ( q < 3 ) {
		return calc( q, 1.125, P3, Q3, Y3 );
	}
	// [6] q < 6
	if ( q < 6 ) {
		return calc( q, 3, P4, Q4, Y4 );
	}
	// Note that the smallest number in JavaScript is 5e-324. Math.sqrt( -Math.log( 5e-324 ) ) ~27.2844
	return calc( q, 6, P5, Q5, Y5 );

	// Note that in the boost library, they are able to go to much smaller values, as 128 bit long doubles support ~1e-5000; something which JavaScript does not natively support.
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"compute-polynomial":775}],350:[function(require,module,exports){
'use strict';

// MODULES //

var ERFCINV = require( './number.js' );


// INVERSE COMPLEMENTARY ERROR FUNCTION //

/**
* FUNCTION: erfcinv( out, arr )
*	Computes the inverse complementary error function for each typed-array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfcinv( out, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = ERFCINV( x[ i ] );
	}
	return out;
} // end FUNCTION erfcinv()


// EXPORTS //

module.exports = erfcinv;

},{"./number.js":349}],351:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'erfcinv()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'erfcinv()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'erfcinv()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'erfcinv()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'erfcinv()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'erfcinv()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":414,"validate.io-function":415,"validate.io-object":419,"validate.io-string-primitive":421}],352:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],353:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":352,"dup":63}],354:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],355:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":358,"./iget.js":360,"./iset.js":363,"./mget.js":367,"./mset.js":369,"./set.js":377,"./sget.js":379,"./sset.js":381,"./toString.js":383,"dup":2}],356:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":359,"./iget.raw.js":361,"./iset.raw.js":364,"./mget.raw.js":368,"./mset.raw.js":370,"./set.raw.js":378,"./sget.raw.js":380,"./sset.raw.js":382,"./toString.js":383,"dup":3}],357:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],358:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":396}],359:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],360:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":394}],361:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],362:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":365,"./matrix.raw.js":366,"dup":9}],363:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":394,"validate.io-number-primitive":418}],364:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],365:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":354,"./ctor.js":355,"./dtypes.js":357,"compute-cast-arrays":384,"compute-dtype":387,"dup":12,"validate.io-array":391,"validate.io-contains":392,"validate.io-nonnegative-integer-array":395,"validate.io-string-primitive":421}],366:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":354,"./ctor.raw.js":356,"./dtypes.js":357,"compute-dtype":387,"dup":13,"validate.io-contains":392,"validate.io-string-primitive":421}],367:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":354,"dup":14,"validate.io-nonnegative-integer-array":395}],368:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":354,"dup":15}],369:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":371,"./mset2.js":372,"./mset3.js":373,"./mset4.js":374,"./mset5.js":375,"./mset6.js":376,"dup":16,"validate.io-function":415,"validate.io-nonnegative-integer-array":395,"validate.io-number-primitive":418}],370:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":371,"./mset2.js":372,"./mset3.js":373,"./mset4.js":374,"./mset5.js":375,"./mset6.js":376,"dup":17}],371:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],372:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],373:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],374:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],375:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],376:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],377:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":396,"validate.io-number-primitive":418}],378:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],379:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":354,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":421}],380:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":354,"compute-indexspace":585,"dup":27}],381:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":415,"validate.io-number-primitive":418,"validate.io-string-primitive":421}],382:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],383:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],384:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":352,"compute-array-dtype/lib/dtypes":385,"dup":31,"type-name":386,"validate.io-array-like":411}],385:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],386:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],387:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":389,"dup":36,"type-name":390}],388:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],389:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":388,"dup":38}],390:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],391:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],392:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":391,"validate.io-nan-primitive":393}],393:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],394:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":418}],395:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":391,"validate.io-nonnegative-integer":396}],396:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":397}],397:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":398}],398:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],399:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],400:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],401:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":399,"./defaults.js":400,"./validate.js":403,"dup":111,"validate.io-array":404,"validate.io-string-primitive":421}],402:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":399,"./defaults.js":400,"./factory.js":401,"./validate.js":403,"dup":112,"validate.io-array":404,"validate.io-string-primitive":421}],403:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":419,"validate.io-string-primitive":421}],404:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],405:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],406:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],407:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":405,"./defaults.js":406,"./validate.js":409,"dup":117,"validate.io-array":410,"validate.io-string-primitive":421}],408:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":405,"./defaults.js":406,"./factory.js":407,"./validate.js":409,"dup":118,"validate.io-array":410,"validate.io-string-primitive":421}],409:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":414,"validate.io-object":419,"validate.io-string-primitive":421}],410:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],411:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":412,"dup":34,"validate.io-integer-primitive":413}],412:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],413:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":418}],414:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],415:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],416:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],417:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],418:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],419:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":420}],420:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],421:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],422:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":423,"dup":132,"validate.io-integer-primitive":424}],423:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],424:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":418}],425:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFINV = require( './number.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( out, arr, accessor )
*	Computes the inverse error function for each array element using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfinv( y, x, clbk ) {
	var len = x.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = ERFINV( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./number.js":430}],426:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFINV = require( './number.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( out, arr )
*	Computes the inverse error function for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfinv( y, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = ERFINV( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./number.js":430}],427:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory;


// FUNCTIONS //

var ERFINV = require( './number.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( arr, path[, sep] )
*	Computes the inverse error function for each array element and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function erfinv( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[ i ], ERFINV( v ) );
			} else {
				dset( x[ i ], NaN );
			}
		}
	}
	return x;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./number.js":430,"utils-deep-get":483,"utils-deep-set":489}],428:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var erfinv1 = require( './number.js' ),
	erfinv2 = require( './array.js' ),
	erfinv3 = require( './accessor.js' ),
	erfinv4 = require( './deepset.js' ),
	erfinv5 = require( './matrix.js' ),
	erfinv6 = require( './typedarray.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( x[, opts] )
*	Evaluates the inverse error function element-wise.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} inverse error function value(s)
*/
function erfinv( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return erfinv1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return erfinv5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'erfinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return erfinv6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return erfinv4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'erfinv()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return erfinv3( out, x, opts.accessor );
		}
		return erfinv2( out, x );
	}
	return NaN;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./accessor.js":425,"./array.js":426,"./deepset.js":427,"./matrix.js":429,"./number.js":430,"./typedarray.js":431,"./validate.js":432,"compute-array-constructors":434,"dstructs-matrix":443,"validate.io-array-like":492,"validate.io-matrix-like":497,"validate.io-nan":498,"validate.io-number-primitive":499,"validate.io-typed-array-like":503}],429:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFINV = require( './number.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( out, matrix )
*	Evaluates the inverse error function for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} matrix - input matrix
* @returns {Matrix} output matrix
*/
function erfinv( y, x ) {
	var len = x.length,
		i;
	if ( y.length !== len ) {
		throw new Error( 'erfinv()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = ERFINV( x.data[ i ] );
	}
	return y;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./number.js":430}],430:[function(require,module,exports){
'use strict';

/**
* erfinv( x )
*
* Method:
*	1. For `|x| <= 0.5`, evaluate inverse erf using the rational approximation:
*
*		`erfinv = x(x+10)(Y+R(x))`
*
*	where `Y` is a constant and `R(x)` is optimized for a low absolute error compared to `|Y|`. Max error `~2e-18`.
*
*	2. For `0.5 > 1-|x| >= 0`, evaluate inverse erf using the rational approximation:
*
*		`erfinv = sqrt(-2*log(1-x)) / (Y + R(1-x))`
*
*	where `Y `is a constant, and R(q) is optimised for a low absolute error compared to `Y`. Max error `~7e-17`.
*
*	3. For `1-|x| < 0.25`, we have a series of rational approximations all of the general form:
*
*		`p = sqrt(-log(1-x))`
*
*	Then the result is given by:
*
*		`erfinv = p(Y+R(p-B))`
*
*	where `Y` is a constant, `B` is the lowest value of `p` for which the approximation is valid, and `R(x-B)` is optimized for a low absolute error compared to `Y`.
*
*	Note that almost all code will really go through the first or maybe second approximation.  After that we are dealing with very small input values.
*
*	If `p < 3`, max error `~1e-20`.
*	If `p < 6`, max error `~8e-21`.
*	If `p < 18`, max error `~1e-19`.
*	If `p < 44`, max error `~6e-20`.
*	If `p >= 44`, max error `~1e-20`.
*/

// MODULES //

var polyval = require( 'compute-polynomial' );


// CONSTANTS //

var // Coefficients for erfinv on [0, 0.5]:
	Y1 = 8.91314744949340820313e-2,
	P1 = [
		-5.38772965071242932965e-3,
		8.22687874676915743155e-3,
		2.19878681111168899165e-2,
		-3.65637971411762664006e-2,
		-1.26926147662974029034e-2,
		3.34806625409744615033e-2,
		-8.36874819741736770379e-3,
		-5.08781949658280665617e-4
	],
	Q1 = [
		8.86216390456424707504e-4,
		-2.33393759374190016776e-3,
		7.95283687341571680018e-2,
		-5.27396382340099713954e-2,
		-7.1228902341542847553e-1,
		6.62328840472002992063e-1,
		1.56221558398423026363,
		-1.56574558234175846809,
		-9.70005043303290640362e-1,
		1,
	],

	// Coefficients for erfinv for 0.5 > 1-x >= 0:
	Y2 = 2.249481201171875,
	P2 = [
		-3.67192254707729348546,
		2.11294655448340526258e1,
		1.7445385985570866523e1,
		-4.46382324441786960818e1,
		-1.88510648058714251895e1,
		1.76447298408374015486e1,
		8.37050328343119927838,
		1.05264680699391713268e-1,
		-2.02433508355938759655e-1
	],
	Q2 = [
		1.72114765761200282724,
		2.26436933413139721736e1,
		1.08268667355460159008e1,
		4.85609213108739935468e1,
		-2.01432634680485188801e1,
		-2.86608180499800029974e1,
		3.9713437953343869095,
		6.24264124854247537712,
		1
	],

	// Coefficients for erfinv for sqrt( -log(1-x) ):
	Y3 = 8.07220458984375e-1,
	P3 = [
		-6.81149956853776992068e-10,
		2.85225331782217055858e-8,
		-6.79465575181126350155e-7,
		2.14558995388805277169e-3,
		2.90157910005329060432e-2,
		1.42869534408157156766e-1,
		3.37785538912035898924e-1,
		3.87079738972604337464e-1,
		1.17030156341995252019e-1,
		-1.63794047193317060787e-1,
		-1.31102781679951906451e-1
	],
	Q3 = [
		1.105924229346489121e-2,
		1.52264338295331783612e-1,
		8.48854343457902036425e-1,
		2.59301921623620271374,
		4.77846592945843778382,
		5.38168345707006855425,
		3.46625407242567245975,
		1
	],

	Y4 = 9.3995571136474609375e-1,
	P4 = [
		2.66339227425782031962e-12,
		-2.30404776911882601748e-10,
		4.60469890584317994083e-6,
		1.57544617424960554631e-4,
		1.87123492819559223345e-3,
		9.50804701325919603619e-3,
		1.85573306514231072324e-2,
		-2.22426529213447927281e-3,
		-3.50353787183177984712e-2
	],
	Q4 = [
		7.64675292302794483503e-5,
		2.63861676657015992959e-3,
		3.41589143670947727934e-2,
		2.20091105764131249824e-1,
		7.62059164553623404043e-1,
		1.3653349817554063097,
		1
	],

	Y5 = 9.8362827301025390625e-1,
	P5 = [
		9.9055709973310326855e-17,
		-2.81128735628831791805e-14,
		4.62596163522878599135e-9,
		4.49696789927706453732e-7,
		1.49624783758342370182e-5,
		2.09386317487588078668e-4,
		1.05628862152492910091e-3,
		-1.12951438745580278863e-3,
		-1.67431005076633737133e-2
	],
	Q5 = [
		2.82243172016108031869e-7,
		2.75335474764726041141e-5,
		9.64011807005165528527e-4,
		1.60746087093676504695e-2,
		1.38151865749083321638e-1,
		5.91429344886417493481e-1,
		1
	];


// FUNCTIONS //

/**
* FUNCTION: calc( x, v, P, Q, Y, sign )
*	Calculates a rational approximation.
*
* @private
* @param {Number} x
* @param {Number} v
* @param {Array} P - array of polynomial coefficients
* @param {Array} Q - array of polynomial coefficients
* @param {Number} Y
* @param {Boolean} sign - indicates if positive or negative
* @returns {Number} rational approximation
*/
function calc( x, v, P, Q, Y, sign ) {
	var val, s, r;
	s = x - v;
	r = polyval( P, s ) / polyval( Q, s );
	val = Y*x + r*x;
	return ( sign ) ? -val : val;
} // end FUNCTION calc()


// ERFINV //

/**
* FUNCTION: erfinv( x )
*	Evaluates the inverse error function for an input value.
*
* @private
* @param {Number} x - input value
* @returns {Number} evaluated inverse error function
*/
function erfinv( x ) {
	var sign = false,
		val,
		q, g, r;

	// [1] Special cases...

	// NaN:
	if ( x !== x ) {
		return NaN;
	}
	// x not on the interval: [-1,1]
	if ( x < -1 || x > 1 ) {
		throw new RangeError( 'erfinv()::invalid input argument. Value must be on the interval [-1,1]. Value: `' + x + '`.' );
	}
	if ( x === 1 ) {
		return Number.POSITIVE_INFINITY;
	}
	if ( x === -1 ) {
		return Number.NEGATIVE_INFINITY;
	}
	if ( x === 0 ) {
		return 0;
	}
	// [2] Get the sign and make use of `erf` reflection formula: `erf(-z) = -erf(z)`...
	if ( x < 0 ) {
		x = -x;
		sign = true;
	}
	q = 1 - x;

	// [3] |x| <= 0.5
	if ( x <= 0.5 ) {
		g = x * (x+10);
		r = polyval( P1, x ) / polyval( Q1, x );
		val = g*Y1 + g*r;
		return ( sign ) ? -val : val;
	}
	// [4] 1-|x| >= 0.25
	if ( q >= 0.25 ) {
		g = Math.sqrt( -2 * Math.log( q ) );
		q = q - 0.25;
		r = polyval( P2, q ) / polyval( Q2, q );
		val = g / (Y2+r);
		return ( sign ) ? -val : val;
	}
	q = Math.sqrt( -Math.log( q ) );

	// [5] q < 3
	if ( q < 3 ) {
		return calc( q, 1.125, P3, Q3, Y3, sign );
	}
	// [6] q < 6
	if ( q < 6 ) {
		return calc( q, 3, P4, Q4, Y4, sign );
	}
	// Note that the smallest number in JavaScript is 5e-324. Math.sqrt( -Math.log( 5e-324 ) ) ~27.2844
	return calc( q, 6, P5, Q5, Y5, sign );

	// Note that, in the boost library, they are able to go to much smaller values, as 128 bit long doubles support ~1e-5000; something which JavaScript does not natively support.
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"compute-polynomial":775}],431:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ERFINV = require( './number.js' );


// INVERSE ERROR FUNCTION //

/**
* FUNCTION: erfinv( out, arr )
*	Computes the inverse error function for each typed-array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function erfinv( y, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		y[ i ] = ERFINV( x[ i ] );
	}
	return y;
} // end FUNCTION erfinv()


// EXPORTS //

module.exports = erfinv;

},{"./number.js":430}],432:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'erfinv()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'erfinv()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'erfinv()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'erfinv()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'erfinv()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'erfinv()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":495,"validate.io-function":496,"validate.io-object":500,"validate.io-string-primitive":502}],433:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],434:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":433,"dup":63}],435:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],436:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":439,"./iget.js":441,"./iset.js":444,"./mget.js":448,"./mset.js":450,"./set.js":458,"./sget.js":460,"./sset.js":462,"./toString.js":464,"dup":2}],437:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":440,"./iget.raw.js":442,"./iset.raw.js":445,"./mget.raw.js":449,"./mset.raw.js":451,"./set.raw.js":459,"./sget.raw.js":461,"./sset.raw.js":463,"./toString.js":464,"dup":3}],438:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],439:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":477}],440:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],441:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":475}],442:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],443:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":446,"./matrix.raw.js":447,"dup":9}],444:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":475,"validate.io-number-primitive":499}],445:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],446:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":435,"./ctor.js":436,"./dtypes.js":438,"compute-cast-arrays":465,"compute-dtype":468,"dup":12,"validate.io-array":472,"validate.io-contains":473,"validate.io-nonnegative-integer-array":476,"validate.io-string-primitive":502}],447:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":435,"./ctor.raw.js":437,"./dtypes.js":438,"compute-dtype":468,"dup":13,"validate.io-contains":473,"validate.io-string-primitive":502}],448:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":435,"dup":14,"validate.io-nonnegative-integer-array":476}],449:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":435,"dup":15}],450:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":452,"./mset2.js":453,"./mset3.js":454,"./mset4.js":455,"./mset5.js":456,"./mset6.js":457,"dup":16,"validate.io-function":496,"validate.io-nonnegative-integer-array":476,"validate.io-number-primitive":499}],451:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":452,"./mset2.js":453,"./mset3.js":454,"./mset4.js":455,"./mset5.js":456,"./mset6.js":457,"dup":17}],452:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],453:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],454:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],455:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],456:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],457:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],458:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":477,"validate.io-number-primitive":499}],459:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],460:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":435,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":502}],461:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":435,"compute-indexspace":585,"dup":27}],462:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":496,"validate.io-number-primitive":499,"validate.io-string-primitive":502}],463:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],464:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],465:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":433,"compute-array-dtype/lib/dtypes":466,"dup":31,"type-name":467,"validate.io-array-like":492}],466:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],467:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],468:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":470,"dup":36,"type-name":471}],469:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],470:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":469,"dup":38}],471:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],472:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],473:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":472,"validate.io-nan-primitive":474}],474:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],475:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":499}],476:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":472,"validate.io-nonnegative-integer":477}],477:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":478}],478:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":479}],479:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],480:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],481:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],482:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":480,"./defaults.js":481,"./validate.js":484,"dup":111,"validate.io-array":485,"validate.io-string-primitive":502}],483:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":480,"./defaults.js":481,"./factory.js":482,"./validate.js":484,"dup":112,"validate.io-array":485,"validate.io-string-primitive":502}],484:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":500,"validate.io-string-primitive":502}],485:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],486:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],487:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],488:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":486,"./defaults.js":487,"./validate.js":490,"dup":117,"validate.io-array":491,"validate.io-string-primitive":502}],489:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":486,"./defaults.js":487,"./factory.js":488,"./validate.js":490,"dup":118,"validate.io-array":491,"validate.io-string-primitive":502}],490:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":495,"validate.io-object":500,"validate.io-string-primitive":502}],491:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],492:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":493,"dup":34,"validate.io-integer-primitive":494}],493:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],494:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":499}],495:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],496:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],497:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],498:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],499:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],500:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":501}],501:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],502:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],503:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":504,"dup":132,"validate.io-integer-primitive":505}],504:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],505:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":499}],506:[function(require,module,exports){
/**
*
*	COMPUTE: find
*
*
*	DESCRIPTION:
*		- Finds array elements which satisfy a test condition.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isInteger = require( 'validate.io-integer' );


// FIND //

/**
* FUNCTION: find( arr, [opts,], clbk )
*	Finds array elements which satisfy a test condition.
*
* @param {Array} arr - array from which elements will be tested
* @param {Object} [opts] - function options
* @param {Number} [opts.k] - limits the number of returned elements (default: `*`)
* @param {String} [opts.returns] - if `values`, values are returned; if `indices`, indices are returned; if `*`, both indices and values are returned (default: `indices`)
* @param {Function} clbk - function invoked for each array element. If the return value is truthy, the value is considered to have satisfied the test condition.
* @returns {Array} array of indices, element values, or arrays of index-value pairs
*/
function find( arr, opts, clbk ) {
	var returns = [ 'values', 'indices', '*' ],
		mode = 0,
		ret,
		len,
		k,
		v,
		i,
		count,
		out;

	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'find()::invalid input argument. Must provide an array.' );
	}
	len = arr.length;
	if ( arguments.length < 3 ) {
		clbk = opts;
		opts = {};
	}
	if ( typeof clbk !== 'function' ) {
		throw new TypeError( 'find()::invalid input argument. Callback argument must be a function.' );
	}
	if ( !isObject( opts ) ) {
		throw new TypeError( 'find()::invalid input argument. Options must be an object.' );
	}
	if ( opts.hasOwnProperty( 'k' ) ) {
		k = opts.k;
		if ( typeof k !== 'number' || k !== k || !isInteger( k ) ) {
			throw new TypeError( 'find()::invalid input argument. `k` must be an integer.' );
		}
	} else {
		k = len;
	}
	if ( opts.hasOwnProperty( 'returns' ) ) {
		ret = opts.returns;
		if ( typeof ret !== 'string' || returns.indexOf( ret ) === -1 ) {
			throw new TypeError( 'find()::invalid input argument. `returns` option must be a string and have one of the following values: `values`, `indices`, `all`.' );
		}
		if ( ret === 'values' ) {
			mode = 1;
		} else if ( ret === '*' ) {
			mode = 2;
		}
	}
	out = [];
	count = 0;

	if ( k === 0 ) {
		return out;
	}
	if ( k > 0 ) {
		// Search moving from begin-to-end [0,1,...]:
		for ( i = 0; i < len; i++ ) {
			v = arr[ i ];
			if ( clbk( v, i, arr ) ) {
				if ( mode === 2 ) {
					out.push( [ i, v ] );
				} else if ( mode === 1 ) {
					out.push( v );
				} else {
					out.push( i );
				}
				if ( ++count === k ) {
					break;
				}
			}
		}
		return out;
	}
	// Search moving from end-to-begin [...,2,1,0]:
	k = -k;
	for ( i = len-1; i >= 0; i-- ) {
		v = arr[ i ];
		if ( clbk( v, i, arr ) ) {
			if ( mode === 2 ) {
				out.push( [ i, v ] );
			} else if ( mode === 1 ) {
				out.push( v );
			} else {
				out.push( i );
			}
			if ( ++count === k ) {
				break;
			}
		}
	}
	return out;
} // end FUNCTION find()


// EXPORTS //

module.exports = find;

},{"validate.io-integer":507,"validate.io-object":509}],507:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":508}],508:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],509:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":510}],510:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],511:[function(require,module,exports){
'use strict';

// MODULES //

var createCopy = require( 'utils-copy' ),
	isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' ),
	isPositiveIntegerArray = require( 'validate.io-positive-integer-array' ),
	isBoolean = require( 'validate.io-boolean-primitive');


// FUNCTIONS //

/**
* FUNCTION: dims( arr, d, depth )
*	Determines matrix dimensions.
*
* @param {Array} arr - input array
* @param {Number[]} d - dimensions array
* @param {Number} depth - maximum number of dimensions
* @returns {Number[]} array of dimensions
*/
function dims( arr, d, depth ) {
	if ( depth && isArray( arr ) ) {
		d.push( arr.length );
		dims( arr[ 0 ], d, depth-1 );
	}
	return d;
} // end FUNCTION dims()

/**
* FUNCTION: createMatrixFcn( d )
*	Returns a function to flatten a matrix.
*
* @private
* @param {Number[d]} d - matrix dimensions
* @returns {Function} function which can be used to flatten a matrix having specified dimensions
*/
function createMatrixFcn( d ) {
	var len = d.length,
		n = len - 1,
		fcn,
		i;

	// Code generation. Create the variables...
	fcn = 'var o=[];var ';
	for ( i = 0; i < len; i++ ) {
		fcn += 'i' + i;
		if ( i < n ) {
			fcn += ',';
		} else {
			fcn += ';';
		}
	}
	// Create the nested for loops...
	for ( i = 0; i < len; i++ ) {
		fcn += 'for(i' + i + '=0;i' + i + '<' + d[ i ] + ';i' + i + '++){';
	}
	// Create the code which accesses the nested array values and pushes them onto the flattened array.
	fcn += 'o.push(x';
	for ( i = 0; i < len; i++ ) {
		fcn += '[i' + i + ']';
	}
	fcn += ');';

	// Tidy up:
	for ( i = 0; i < len; i++ ) {
		fcn += '}';
	}
	fcn += 'return o;';

	// Create a new function:
	return new Function( 'x', fcn );
} // end FUNCTION createMatrixFcn()

/**
* FUNCTION: recurse( out, arr, depth )
*	Recursively flattens an array.
*
* @private
* @param {Array} out - output array
* @param {Array} arr - input array
* @param {Number} depth - recursion depth
* @returns {Array} flattened array
*/
function recurse( out, arr, depth ) {
	var len = arr.length,
		val,
		i;

	for ( i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( depth && isArray( val ) ) {
			recurse( out, val, depth-1 );
		} else {
			out.push( val );
		}
	}
	return out;
} // end FUNCTION recurse()


// FLATTEN //

/**
* FUNCTION: flatten( arr[, options] )
*	Flattens an array.
*
* @param {Array} arr - input array
* @param {Object} [options] - function options
* @param {Number} [options.depth=Infinity] - maximum depth
* @param {Boolean} [options.matrix=false] - indicates whether the input array can be regarded as a matrix; i.e., all elements having same array dimensions
* @param {Boolean} [options.copy=false] - indicates whether array elements should be deep copied
* @returns {Array} flattened array
*/
function flatten( arr, opts ) {
	var isMatrix = false,
		depth = Number.POSITIVE_INFINITY,
		copy = false,
		out,
		fcn,
		d;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'flatten()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'flatten()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'matrix' ) ) {
			isMatrix = opts.matrix;
			if ( !isBoolean( isMatrix ) ) {
				throw new TypeError( 'flatten()::invalid option. Matrix option must be a boolean primitive. Option: `' + isMatrix + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'depth' ) ) {
			depth = opts.depth;
			if ( !isNonNegativeInteger( depth ) ) {
				throw new TypeError( 'flatten()::invalid option. Depth option must be a nonnegative integer. Option: `' + depth + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'flatten()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
	}
	if ( depth === 0 ) {
		out = arr;
	}
	else if ( isMatrix ) {
		d = dims( arr, [], depth );
		fcn = createMatrixFcn( d );
		out = fcn( arr );
	}
	else {
		out = recurse( [], arr, depth );
	}
	if ( copy ) {
		return createCopy( out );
	}
	return out;
} // end FUNCTION flatten()


// CREATE FLATTEN //

/**
* FUNCTION: createFlatten( d[, opts] )
*	Creates a customized function for flattening arrays having specified dimensions.
*
* @param {Number[]} d - dimension array
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy] - indicates whether to deep copy array elements
* @returns {Function} function for flattening arrays having specified dimensions
*/
function createFlatten( d, opts ) {
	var copy = false,
		fcn;
	if ( !isPositiveIntegerArray( d ) ) {
		throw new TypeError( 'createFlatten()::invalid input argument. Dimensions must be a positive integer array. Value: `' + d + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'createFlatten()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'createFlatten()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
	}
	fcn = createMatrixFcn( d );
	if ( copy ) {
		return function flatten( arr ) {
			return createCopy( fcn( arr ) );
		};
	}
	return fcn;
} // end FUNCTION createFlatten()


// EXPORTS //

module.exports = flatten;
module.exports.createFlatten = createFlatten;

},{"utils-copy":512,"validate.io-array":515,"validate.io-boolean-primitive":516,"validate.io-nonnegative-integer":517,"validate.io-object":520,"validate.io-positive-integer-array":521}],512:[function(require,module,exports){
/**
*
*	UTILS: copy
*
*
*	DESCRIPTION:
*		- Copy or deep clone a value to an arbitrary depth.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isBuffer = require( 'validate.io-buffer' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' ),
	typeName = require( 'type-name' );


// FUNCTIONS //

/**
* FUNCTION: indexOf( arr, val )
*	Returns the array index of a value. If the array does not contain the value, the function returns `-1`.
*
* @private
* @param {Array} arr - array
* @param {*} val - value for which to search
* @returns {Number} array index
*/
function indexOf( arr, val ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( arr[ i ] === val ) {
			return i;
		}
	}
	return -1;
} // end FUNCTION indexOf()

/**
* FUNCTION: objectKeys( obj )
*	Returns an object's keys.
*
* @private
* @param {Array|Object} obj - object
* @returns {Array} array of keys
*/
function objectKeys( obj ) {
	var keys = [],
		key;
	for ( key in obj ) {
		if ( obj.hasOwnProperty( key ) ) {
			keys.push( key );
		}
	}
	return keys;
} // end METHOD objectKeys()

/**
* Create functions for copying typed arrays.
*/
var typedArrays = {
	'Int8Array': null,
	'Uint8Array': null,
	'Uint8ClampedArray': null,
	'Int16Array': null,
	'Uint16Array': null,
	'Int32Array': null,
	'Uint32Array': null,
	'Float32Array': null,
	'Float64Array': null
};

(function createTypedArrayFcns() {
	/* jshint evil:true */
	var keys = objectKeys( typedArrays ),
		len = keys.length,
		key,
		i;
	for ( i = 0; i < len; i++ ) {
		key = keys[ i ];
		typedArrays[ key ] = new Function( 'arr', 'return new '+key+'( arr );' );
	}
})();

/**
* FUNCTION: cloneInstance( val )
*	Clones a class instance.
*
*	WARNING: this should only be used for simple cases. Any instances with privileged access to variables (e.g., within closures) cannot be cloned. This approach should be considered fragile.
*
*	NOTE: the function is greedy, disregarding the notion of a 'level'. Instead, the function deep copies all properties, as we assume the concept of 'level' applies only to the class instance reference but not to its internal state. This prevents, in theory, two instances from sharing state.
*
* @private
* @param {Object} val - class instance
* @returns {Object} new instance
*/
function cloneInstance( val ) {
	var cache = [],
		refs = [],
		names,
		name,
		desc,
		tmp,
		ref,
		i;

	ref = Object.create( Object.getPrototypeOf( val ) );
	cache.push( val );
	refs.push( ref );

	names = Object.getOwnPropertyNames( val );
	for ( i = 0; i < names.length; i++ ) {
		name = names[ i ];
		desc = Object.getOwnPropertyDescriptor( val, name );
		if ( desc.hasOwnProperty( 'value' ) ) {
			tmp = ( isArray( val[name] ) ) ? [] : {};
			desc.value = deepCopy( val[name], tmp, cache, refs, -1 );
		}
		Object.defineProperty( ref, name, desc );
	}
	if ( !Object.isExtensible( val ) ) {
		Object.preventExtensions( ref );
	}
	if ( Object.isSealed( val ) ) {
		Object.seal( ref );
	}
	if ( Object.isFrozen( val ) ) {
		Object.freeze( ref );
	}
	return ref;
} // end FUNCTION cloneInstance()


// DEEP COPY //

/**
* FUNCTION: deepCopy( val, copy, cache, refs, level )
*	Recursively performs a deep copy of an input object.
*
* @private
* @param {Array|Object} val - value to copy
* @param {Array|Object} copy - copy
* @param {Array} cache - an array of visited objects
* @param {Array} refs - an array of object references
* @param {Number} level - copy depth
* @returns {*} deep copy
*/
function deepCopy( val, copy, cache, refs, level ) {
	var keys,
		name,
		key,
		ref,
		x,
		i, j;

	// [-] Decrement the level...
	level = level - 1;

	// [0] Primitives and functions...
	if ( typeof val !== 'object' || val === null ) {
		return val;
	}
	// [1] Node.js Buffer objects...
	if ( isBuffer( val ) ) {
		return new val.constructor( val );
	}
	name = typeName( val );

	// [2] Sets and Maps...
	if ( name === 'Set' || name === 'Map' ) {
		console.warn( 'copy()::not supported. Copying Sets and Maps is not currently supported. File an issue, submit a pull request, or contact the author directly at kgryte@gmail.com.' );
		return {};
	}
	// [3] Number, String, and Boolean objects...
	if ( name === 'String' || name === 'Boolean' || name === 'Number' ) {
		// Return an equivalent primitive!
		return val.valueOf();
	}
	// [4] Date objects...
	if ( name === 'Date' ) {
		return new Date( +val );
	}
	// [5] Regular expressions...
	if ( name === 'RegExp' ) {
		val = val.toString();
		i = val.lastIndexOf( '/' );
		return new RegExp( val.slice( 1, i ), val.slice( i+1 ) );
	}
	// [6] Typed arrays...
	if ( typedArrays.hasOwnProperty( name ) ) {
		return typedArrays[ name ]( val );
	}
	// [7] Class instances...
	if ( name !== 'Array' && name !== 'Object' ) {
		// Require ES5 or higher...
		if ( typeof Object.freeze === 'function' ) {
			return cloneInstance( val );
		}
		return {};
	}
	// [8] Arrays and objects...
	keys = objectKeys( val );
	if ( level > 0 ) {
		for ( j = 0; j < keys.length; j++ ) {
			key = keys[ j ];
			x = val[ key ];

			// [8.1] Primitive, Buffer, special class instance...
			name = typeName( x );
			if ( typeof x !== 'object' || x === null || (name !== 'Array' && name !== 'Object') || isBuffer( x ) ) {
				copy[ key ] = deepCopy( x );
				continue;
			}
			// [8.2] Circular reference...
			i = indexOf( cache, x );
			if ( i !== -1 ) {
				copy[ key ] = refs[ i ];
				continue;
			}
			// [8.3] Plain array or object...
			ref = ( isArray(x) ) ? [] : {};
			cache.push( x );
			refs.push( ref );
			copy[ key ] = deepCopy( x, ref, cache, refs, level );
		}
	} else {
		for ( j = 0; j < keys.length; j++ ) {
			key = keys[ j ];
			copy[ key ] = val[ key ];
		}
	}
	return copy;
} // end FUNCTION deepCopy()

/**
* FUNCTION: createCopy( value[, level] )
*	Copy or deep clone a value to an arbitrary depth.
*
* @param {*} value - value to be copied
* @param {Number} [level=+infinity] - option to control copy depth. For example, set to `0` for a shallow copy. Default behavior returns a full deep copy.
* @returns {*} copy
*/
function createCopy( val, level ) {
	var copy;
	if ( arguments.length > 1 ) {
		if ( !isNonNegativeInteger( level ) ) {
			throw new TypeError( 'copy()::invalid input argument. Level must be a nonnegative integer. Value: `' + level + '`.' );
		}
		if ( level === 0 ) {
			return val;
		}
	} else {
		level = Number.POSITIVE_INFINITY;
	}
	copy = ( isArray(val) ) ? [] : {};
	return deepCopy( val, copy, [val], [copy], level );
} // end FUNCTION createCopy()


// EXPORTS //

module.exports = createCopy;

},{"type-name":513,"validate.io-array":515,"validate.io-buffer":514,"validate.io-nonnegative-integer":517}],513:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],514:[function(require,module,exports){
/**
*
*	VALIDATE: buffer
*
*
*	DESCRIPTION:
*		- Validates if a value is a Buffer object.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

/**
* FUNCTION: isBuffer( value )
*	Validates if a value is a Buffer object.
*
* @param {*} value - value to validate
* @returns {Boolean} boolean indicating if a value is a Buffer object
*/
function isBuffer( val ) {
	return typeof val === 'object' && val !== null && val.constructor && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer( val );
} // end FUNCTION isBuffer()


// EXPORTS //

module.exports = isBuffer;

},{}],515:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],516:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],517:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":518}],518:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":519}],519:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],520:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":515}],521:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// IS POSITIVE INTEGER ARRAY //

/**
* FUNCTION: isPositiveIntegerArray( value )
*	Validates if a value is a positive integer array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a positive integer array
*/
function isPositiveIntegerArray( value ) {
	var len, i;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( i = 0; i < len; i++ ) {
		if ( !isPositiveInteger( value[i] ) ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isPositiveIntegerArray()


// EXPORTS //

module.exports = isPositiveIntegerArray;

},{"validate.io-array":515,"validate.io-positive-integer":522}],522:[function(require,module,exports){
/**
*
*	VALIDATE: positive-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a positive integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS POSITIVE INTEGER //

/**
* FUNCTION: isPositiveInteger( value )
*	Validates if a value is a positive integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a positive integer
*/
function isPositiveInteger( value ) {
	return isInteger( value ) && value > 0;
} // end FUNCTION isPositiveInteger()


// EXPORTS //

module.exports = isPositiveInteger;

},{"validate.io-integer":523}],523:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":524}],524:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],525:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isIntegerArray = require( 'validate.io-integer-array' ),
	isFunction = require( 'validate.io-function' );


// VARIABLES //

var MAXINT = Math.pow( 2, 53 ) - 1;


// FUNCTIONS //

/**
* FUNCTION: gcd( a, b )
*	Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.
*
* @param {Number} a - integer
* @param {Number} b - integer
* @returns {Number} greatest common divisor
*/
function gcd( a, b ) {
	var k = 1,
		t;
	// Simple cases:
	if ( a === 0 ) {
		return b;
	}
	if ( b === 0 ) {
		return a;
	}
	// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...
	while ( a%2 === 0 && b%2 === 0 ) {
		a = a / 2; // right shift
		b = b / 2; // right shift
		k = k * 2; // left shift
	}
	// Reduce `a` to an odd number...
	while ( a%2 === 0 ) {
		a = a / 2; // right shift
	}
	// Henceforth, `a` is always odd...
	while ( b ) {
		// Remove all factors of 2 in `b`, as they are not common...
		while ( b%2 === 0 ) {
			b = b / 2; // right shift
		}
		// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...
		if ( a > b ) {
			t = b;
			b = a;
			a = t;
		}
		b = b - a; // b=0 iff b=a
	}
	// Restore common factors of 2...
	return k * a;
} // end FUNCTION gcd()

/**
* FUNCTION: bitwise( a, b )
*	Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.
*
* @param {Number} a - safe integer
* @param {Number} b - safe integer
* @returns {Number} greatest common divisor
*/
function bitwise( a, b ) {
	var k = 0,
		t;
	// Simple cases:
	if ( a === 0 ) {
		return b;
	}
	if ( b === 0 ) {
		return a;
	}
	// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...
	while ( (a & 1) === 0 && (b & 1) === 0 ) {
		a >>>= 1; // right shift
		b >>>= 1; // right shift
		k++;
	}
	// Reduce `a` to an odd number...
	while ( (a & 1) === 0 ) {
		a >>>= 1; // right shift
	}
	// Henceforth, `a` is always odd...
	while ( b ) {
		// Remove all factors of 2 in `b`, as they are not common...
		while ( (b & 1) === 0 ) {
			b >>>= 1; // right shift
		}
		// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...
		if ( a > b ) {
			t = b;
			b = a;
			a = t;
		}
		b = b - a; // b=0 iff b=a
	}
	// Restore common factors of 2...
	return a << k;
} // end FUNCTION bitwise()


// GREATEST COMMON DIVISOR //

/**
* FUNCTION: compute( arr[, clbk] )
*	Computes the greatest common divisor.
*
* @param {Number[]|Number} arr - input array of integers
* @param {Function|Number} [clbk] - accessor function for accessing array values
* @returns {Number|Null} greatest common divisor or null
*/
function compute() {
	var nargs = arguments.length,
		args,
		clbk,
		arr,
		len,
		a, b,
		i;

	// Copy the input arguments to an array...
	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}
	// Have we been provided with integer arguments?
	if ( isIntegerArray( args ) ) {
		if ( nargs === 2 ) {
			a = args[ 0 ];
			b = args[ 1 ];
			if ( a < 0 ) {
				a = -a;
			}
			if ( b < 0 ) {
				b = -b;
			}
			if ( a <= MAXINT && b <= MAXINT ) {
				return bitwise( a, b );
			} else {
				return gcd( a, b );
			}
		}
		arr = args;
	}
	// If not integers, ensure the first argument is an array...
	else if ( !isArray( args[ 0 ] ) ) {
		throw new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );
	}
	// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...
	else if ( nargs > 1 ) {
		arr = args[ 0 ];
		clbk = args[ 1 ];
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	// We have been provided an array...
	else {
		arr = args[ 0 ];
	}
	len = arr.length;

	// Check if a sufficient number of values have been provided...
	if ( len < 2 ) {
		return null;
	}
	// If an accessor is provided, extract the array values...
	if ( clbk ) {
		a = new Array( len );
		for ( i = 0; i < len; i++ ) {
			a[ i ] = clbk( arr[ i ], i );
		}
		arr = a;
	}
	// Given an input array, ensure all array values are integers...
	if ( nargs < 3 ) {
		if ( !isIntegerArray( arr ) ) {
			throw new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );
		}
	}
	// Convert any negative integers to positive integers...
	for ( i = 0; i < len; i++ ) {
		a = arr[ i ];
		if ( a < 0 ) {
			arr[ i ] = -a;
		}
	}
	// Exploit the fact that the gcd is an associative function...
	a = arr[ 0 ];
	for ( i = 1; i < len; i++ ) {
		b = arr[ i ];
		if ( b <= MAXINT && a <= MAXINT ) {
			a = bitwise( a, b );
		} else {
			a = gcd( a, b );
		}
	}
	return a;
} // end FUNCTION compute()


// EXPORTS //

module.exports = compute;

},{"validate.io-array":526,"validate.io-function":527,"validate.io-integer-array":528}],526:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],527:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],528:[function(require,module,exports){
/**
*
*	VALIDATE: integer-array
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isInteger = require( 'validate.io-integer' );


// IS INTEGER ARRAY //

/**
* FUNCTION: isIntegerArray( value )
*	Validates if a value is an integer array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is an integer array
*/
function isIntegerArray( value ) {
	var len;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( var i = 0; i < len; i++ ) {
		if ( !isInteger( value[i] ) ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isIntegerArray()


// EXPORTS //

module.exports = isIntegerArray;

},{"validate.io-array":526,"validate.io-integer":529}],529:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":530}],530:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],531:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isString = require( 'validate.io-string-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isObject = require( 'validate.io-object' );


// GREATER THAN OR EQUAL TO //

/**
* FUNCTION: geq( arr, x[, opts] )
*	Computes an element-wise comparison (greater than or equal to) of an array.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number|String} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} array of 1s and 0s, where a `1` indicates that an input array element is greater than or equal to a compared value and `0` indicates that an input array element is not greater than or equal to a compared value
*/
function geq( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'geq()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) && !isString( x ) ) {
		throw new TypeError( 'geq()::invalid input argument. Comparison input must either be an array, number primitive, or string primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'geq()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'geq()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'geq()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: comparison array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'geq()::invalid input argument. Comparison array must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i, 0 ) >= clbk( x[i], i, 1 ) ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i ) >= x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] >= x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
	}
	// Case 2: accessor and single comparator
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			if ( clbk( arr[ i ], i ) >= x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	// Case 3: single comparator
	else {
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] >= x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	return out;
} // end FUNCTION geq()


// EXPORTS //

module.exports = geq;

},{"validate.io-array":532,"validate.io-boolean-primitive":533,"validate.io-function":534,"validate.io-number-primitive":535,"validate.io-object":536,"validate.io-string-primitive":537}],532:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],533:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],534:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],535:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],536:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":532}],537:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],538:[function(require,module,exports){
/**
*
*	COMPUTE: gmean
*
*
*	DESCRIPTION:
*		- Computes the geometric mean of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isFunction = require( 'validate.io-function' );


// GEOMETRIC MEAN //

/**
* FUNCTION: gmean( arr[, accessor ] )
*	Computes the geometric mean of an array.
*
* @param {Array} arr - input array
* @param {Function} [accessor] - accessor function for accessing numeric array values
* @returns {Number|null} geometric mean
*/
function gmean( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'gmean()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 && !isFunction( clbk ) ) {
		throw new TypeError( 'gmean()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
	}
	var len = arr.length,
		sum = 0,
		val,
		i;

	if ( !len ) {
		return null;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			val = clbk( arr[ i ] );
			if ( val <= 0 ) {
				return NaN;
			}
			sum += Math.log( val ) / len;
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( val <= 0 ) {
				return NaN;
			}
			sum += Math.log( val ) / len;
		}
	}
	return Math.exp( sum );
} // end FUNCTION gmean()


// EXPORTS //

module.exports = gmean;

},{"validate.io-array":539,"validate.io-function":540}],539:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],540:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],541:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isString = require( 'validate.io-string-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isObject = require( 'validate.io-object' );


// GREATER THAN //

/**
* FUNCTION: gt( arr, x[, opts] )
*	Computes an element-wise comparison (greater than) of an array.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number|String} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} array of 1s and 0s, where a `1` indicates that an input array element is greater than a compared value and `0` indicates that an input array element is not greater than a compared value
*/
function gt( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'gt()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) && !isString( x ) ) {
		throw new TypeError( 'gt()::invalid input argument. Comparison input must either be an array, number primitive, or string primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'gt()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'gt()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'gt()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: comparison array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'gt()::invalid input argument. Comparison array must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i, 0 ) > clbk( x[i], i, 1 ) ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i ) > x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] > x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
	}
	// Case 2: accessor and single comparator
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			if ( clbk( arr[ i ], i ) > x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	// Case 3: single comparator
	else {
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] > x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	return out;
} // end FUNCTION gt()


// EXPORTS //

module.exports = gt;

},{"validate.io-array":542,"validate.io-boolean-primitive":543,"validate.io-function":544,"validate.io-number-primitive":545,"validate.io-object":546,"validate.io-string-primitive":547}],542:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],543:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],544:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],545:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],546:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":542}],547:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],548:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isString = require( 'validate.io-string' ),
	isFunction = require( 'validate.io-function' );


// HAMMING DISTANCE //

/**
* FUNCTION: hamming( a, b, accessor )
*	Computes the Hamming distance between two sequences.
*
* @param {String|Array} a - array or string sequence
* @param {String|Array} b - array or string sequence
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Number} Hamming distance
*/
function hamming( a, b, clbk ) {
	var aType = isString( a ),
		bType = isString( b ),
		len,
		d, i;

	if ( !isArray( a ) && !aType ) {
		throw new TypeError( 'hamming()::invalid input argument. Sequence must be either an array or a string. Value: `' + a + '`.' );
	}
	if ( !isArray( b ) && !bType ) {
		throw new TypeError( 'hamming()::invalid input argument. Sequence must be either an array or a string. Value: `' + b + '`.' );
	}
	if ( aType !== bType ) {
		throw new TypeError( 'hamming()::invalid input arguments. Sequences must be the same type; i.e., both strings or both arrays.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'hamming()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	len = a.length;
	if ( len !== b.length ) {
		throw new Error( 'hamming()::invalid input arguments. Sequences must be the same length.' );
	}
	d = 0;
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			if ( clbk( a[i], i, 0 ) !== clbk( b[i], i, 1 ) ) {
				d += 1;
			}
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			if ( a[ i ] !== b[ i ] ) {
				d += 1;
			}
		}
	}
	return d;
} // end FUNCTION hamming()


// EXPORTS //

module.exports = hamming;

},{"validate.io-array":549,"validate.io-function":550,"validate.io-string":551}],549:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],550:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],551:[function(require,module,exports){
/**
*
*	VALIDATE: string
*
*
*	DESCRIPTION:
*		- Validates if a value is a string.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isString( value )
*	Validates if a value is a string.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a string
*/
function isString( value ) {
	return typeof value === 'string' || Object.prototype.toString.call( value ) === '[object String]';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],552:[function(require,module,exports){
/**
*
*	COMPUTE: hmean
*
*
*	DESCRIPTION:
*		- Computes the harmonic mean over an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// HMEAN //

	/**
	* FUNCTION: hmean( arr )
	*	Computes the harmonic mean over an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} harmonic mean
	*/
	function hmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'hmean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			sum = 0,
			val;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( val <= 0 ) {
				return NaN;
			}
			sum += 1 / val;
		}
		return len / sum;
	} // end FUNCTION hmean()


	// EXPORTS //

	module.exports = hmean;

})();
},{}],553:[function(require,module,exports){
/**
*
*	COMPUTE: hypot
*
*
*	DESCRIPTION:
*		- Computes the hypotenuse of a right triangle.
*
*
*	NOTES:
*		[1] Based on http://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/ .
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// MODULES //

	var isNumeric = require( 'validate.io-number' );


	// HYPOT //

	/**
	* FUNCTION: hypot( a, b )
	*	Computes the hypotenuse of a right triangle.
	*
	* @param {Number} a - length of one side of triangle
	* @param {Number} b - length of other side of a triangle
	* @returns {Number} hypotenuse
	*/
	function hypot( a, b ) {
		if ( !isNumeric( a ) || !isNumeric( b ) ) {
			throw new TypeError( 'hypot()::invalid input argument. Input arguments must be numeric.' );
		}
		var min, max, r;
		a = Math.abs( a );
		b = Math.abs( b );
		if ( a > b ) {
			min = b;
			max = a;
		} else  {
			min = a;
			max = b;
		}
		r = min / max;
		return max * Math.sqrt( 1 + r*r );
	} // end FUNCTION hypot()


	// EXPORTS //

	module.exports = hypot;

})();
},{"validate.io-number":554}],554:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],555:[function(require,module,exports){
/**
*
*	COMPUTE: idr
*
*
*	DESCRIPTION:
*		- Computes the interdecile range for an array of values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	quantile = require( 'compute-quantile' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// INTERDECILE RANGE //

/**
* FUNCTION: idr( arr[, opts] )
*	Computes the interdecile range for an array.
*
* @param {Array} arr - array of values
* @param {Object} [opts] - quantile options
* @returns {Number} interdecile range
*/
function idr( arr, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'idr()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'idr()::invalid input argument. Options should be an object.' );
		}
	} else {
		opts = {
			'sorted': false
		};
	}
	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
		opts.sorted = true;
	}
	return quantile( arr, 0.90, opts ) - quantile( arr, 0.10, opts );
} // end FUNCTION idr()


// EXPORTS //

module.exports = idr;

},{"compute-quantile":848,"validate.io-object":556}],556:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":557}],557:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],558:[function(require,module,exports){
/**
*
*	COMPUTE: incrdatespace
*
*
*	DESCRIPTION:
*		- Generates an array of linearly spaced dates using a provided increment.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

var isObject = require( 'validate.io-object' );


// VARIABLES //

var rounders,
	convert,
	timestamp,
	units,
	reUnits,
	fmt;

// Rounding options:
rounders = [
	'floor',
	'ceil',
	'round'
];

// Units:
units = [
	'y',
	'b',
	'w',
	'd',
	'h',
	'm',
	's',
	'ms'
];

// Conversions to milliseconds:
convert = {
	'ms': 1,
	's': 1000, // 1*1000
	'm': 60000, // 60*1000
	'h': 3600000, // 60000*60
	'd': 86400000, // 3600000*24
	'w': 604800000, // 86400000*7
	'b': 2629800000, // 365.25/12*86400000
	'y': 31557600000 // 365.25*86400000
};

// Regular expressions...
timestamp = /^\d{10}$|^\d{13}$/;

reUnits = {
	'ms': /^\d{0,}ms$|^\d{0,}millisecond$|^\d{0,}milliseconds$/,
	's': /^\d{0,}s$|^\d{0,}sec$|^\d{0,}secs$|^\d{0,}second$|^\d{0,}seconds$/,
	'm': /^\d{0,}m$|^\d{0,}min$|^\d{0,}mins$|^\d{0,}minute$|^\d{0,}minutes$/,
	'h': /^\d{0,}h$|^\d{0,}hr$|^\d{0,}hrs$|^\d{0,}hour$|^\d{0,}hours$/,
	'd': /^\d{0,}d$|^\d{0,}day$|^\d{0,}days$/,
	'w': /^\d{0,}w$|^\d{0,}wk$|^\d{0,}wks$|^\d{0,}week$|^\d{0,}weeks$/,
	'b': /^\d{0,}b$|^\d{0,}month$|^\d{0,}months$/,
	'y': /^\d{0,}y$|^\d{0,}yr$|^\d{0,}yrs$|^\d{0,}year$|^\d{0,}years$/
};

fmt = /^\d{0,}[a-z]+$/;


// FUNCTIONS //

/**
* FUNCTION: validDate( value, name )
*	Validates a date parameter.
*
* @private
* @param {*} value - value to be validated
* @param {String} name - name to be used in error messages
* @returns {Date} validated date
*/
function validDate( value, name ) {
	var type;

	type = typeof value;
	if ( type === 'string' ) {
		value = Date.parse( value );
		if ( value !== value ) {
			throw new Error( 'incrdatespace()::invalid input argument. Unable to parse ' +  name.toLowerCase() + ' date.' );
		}
		value = new Date( value );
	}
	if ( type === 'number' ) {
		if ( !timestamp.test( value ) ) {
			throw new Error( 'incrdatespace()::invalid input argument. Numeric ' + name.toLowerCase() + ' date must be either a Unix or Javascript timestamp.' );
		}
		if ( value.toString().length === 10 ) {
			value = value * 1000; // sec to ms
		}
		value = new Date( value );
	}
	if ( !(value instanceof Date) ) {
		throw new TypeError( 'incrdatespace()::invalid input argument. ' + name + ' date must either be a date string, Date object, Unix timestamp, or JavaScript timestamp.' );
	}
	return value;
} // end FUNCTION validDate()

/**
* FUNCTION: validIncrement( x )
*	Validates an increment.
*
* @private
* @param {String|Number} x - increment to be validated
* @returns {Number} increment in milliseconds
*/
function validIncrement( x ) {
	var N = units.length,
		sign = false,
		parts,
		len,
		unit,
		val,
		flg,
		i;

	if ( typeof x === 'number' ) {
		if ( x !== x ) {
			throw new TypeError( 'incrdatespace()::invalid value. Increment must be a valid number.' );
		}
		return x;
	}
	if ( typeof x !== 'string' ) {
		throw new TypeError( 'incrdatespace()::invalid value. Increment must be either a string or number.' );
	}
	// Convert the formatted string to milliseconds...
	if ( x[ 0 ] === '-' ) {
		sign = true;
		x = x.substr( 1 );
	}
	parts = x.split( '.' );
	len = parts.length;
	x = 0;
	while ( len ) {
		flg = false;
		val = parts.pop();
		if ( !fmt.test( val ) ) {
			throw new Error( 'incrdatespace()::invalid value. Scalar unit pair must have the following format: `ms`, `5ms`, `5days`, etc.' );
		}
		for ( i = 0; i < N; i++ ) {
			unit = units[ i ];
			if ( reUnits[ unit ].test( val ) ) {
				flg = true;
				val = parseInt( val, 10 );
				if ( val !== val ) {
					// No scalar...
					val = 1;
				}
				x += val * convert[ unit ];
				break;
			}
		}
		if ( !flg ) {
			throw new Error( 'incrdatespace()::invalid value. Unrecognized unit: `' + val + '`.' );
		}
		len = parts.length;
	}
	if ( sign ) {
		return -x;
	}
	return x;
} // end FUNCTION validIncrement()


// INCRDATESPACE //

/**
* FUNCTION: incrdatespace( start, stop[, increment, options])
*	Generates an array of linearly spaced dates using a provided increment.
*
* @param {Date|Number|String} start - start time as either a `Date` object, Unix timestamp, JavaScript timestamp, or date string
* @param {Data|Number|String} stop - stop time as either a `Date` object, Unix timestamp, JavaScript timestamp, or date string
* @param {Number|String} [increment] - value by which to increment successive dates (default: 'day')
* @param {Object} [options] - function options
* @param {String} [options.round] - specifies how sub-millisecond times should be rounded: [ 'floor', 'ceil', 'round' ] (default: 'floor' )
* @returns {Array} array of dates
*/
function incrdatespace( start, stop, increment, options ) {
	var nArgs = arguments.length,
		opts = {
			'round': 'floor'
		},
		incr = convert[ 'd' ],
		flg = true,
		round,
		len,
		i,
		tmp,
		arr;

	start = validDate( start, 'Start' );
	stop = validDate( stop, 'Stop' );

	if ( nArgs > 2 ) {
		if ( nArgs === 3 ) {
			if ( isObject( increment ) ) {
				opts = increment;
			} else {
				incr = increment;

				// Turn off checking the options object...
				flg = false;
			}
		} else {
			opts = options;
			incr = increment;
		}
		incr = validIncrement( incr );
		if ( flg ) {
			if ( !isObject( opts ) ) {
				throw new TypeError( 'incrdatespace()::invalid input argument. Options must be an object.' );
			}
			if ( opts.hasOwnProperty( 'round' ) ) {
				if ( typeof opts.round !== 'string' ) {
					throw new TypeError( 'incrdatespace()::invalid input argument. Round option must be a string.' );
				}
				if ( rounders.indexOf( opts.round ) === -1 ) {
					throw new Error( 'incrdatespace()::invalid input argument. Unrecognized round option. Must be one of [' + rounders.join( ',' ) + '].' );
				}
			} else {
				opts.round = 'floor';
			}
		}
	}
	round = Math[ opts.round ];

	// Calculate the array length:
	len = Math.ceil( ( stop-start ) / incr );
	if ( len < 0 ) {
		return [ start ];
	}

	// Build the output array...
	if ( len > 64000 ) {
		// Ensure fast elements...
		arr = [];
		arr.push( start );
		tmp = start.getTime();
		for ( i = 1; i < len; i++ ) {
			tmp += incr;
			arr.push( new Date( round( tmp ) ) );
		}
		return arr;
	}
	arr = new Array( len );
	arr[ 0 ] = start;
	tmp = start.getTime();
	for ( i = 1; i < len; i++ ) {
		tmp += incr;
		arr[ i ] = new Date( round( tmp ) );
	}
	return arr;
} // end FUNCTION incrdatespace()


// EXPORTS //

module.exports = incrdatespace;

},{"validate.io-object":559}],559:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":560}],560:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],561:[function(require,module,exports){
'use strict';

// INCREMENTAL MAX //

/**
* FUNCTION: incrmax()
*	Returns a method to compute the maximum value incrementally.
*
* @returns {Function} method to compute the max incrementally
*/
function incrmax() {
	var max = null;
	/**
	* FUNCTION: incrmax( [value] )
	*	If a `value` is provided, updates and returns the updated max. If no `value` is provided, returns the current max.
	*
	* @param {Number} [value] - value used to update the max
	* @returns {Number|Null} max value or null
	*/
	return function incrmax( x ) {
		if ( !arguments.length ) {
			return max;
		}
		if ( x > max || max === null ) {
			max = x;
		}
		return max;
	};
} // end FUNCTION incrmax()


// EXPORTS //

module.exports = incrmax;

},{}],562:[function(require,module,exports){
/**
*
*	COMPUTE: incrmean
*
*
*	DESCRIPTION:
*		- Provides a method to compute an arithmetic mean incrementally.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// INCREMENTAL MEAN //

/**
* FUNCTION: incrmean()
*	Returns a method to compute an arithmetic mean incrementally.
*
* @returns {Function} method to compute an arithmetic mean incrementally
*/
function incrmean() {
	var mu = 0,
		N = 0,
		delta;
	/**
	* FUNCTION: incrmean( [value] )
	*	If a `value` is provided, updates and returns the updated mean. If no `value` is provided, returns the current mean.
	*
	* @param {Number} [value] - value used to update the mean
	* @returns {Number} mean value
	*/
	return function incrmean( x ) {
		if ( !arguments.length ) {
			return mu;
		}
		N += 1;
		delta = x - mu;
		mu += delta / N;
		return mu;
	};
} // end FUNCTION incrmean()


// EXPORTS //

module.exports = incrmean;

},{}],563:[function(require,module,exports){
'use strict';

// INCREMENTAL MIN //

/**
* FUNCTION: incrmin()
*	Returns a method to compute the minimum value incrementally.
*
* @returns {Function} method to compute the min incrementally
*/
function incrmin() {
	var min = null;
	/**
	* FUNCTION: incrmin( [value] )
	*	If a `value` is provided, updates and returns the updated min. If no `value` is provided, returns the current min.
	*
	* @param {Number} [value] - value used to update the min
	* @returns {Number|Null} min value
	*/
	return function incrmin( x ) {
		if ( !arguments.length ) {
			return min;
		}
		if ( x < min || min === null ) {
			min = x;
		}
		return min;
	};
} // end FUNCTION incrmin()


// EXPORTS //

module.exports = incrmin;

},{}],564:[function(require,module,exports){
'use strict';

// MODULES //

var isPositiveInteger = require( 'validate.io-positive-integer' );


// INCREMENTAL MOVING MEAN //

/**
* FUNCTION: incrmmean( W )
*	Returns a method to compute a moving arithmetic mean incrementally.
*
* @param {Number} W - window size
* @returns {Function} method to compute a moving arithmetic mean incrementally
*/
function incrmmean( W ) {
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'incrmmean()::invalid input argument. Window size must be a positive integer. Value: `' + W + '`.' );
	}
	var arr = new Array( W ),
		mu = 0,
		N = 0,
		i = -1,
		delta;
	/**
	* FUNCTION: incrmmean( [value] )
	*	If a `value` is provided, updates and returns the updated mean. If no `value` is provided, returns the current mean.
	*
	* @param {Number} [value] - value used to update the moving mean
	* @returns {Number|Null} mean or null
	*/
	return function incrmmean( x ) {
		if ( !arguments.length ) {
			if ( N === 0 ) {
				return null;
			}
			return mu;
		}
		// Update the index for managing the circular buffer...
		i = (i+1) % W;

		// Fill up the initial window; else, update the existing window...
		if ( N < W ) {
			N += 1;
			delta = x - mu;
			mu += delta / N;
		} else {
			delta = x - arr[ i ];
			mu += delta / W;
		}
		arr[ i ] = x;
		return mu;
	};
} // end FUNCTION incrmmean()


// EXPORTS //

module.exports = incrmmean;

},{"validate.io-positive-integer":565}],565:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":566}],566:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":567}],567:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],568:[function(require,module,exports){
'use strict';

// MODULES //

var isPositiveInteger = require( 'validate.io-positive-integer' );


// INCREMENTAL MOVING SAMPLE STANDARD DEVIATION //

/**
* FUNCTION: incrmstdev( W )
*	Returns a method to compute a moving sample standard deviation incrementally.
*
* @param {Number} W - window size
* @returns {Function} method to compute a moving sample standard deviation incrementally
*/
function incrmstdev( W ) {
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'incrmstdev()::invalid input argument. Window size must be a positive integer. Value: `' + W + '`.' );
	}
	var arr = new Array( W ),
		n = W - 1,
		M2 = 0,
		mu = 0,
		N = 0,
		i = -1,
		delta,
		tmp,
		d1,
		d2;
	/**
	* FUNCTION: incrmstdev( [value] )
	*	If a `value` is provided, updates and returns the updated sample standard deviation. If no `value` is provided, returns the current sample standard deviation.
	*
	* @param {Number} [value] - value used to update the moving sample standard deviation
	* @returns {Number|Null} sample standard deviation or null
	*/
	return function incrmstdev( x ) {
		if ( !arguments.length ) {
			if ( N === 0 ) {
				return null;
			}
			if ( N === 1 ) {
				return 0;
			}
			if ( N < W ) {
				return Math.sqrt( M2 / (N-1) );
			}
			return Math.sqrt( M2 / n );
		}
		// Update the index for managing the circular buffer...
		i = (i+1) % W;

		// Fill up the initial window; else, update the existing window...
		if ( N < W ) {
			arr[ i ] = x;
			N += 1;
			delta = x - mu;
			mu += delta / N;
			M2 += delta * (x - mu);
			if ( N === 1 ) {
				return 0;
			}
			return Math.sqrt( M2 / (N-1) );
		}
		if ( N === 1 ) {
			return 0;
		}
		tmp = arr[ i ];
		arr[ i ] = x;
		delta = x - tmp;
		d1 = tmp - mu;
		mu += delta / W;
		d2 = x - mu;
		M2 += delta * (d1 + d2);

		return Math.sqrt( M2 / n );
	};
} // end FUNCTION incrmstdev()


// EXPORTS //

module.exports = incrmstdev;

},{"validate.io-positive-integer":569}],569:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":570}],570:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":571}],571:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],572:[function(require,module,exports){
'use strict';

// MODULES //

var isPositiveInteger = require( 'validate.io-positive-integer' );


// INCREMENTAL MOVING SUM //

/**
* FUNCTION: incrmsum( W )
*	Returns a method to compute a moving sum incrementally.
*
* @param {Number} W - window size
* @returns {Function} method to compute a moving sum incrementally
*/
function incrmsum( W ) {
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'incrmsum()::invalid input argument. Window size must be a positive integer. Value: `' + W + '`.' );
	}
	var arr = new Array( W ),
		sum = 0,
		N = 0,
		i = -1;
	/**
	* FUNCTION: incrmsum( [value] )
	*	If a `value` is provided, updates and returns the updated sum. If no `value` is provided, returns the current sum.
	*
	* @param {Number} [value] - value used to update the moving sum
	* @returns {Number|Null} sum or null
	*/
	return function incrmsum( x ) {
		if ( !arguments.length ) {
			if ( N === 0 ) {
				return null;
			}
			return sum;
		}
		// Update the index for managing the circular buffer...
		i = (i+1) % W;

		// Fill up the initial window; else, update the existing window...
		if ( N < W ) {
			N += 1;
			sum += x;
		} else {
			sum += x - arr[ i ];
		}
		arr[ i ] = x;
		return sum;
	};
} // end FUNCTION incrmsum()


// EXPORTS //

module.exports = incrmsum;

},{"validate.io-positive-integer":573}],573:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":574}],574:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":575}],575:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],576:[function(require,module,exports){
'use strict';

// MODULES //

var isPositiveInteger = require( 'validate.io-positive-integer' );


// INCREMENTAL MOVING SAMPLE VARIANCE //

/**
* FUNCTION: incrmvariance( W )
*	Returns a method to compute a moving sample variance incrementally.
*
* @param {Number} W - window size
* @returns {Function} method to compute a moving sample variance incrementally
*/
function incrmvariance( W ) {
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'incrmvariance()::invalid input argument. Window size must be a positive integer. Value: `' + W + '`.' );
	}
	var arr = new Array( W ),
		n = W - 1,
		M2 = 0,
		mu = 0,
		N = 0,
		i = -1,
		delta,
		tmp,
		d1,
		d2;
	/**
	* FUNCTION: incrmvariance( [value] )
	*	If a `value` is provided, updates and returns the updated sample variance. If no `value` is provided, returns the current sample variance.
	*
	* @param {Number} [value] - value used to update the moving sample variance
	* @returns {Number|Null} sample variance or null
	*/
	return function incrmvariance( x ) {
		if ( !arguments.length ) {
			if ( N === 0 ) {
				return null;
			}
			if ( N === 1 ) {
				return 0;
			}
			if ( N < W ) {
				return M2 / (N-1);
			}
			return M2 / n;
		}
		// Update the index for managing the circular buffer...
		i = (i+1) % W;

		// Fill up the initial window; else, update the existing window...
		if ( N < W ) {
			arr[ i ] = x;
			N += 1;
			delta = x - mu;
			mu += delta / N;
			M2 += delta * (x - mu);
			if ( N === 1 ) {
				return 0;
			}
			return M2 / (N-1);
		}
		if ( N === 1 ) {
			return 0;
		}
		tmp = arr[ i ];
		arr[ i ] = x;
		delta = x - tmp;
		d1 = tmp - mu;
		mu += delta / W;
		d2 = x - mu;
		M2 += delta * (d1 + d2);

		return M2 / n;
	};
} // end FUNCTION incrmvariance()


// EXPORTS //

module.exports = incrmvariance;

},{"validate.io-positive-integer":577}],577:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":578}],578:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":579}],579:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],580:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' );


// VARIABLES //

var MAXLENGTH = Math.pow( 2, 32 ) - 1;


// INCRSPACE //

/**
* FUNCTION: incrspace( start, stop[, increment] )
*	Generates a linearly spaced numeric array using a provided increment.
*
* @param {Number} start - first array value
* @param {Number} stop - array element bound
* @param {Number} [increment] - increment
* @returns {Array} linearly spaced numeric array
*/
function incrspace( x1, x2, increment ) {
	var arr,
		len,
		inc,
		i;
	if ( !isNumber( x1 ) ) {
		throw new TypeError( 'incrspace()::invalid input argument. Start must be numeric. Value: `' + x1 + '`.' );
	}
	if ( !isNumber( x2 ) ) {
		throw new TypeError( 'incrspace()::invalid input argument. Stop must be numeric. Value: `' + x2 + '`.' );
	}
	if ( arguments.length < 3 ) {
		inc = 1;
	} else {
		inc = increment;
		if ( !isNumber( inc ) ) {
			throw new TypeError( 'incrspace()::invalid input argument. Increment must be numeric. Value: `' + inc + '`.' );
		}
	}
	len = Math.ceil( ( x2-x1 ) / inc );

	if ( len > MAXLENGTH ) {
		throw new RangeError( 'incrspace()::invalid input arguments. Generated array exceeds maximum array length.' );
	}
	if ( len <= 1 ) {
		return [ x1 ];
	}
	if ( len > 64000 ) {
		// Ensure fast elements...
		arr = [];
		arr.push( x1 );
		for ( i = 1; i < len; i++ ) {
			arr.push( x1 + inc*i );
		}
	} else {
		arr = new Array( len );
		arr[ 0 ] = x1;
		for ( i = 1; i < len; i++ ) {
			arr[ i ] = x1 + inc*i;
		}
	}
	return arr;
} // end FUNCTION incrspace()


// EXPORTS //

module.exports = incrspace;

},{"validate.io-number-primitive":581}],581:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],582:[function(require,module,exports){
/**
*
*	COMPUTE: incrstdev
*
*
*	DESCRIPTION:
*		- Provides a method to compute a sample standard deviation incrementally.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// INCREMENTAL //

	/**
	* FUNCTION: incrstdev()
	*	Returns a method to compute the sample standard deviation incrementally.
	*
	* @returns {Function} method to compute the sample standard deviation incrementally
	*/
	function incrstdev() {
		var mu = 0,
			N = 0,
			M2 = 0,
			delta;
		/**
		* FUNCTION: incrstdev( [value] )
		*	If a `value` is provided, updates and returns the updated sample standard deviation. If no `value` is provided, returns the current sample standard deviation.
		*
		* @param {Number} [value] - value used to update the sample standard deviation
		* @returns {Number} sample standard deviation
		*/
		return function incrstdev( x ) {
			if ( !arguments.length ) {
				if ( N < 2 ) {
					return 0;
				}
				return Math.sqrt( M2 / (N-1) );
			}
			N += 1;
			delta = x - mu;
			mu += delta / N;
			M2 += delta * ( x - mu );
			if ( N < 2 ) {
				return 0;
			}
			return Math.sqrt( M2 / (N-1) );
		};
	} // end FUNCTION incrstdev()


	// EXPORTS //

	module.exports = incrstdev;

})();
},{}],583:[function(require,module,exports){
'use strict';

// INCREMENTAL SUM //

/**
* FUNCTION: incrsum()
*	Returns a method to compute the sum incrementally.
*
* @returns {Function} method to compute the sum incrementally
*/
function incrsum() {
	var sum = 0;
	/**
	* FUNCTION: incrsum( [value] )
	*	If a `value` is provided, updates and returns the updated sum. If no `value` is provided, returns the current sum.
	*
	* @param {Number} [value] - value used to update the sum
	* @returns {Number} sum
	*/
	return function incrsum( x ) {
		if ( !arguments.length ) {
			return sum;
		}
		sum += x;
		return sum;
	};
} // end FUNCTION incrsum()


// EXPORTS //

module.exports = incrsum;

},{}],584:[function(require,module,exports){
/**
*
*	COMPUTE: incrvariance
*
*
*	DESCRIPTION:
*		- Provides a method to compute a sample variance incrementally.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// INCREMENTAL SAMPLE VARIANCE //

	/**
	* FUNCTION: incrvariance()
	*	Returns a method to compute the sample variance incrementally.
	*
	* @returns {Function} method to compute the sample variance incrementally
	*/
	function incrvariance() {
		var mu = 0,
			N = 0,
			M2 = 0,
			delta;
		/**
		* FUNCTION: incrvariance( [value] )
		*	If a `value` is provided, updates and returns the updated sample variance. If no `value` is provided, returns the current sample variance.
		*
		* @param {Number} [value] - value used to update the sample variance
		* @returns {Number} sample variance
		*/
		return function incrvariance( x ) {
			if ( !arguments.length ) {
				if ( N < 2 ) {
					return 0;
				}
				return M2 / (N-1);
			}
			N += 1;
			delta = x - mu;
			mu += delta / N;
			M2 += delta * ( x - mu );
			if ( N < 2 ) {
				return 0;
			}
			return M2 / (N-1);
		};
	} // end FUNCTION incrvariance()


	// EXPORTS //

	module.exports = incrvariance;

})();
},{}],585:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":586,"validate.io-string-primitive":589}],586:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":587}],587:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":588}],588:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],589:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],590:[function(require,module,exports){
/**
*
*	COMPUTE: iqr
*
*
*	DESCRIPTION:
*		- Computes the interquartile range for an array of values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	quantile = require( 'compute-quantile' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// INTERQUARTILE RANGE //

/**
* FUNCTION: iqr( arr )
*	Computes the interquartile range for an array.
*
* @param {Array} arr - array of values
* @returns {Number} interquartile range
*/
function iqr( arr, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'iqr()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'iqr()::invalid input argument. Options should be an object.' );
		}
	} else {
		opts = {
			'sorted': false
		};
	}
	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
		opts.sorted = true;
	}
	return quantile( arr, 0.75, opts ) - quantile( arr, 0.25, opts );
} // end FUNCTION iqr()


// EXPORTS //

module.exports = iqr;

},{"compute-quantile":848,"validate.io-object":591}],591:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":592}],592:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],593:[function(require,module,exports){
/**
*
*	COMPUTE: isfinite
*
*
*	DESCRIPTION:
*		- Computes for each array element whether an element is a finite number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// VARIABLES //

var pinf = Number.POSITIVE_INFINITY,
	ninf = Number.NEGATIVE_INFINITY;


// ISFINITE //

/**
* FUNCTION: isfinite( arr )
*	Computes for each array element whether an element is a finite number.
*
* @param {Array} arr - input array
* @param {Array} array of 1s and 0s indicating if an element is a finite number
*/
function isfinite( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'isfinite()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		out = new Array( len ),
		val;

	for ( var i = 0; i < len; i++ ) {
		out[ i ] = 0;
		val = arr[ i ];
		if ( typeof val === 'number' && val === val && val < pinf && val > ninf ) {
			out[ i ] = 1;
		}
	}
	return out;
} // end FUNCTION isfinite()


// EXPORTS //

module.exports = isfinite;

},{}],594:[function(require,module,exports){
/**
*
*	COMPUTE: isinf
*
*
*	DESCRIPTION:
*		- Computes for each array element whether an element is infinite.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// VARIABLES //

var pinf = Number.POSITIVE_INFINITY,
	ninf = Number.NEGATIVE_INFINITY;


// ISINF //

/**
* FUNCTION: isinf( arr )
*	Computes for each array element whether an element is infinite.
*
* @param {Array} arr - input array
* @param {Array} array of 1s and 0s indicating if an element is infinite
*/
function isinf( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'isinf()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		out = new Array( len ),
		val;

	for ( var i = 0; i < len; i++ ) {
		out[ i ] = 0;
		val = arr[ i ];
		if ( val === pinf || val === ninf ) {
			out[ i ] = 1;
		}
	}
	return out;
} // end FUNCTION isinf()


// EXPORTS //

module.exports = isinf;

},{}],595:[function(require,module,exports){
/**
*
*	COMPUTE: isinteger
*
*
*	DESCRIPTION:
*		- Computes for each array element whether an element is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// ISINTEGER //

/**
* FUNCTION: isinteger( arr )
*	Computes for each array element whether an element is an integer.
*
* @param {Array} arr - input array
* @param {Array} array of 1s and 0s indicating if an element is an integer
*/
function isinteger( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'isinteger()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		out = new Array( len ),
		val;

	for ( var i = 0; i < len; i++ ) {
		out[ i ] = 0;
		val = arr[ i ];
		if ( typeof val === 'number' && val === val && val%1 === 0 ) {
			out[ i ] = 1;
		}
	}
	return out;
} // end FUNCTION isinteger()


// EXPORTS //

module.exports = isinteger;

},{}],596:[function(require,module,exports){
/**
*
*	COMPUTE: isnan
*
*
*	DESCRIPTION:
*		- Computes for each array element whether an element is NaN.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// ISNAN //

/**
* FUNCTION: isnan( arr )
*	Computes for each array element whether an element is NaN.
*
* @param {Array} arr - input array
* @param {Array} array of 1s and 0s indicating if an element is NaN
*/
function isnan( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'isnan()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		out = new Array( len ),
		val;

	for ( var i = 0; i < len; i++ ) {
		out[ i ] = 0;
		val = arr[ i ];
		if ( typeof val !== 'number' || val !== val ) {
			out[ i ] = 1;
		}
	}
	return out;
} // end FUNCTION isnan()


// EXPORTS //

module.exports = isnan;

},{}],597:[function(require,module,exports){
/**
*
*	COMPUTE: isnumeric
*
*
*	DESCRIPTION:
*		- Computes for each array element whether an element is numeric.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// ISNUMERIC //

/**
* FUNCTION: isnumeric( arr )
*	Computes for each array element whether an element is numeric.
*
* @param {Array} arr - input array
* @param {Array} array of 1s and 0s indicating if an element is numeric
*/
function isnumeric( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'isnumeric()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		out = new Array( len ),
		val;

	for ( var i = 0; i < len; i++ ) {
		out[ i ] = 0;
		val = arr[ i ];
		if ( typeof val === 'number' && val === val ) {
			out[ i ] = 1;
		}
	}
	return out;
} // end FUNCTION isnumeric()


// EXPORTS //

module.exports = isnumeric;

},{}],598:[function(require,module,exports){
/**
*
*	COMPUTE: issorted
*
*
*	DESCRIPTION:
*		- Returns a boolean indicating if an input array is sorted.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// ISSORTED //

/**
* FUNCTION: issorted( arr[, comparator] )
*	Returns a boolean indicating if an input array is sorted.
*
* @param {Array} arr - input array
* @param {Function} [comparator] - comparator function invoked for each pair of consecutive elements which returns a numeric value indicating if elements are ordered
* @returns {Boolean} boolean indicating if array is sorted
*/
function issorted( arr, clbk ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'issorted()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( typeof clbk !== 'function' ) {
			throw new TypeError( 'issorted()::invalid input argument. Comparator must be a function.' );
		}
	}
	var len = arr.length,
		i;
	if ( !clbk ) {
		// Default: ascending order...
		for ( i = 0; i < len-1; i++ ) {
			if ( arr[ i ] > arr[ i+1 ] ) {
				return false;
			}
		}
		return true;
	}
	// Impose arbitrary sort order...
	for ( i = 0; i < len-1; i++ ) {
		if ( clbk( arr[i], arr[i+1] ) > 0 ) {
			return false;
		}
	}
	return true;
} // end FUNCTION issorted()


// EXPORTS //

module.exports = issorted;

},{}],599:[function(require,module,exports){
/**
*
*	COMPUTE: kurtosis
*
*
*	DESCRIPTION:
*		- Computes the sample excess kurtosis of an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	/**
	* FUNCTION: kurtosis( arr )
	*	Computes the sample excess kurtosis of an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} sample excess kurtosis
	*/
	function kurtosis( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'kurtosis()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			delta = 0,
			delta_n = 0,
			delta_n2 = 0,
			term1 = 0,
			N = 0,
			mean = 0,
			M2 = 0,
			M3 = 0,
			M4 = 0,
			g;

		for ( var i = 0; i < len; i++ ) {
			N += 1;

			delta = arr[ i ] - mean;
			delta_n = delta / N;
			delta_n2 = delta_n * delta_n;

			term1 = delta * delta_n * (N-1);

			M4 += term1*delta_n2*(N*N - 3*N + 3) + 6*delta_n2*M2 - 4*delta_n*M3;
			M3 += term1*delta_n*(N-2) - 3*delta_n*M2;
			M2 += term1;
			mean += delta_n;
		}
		// Calculate the population excess kurtosis:
		g = N*M4 / ( M2*M2 ) - 3;
		// Return the corrected sample excess kurtosis:
		return (N-1) / ( (N-2)*(N-3) ) * ( (N+1)*g + 6 );
	} // end FUNCTION kurtosis()


	// EXPORTS //

	module.exports = kurtosis;

})();
},{}],600:[function(require,module,exports){
/**
*
*	COMPUTE: l1norm
*
*
*	DESCRIPTION:
*		- Computes the L1 norm (Manhattan norm) of an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// L1NORM //

	/**
	* FUNCTION: l1norm( arr )
	*	Calculates the L1 norm (Manhattan/Taxicab norm) of an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} L1 norm
	*/
	function l1norm( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'l1norm()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			sum = 0,
			val;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			// Math.abs( val )
			if ( val < 0 ) {
				val = -val;
			}
			sum += val;
		}
		return sum;
	} // end FUNCTION l1norm()


	// EXPORTS //

	module.exports = l1norm;

})();
},{}],601:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isFunction = require( 'validate.io-function' );


// L2NORM //

/**
* FUNCTION: l2norm( arr[, accessor] )
*	Calculates the L2 norm (Euclidean norm) of an array.
*
* @param {Array} arr - input array
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Number|Null} L2 norm or null
*/
function l2norm( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'l2norm()::invalid input argument. Must provide an array.  Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'l2norm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	var len = arr.length,
		t = 0,
		s = 1,
		r,
		val,
		abs,
		i;

	if ( !len ) {
		return null;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			val = clbk( arr[ i ], i );
			abs = ( val < 0 ) ? -val : val;
			if ( abs > 0 ) {
				if ( abs > t ) {
					r = t / val;
					s = 1 + s*r*r;
					t = abs;
				} else {
					r = val / t;
					s = s + r*r;
				}
			}
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			val = arr[ i ];
			abs = ( val < 0 ) ? -val : val;
			if ( abs > 0 ) {
				if ( abs > t ) {
					r = t / val;
					s = 1 + s*r*r;
					t = abs;
				} else {
					r = val / t;
					s = s + r*r;
				}
			}
		}
	}
	return t * Math.sqrt( s );
} // end FUNCTION l2norm()


// EXPORTS //

module.exports = l2norm;

},{"validate.io-array":602,"validate.io-function":603}],602:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],603:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],604:[function(require,module,exports){
'use strict';

// MODULES //

var gcd = require( 'compute-gcd' ),
	isArray = require( 'validate.io-array' ),
	isIntegerArray = require( 'validate.io-integer-array' ),
	isFunction = require( 'validate.io-function' );


// LEAST COMMON MULTIPLE //

/**
* FUNCTION: lcm( arr[, clbk] )
*	Computes the least common multiple (lcm).
*
* @param {Number[]|Number} arr - input array of integers
* @param {Function|Number} [accessor] - accessor function for accessing array values
* @returns {Number|Null} least common multiple or null
*/
function lcm() {
	var nargs = arguments.length,
		args,
		clbk,
		arr,
		len,
		a, b,
		i;

	// Copy the input arguments to an array...
	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}
	// Have we been provided with integer arguments?
	if ( isIntegerArray( args ) ) {
		if ( nargs === 2 ) {
			a = args[ 0 ];
			b = args[ 1 ];
			if ( a < 0 ) {
				a = -a;
			}
			if ( b < 0 ) {
				b = -b;
			}
			if ( a === 0 || b === 0 ) {
				return 0;
			}
			return ( a/gcd(a,b) ) * b;
		}
		arr = args;
	}
	// If not integers, ensure that the first argument is an array...
	else if ( !isArray( args[ 0 ] ) ) {
		throw new TypeError( 'lcm()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );
	}
	// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...
	else if ( nargs > 1 ) {
		arr = args[ 0 ];
		clbk = args[ 1 ];
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'lcm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	// We have been provided an array...
	else {
		arr = args[ 0 ];
	}
	len = arr.length;

	// Check if a sufficient number of values have been provided...
	if ( len < 2 ) {
		return null;
	}
	// If an accessor is provided, extract the array values...
	if ( clbk ) {
		a = new Array( len );
		for ( i = 0; i < len; i++ ) {
			a[ i ] = clbk( arr[ i ], i );
		}
		arr = a;
	}
	// Given an input array, ensure all array values are integers...
	if ( nargs < 3 ) {
		if ( !isIntegerArray( arr ) ) {
			throw new TypeError( 'lcm()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );
		}
	}
	// Convert any negative integers to positive integers...
	for ( i = 0; i < len; i++ ) {
		a = arr[ i ];
		if ( a < 0 ) {
			arr[ i ] = -a;
		}
	}
	// Exploit the fact that the lcm is an associative function...
	a = arr[ 0 ];
	for ( i = 1; i < len; i++ ) {
		b = arr[ i ];
		if ( a === 0 || b === 0 ) {
			return 0;
		}
		a = ( a/gcd(a,b) ) * b;
	}
	return a;
} // end FUNCTION lcm()


// EXPORTS //

module.exports = lcm;

},{"compute-gcd":525,"validate.io-array":605,"validate.io-function":606,"validate.io-integer-array":607}],605:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],606:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],607:[function(require,module,exports){
arguments[4][528][0].apply(exports,arguments)
},{"dup":528,"validate.io-array":605,"validate.io-integer":608}],608:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":609}],609:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],610:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isString = require( 'validate.io-string-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isObject = require( 'validate.io-object' );


// LESS THAN OR EQUAL TO //

/**
* FUNCTION: leq( arr, x[, opts] )
*	Computes an element-wise comparison (less than or equal to) of an array.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number|String} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} array of 1s and 0s, where a `1` indicates that an input array element is less than or equal to a compared value and `0` indicates that an input array element is not less than or equal to a compared value
*/
function leq( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'leq()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) && !isString( x ) ) {
		throw new TypeError( 'leq()::invalid input argument. Comparison input must either be an array, number primitive, or string primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'leq()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'leq()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'leq()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: comparison array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'leq()::invalid input argument. Comparison array must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i, 0 ) <= clbk( x[i], i, 1 ) ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i ) <= x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] <= x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
	}
	// Case 2: accessor and single comparator
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			if ( clbk( arr[ i ], i ) <= x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	// Case 3: single comparator
	else {
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] <= x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	return out;
} // end FUNCTION leq()


// EXPORTS //

module.exports = leq;


},{"validate.io-array":611,"validate.io-boolean-primitive":612,"validate.io-function":613,"validate.io-number-primitive":614,"validate.io-object":615,"validate.io-string-primitive":616}],611:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],612:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],613:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],614:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],615:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":611}],616:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],617:[function(require,module,exports){
/**
*
*	COMPUTE: linfnorm
*
*
*	DESCRIPTION:
*		- Computes the infinity norm (Chebyshev/supremum norm) of an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// LPNORM //

	/**
	* FUNCTION: linfnorm( arr )
	*	Calculates the infinity norm of an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} infinity norm
	*/
	function linfnorm( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'linfnorm()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			val = arr[ 0 ],
			max;

		if ( val < 0 ) {
			val = -val;
		}
		max = val;
		for ( var i = 1; i < len; i++ ) {
			val = arr[ i ];
			if ( val < 0 ) {
				val = -val;
			}
			if ( val > max ) {
				max = val;
			}
		}
		return max;
	} // end FUNCTION linfnorm()


	// EXPORTS //

	module.exports = linfnorm;

})();
},{}],618:[function(require,module,exports){
/**
*
*	COMPUTE: linspace
*
*
*	DESCRIPTION:
*		- Generates a linearly spaced numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// LINSPACE //

/**
* FUNCTION: linspace( start, stop[, length] )
*	Generates a linearly spaced numeric array.
*
* @param {Number} start - first array value
* @param {Number} stop - last array value
* @param {Number} [length] - length of output array
* @returns {Array} linearly spaced numeric array
*/
function linspace( x1, x2, len ) {
	var arr,
		end,
		tmp,
		d;

	if ( typeof x1 !== 'number' || x1 !== x1 ) {
		throw new TypeError( 'linspace()::invalid input argument. Start must be numeric.' );
	}
	if ( typeof x2 !== 'number' || x2 !== x2 ) {
		throw new TypeError( 'linspace()::invalid input argument. Stop must be numeric.' );
	}
	if ( arguments.length < 3 ) {
		len = 100;
	} else {
		if ( !isInteger( len ) || len < 0 ) {
			throw new TypeError( 'linspace()::invalid input argument. Length must be a positive integer.' );
		}
		if ( len === 0 ) {
			return [];
		}
	}
	// Calculate the increment:
	end = len - 1;
	d = ( x2-x1 ) / end;

	// Build the output array...
	arr = new Array( len );
	tmp = x1;
	arr[ 0 ] = tmp;
	for ( var i = 1; i < end; i++ ) {
		tmp += d;
		arr[ i ] = tmp;
	}
	arr[ end ] = x2;
	return arr;
} // end FUNCTION linspace()


// EXPORTS //

module.exports = linspace;

},{"validate.io-integer":619}],619:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":620}],620:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],621:[function(require,module,exports){
/**
*
*	COMPUTE: lmidmean
*
*
*	DESCRIPTION:
*		- Computes the interquartile mean of the values below the median for a numeric array (lower midmean).
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// LOWER MIDMEAN //

/**
* FUNCTION: lmidmean( arr[, sorted] )
*	Computes the interquartile mean of the values below the median in a numeric array (lower midmean).
*
* @param {Array} arr - numeric array
* @param {Boolean} [sorted] - boolean flag indicating if the input array is sorted in ascending order
* @returns {Number} lower midmean
*/
function lmidmean( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'lmidmean()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean' ) {
		throw new TypeError( 'lmidmean()::invalid input argument. Second argument must be a boolean.' );
	}
	if ( arr.length < 6 ) {
		throw new Error( 'lmidmean()::invalid input argument. Input array must have 6 or more elements.' );
	}
	if ( !sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}
	var len = arr.length,
		mean = 0,
		N = 0,
		delta,
		low,
		high;

	// Quartiles sit between values
	if ( len%8 === 0 ) {
		low = len*0.125;
		high = len*0.375 - 1;
	}
	else {
		low = Math.ceil( len*0.125 );
		high = Math.floor( len*0.375 ) - 1;
	}

	// Compute an arithmetic mean...
	for ( var i = low; i <= high; i++ ) {
		N += 1;
		delta = arr[ i ] - mean;
		mean += delta / N;
	}

	return mean;
} // end FUNCTION lmidmean()


// EXPORTS //

module.exports = lmidmean;

},{}],622:[function(require,module,exports){
/**
*
*	COMPUTE: logspace
*
*
*	DESCRIPTION:
*		- Generates a logarithmically spaced numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// LOGSPACE //

/**
* FUNCTION: logspace( a, b[, length] )
*	Generates a logarithmically spaced numeric array.
*
* @param {Number} a - exponent of start value
* @param {Number} b - exponent of end value
* @param {Number} [length] - length of output array (default: 10)
* @returns {Array} logarithmically spaced numeric array
*/
function logspace( a, b, len ) {
	var arr,
		end,
		tmp,
		d;

	if ( typeof a !== 'number' || a !== a ) {
		throw new TypeError( 'logspace()::invalid input argument. Exponent of start value must be numeric.' );
	}
	if ( typeof b !== 'number' || b !== b ) {
		throw new TypeError( 'logspace()::invalid input argument. Exponent of stop value must be numeric.' );
	}
	if ( arguments.length < 3 ) {
		len = 10;
	} else {
		if ( !isInteger( len ) || len < 0 ) {
			throw new TypeError( 'logspace()::invalid input argument. Length must be a positive integer.' );
		}
		if ( len === 0 ) {
			return [];
		}
	}
	// Calculate the increment:
	end = len - 1;
	d = ( b-a ) / end;

	// Build the output array...
	arr = new Array( len );
	tmp = a;
	arr[ 0 ] = Math.pow( 10, tmp );
	for ( var i = 1; i < end; i++ ) {
		tmp += d;
		arr[ i ] = Math.pow( 10, tmp );
	}
	arr[ end ] = Math.pow( 10, b );
	return arr;
} // end FUNCTION logspace()


// EXPORTS //

module.exports = logspace;

},{"validate.io-integer":623}],623:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":624}],624:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],625:[function(require,module,exports){
/**
*
*	COMPUTE: lpnorm
*
*
*	DESCRIPTION:
*		- Computes the Lp norm of an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// MODULES //

	var isInteger = require( 'validate.io-integer' ),
		l1norm = require( 'compute-l1norm' ),
		l2norm = require( 'compute-l2norm' ),
		linfnorm = require( 'compute-linfnorm' );


	// LPNORM //

	/**
	* FUNCTION: lpnorm( arr[, p] )
	*	Calculates the LP norm of an array of values.
	*
	* @param {Array} arr - array of values
	* @param {Number} [p] - norm
	* @returns {Number} LP norm
	*/
	function lpnorm( arr, p ) {
		var inf = Number.POSITIVE_INFINITY;
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'lpnorm()::invalid input argument. First argument must be an array.' );
		}
		if ( arguments.length === 1 ) {
			p = 2;
		} else if ( (!isInteger( p ) && p !== inf ) || p < 1 ) {
			throw new TypeError( 'lpnorm()::invalid input argument. Second argument should be a positive integer greater than 0.' );
		}
		if ( p === 1 ) {
			return l1norm( arr );
		}
		else if ( p === 2 ) {
			return l2norm( arr );
		}
		else if ( p === inf ) {
			return linfnorm( arr );
		}
		var len = arr.length,
			sum = 0,
			val;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( val < 0 ) {
				val = -val;
			}
			sum += Math.pow( val, p );
		}
		return Math.pow( sum, 1/p );
	} // end FUNCTION lpnorm()


	// EXPORTS //

	module.exports = lpnorm;

})();
},{"compute-l1norm":600,"compute-l2norm":601,"compute-linfnorm":617,"validate.io-integer":626}],626:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":627}],627:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],628:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isString = require( 'validate.io-string-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isObject = require( 'validate.io-object' );


// LESS THAN //

/**
* FUNCTION: lt( arr, x[, opts] )
*	Computes an element-wise comparison (less than) of an array.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number|String} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} array of 1s and 0s, where a `1` indicates that an input array element is less than a compared value and `0` indicates that an input array element is not less than a compared value
*/
function lt( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'lt()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) && !isString( x ) ) {
		throw new TypeError( 'lt()::invalid input argument. Comparison input must either be an array, number primitive, or string primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'lt()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'lt()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'lt()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: comparison array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'lt()::invalid input argument. Comparison array must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i, 0 ) < clbk( x[i], i, 1 ) ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				if ( clbk( arr[i], i ) < x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] < x[ i ] ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
		}
	}
	// Case 2: accessor and single comparator
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			if ( clbk( arr[ i ], i ) < x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	// Case 3: single comparator
	else {
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] < x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
	}
	return out;
} // end FUNCTION lt()


// EXPORTS //

module.exports = lt;

},{"validate.io-array":629,"validate.io-boolean-primitive":630,"validate.io-function":631,"validate.io-number-primitive":632,"validate.io-object":633,"validate.io-string-primitive":634}],629:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],630:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],631:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],632:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],633:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":629}],634:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],635:[function(require,module,exports){
/**
*
*	COMPUTE: max
*
*
*	DESCRIPTION:
*		- Computes the maximum value of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: max( arr )
*	Computes the maximum value of a numeric array.
*
* @param {Array} arr - array of values
* @returns {Number} max value
*/
function max( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'max()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		val = arr[ 0 ];

	for ( var i = 1; i < len; i++ ) {
		if ( arr[ i ] > val ) {
			val = arr[ i ];
		}
	}
	return val;
} // end FUNCTION max()


// EXPORTS //

module.exports = max;

},{}],636:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mean( arr, clbk )
*	Computes the arithmetic mean of an array using an accessor function.
*
* @param {Array} arr - input array
* @param {Function} clbk - accessor function for accessing array values
* @returns {Number|Null} arithmetic mean or null
*/
function mean( arr, clbk ) {
	var len = arr.length,
		delta,
		mu,
		i;

	if ( !len ) {
		return null;
	}
	mu = 0;
	for ( i = 0; i < len; i++ ) {
		delta = clbk( arr[ i ], i ) - mu;
		mu += delta / (i+1);
	}
	return mu;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{}],637:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mean( arr )
*	Computes the arithmetic mean of a numeric array.
*
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number|Null} arithmetic mean or null
*/
function mean( arr ) {
	var len = arr.length,
		delta,
		mu,
		i;

	if ( !len ) {
		return null;
	}
	mu = 0;
	for ( i = 0; i < len; i++ ) {
		delta = arr[ i ] - mu;
		mu += delta / (i+1);
	}
	return mu;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{}],638:[function(require,module,exports){
'use strict';

// MODULES //

var isArrayLike = require( 'validate.io-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ).raw,
	validate = require( './validate.js' );


// FUNCTIONS //

var mean1 = require( './array.js' ),
	mean2 = require( './accessor.js' ),
	mean3 = require( './matrix.js' );


// MEAN //

/**
* FUNCTION: mean( x[, opts] )
*	Computes the arithmetic mean.
*
* @param {Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {Number} [opts.dim=2] - dimension along which to compute the arithmetic mean.
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Matrix|Null} mean value(s) or null
*/
function mean( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		shape,
		ctor,
		err,
		len,
		dim,
		dt,
		d,
		m;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		dt = opts.dtype || 'float64';
		dim = opts.dim;

		// Determine if provided a vector...
		if ( x.shape[ 0 ] === 1 || x.shape[ 1 ] === 1 ) {
			// Treat as an array-like object:
			return mean1( x.data );
		}
		if ( dim > 2 ) {
			throw new RangeError( 'mean()::invalid option. Dimension option exceeds number of matrix dimensions. Option: `' + dim + '`.' );
		}
		if ( dim === void 0 || dim === 2 ) {
			len = x.shape[ 0 ];
			shape = [ len, 1 ];
		} else {
			len = x.shape[ 1 ];
			shape = [ 1, len ];
		}
		ctor = ctors( dt );
		if ( ctor === null ) {
			throw new Error( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
		}
		// Create an output matrix and calculate the means:
		d = new ctor( len );
		m = matrix( d, shape, dt );
		return mean3( m, x, dim );
	}
	if ( isArrayLike( x ) ) {
		if ( opts.accessor ) {
			return mean2( x, opts.accessor );
		}
		return mean1( x );
	}
	throw new TypeError( 'mean()::invalid input argument. First argument must be either an array or a matrix. Value: `' + x + '`.' );
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./accessor.js":636,"./array.js":637,"./matrix.js":639,"./validate.js":640,"compute-array-constructors":642,"dstructs-matrix":651,"validate.io-array-like":689,"validate.io-matrix-like":694}],639:[function(require,module,exports){
'use strict';

/**
* FUNCTION: mean( out, mat[, dim] )
*	Computes the arithmetic mean along a matrix dimension.
*
* @param {Matrix} out - output matrix
* @param {Matrix} mat - input matrix
* @param {Number} [dim=2] - matrix dimension along which to compute an arithmetic mean. If `dim=1`, compute along matrix rows. If `dim=2`, compute along matrix columns.
* @returns {Matrix|Null} arithmetic means or null
*/
function mean( out, mat, dim ) {
	var delta,
		mu,
		M, N,
		s0, s1,
		o,
		i, j, k;

	if ( dim === 1 ) {
		// Compute along the rows...
		M = mat.shape[ 1 ];
		N = mat.shape[ 0 ];
		s0 = mat.strides[ 1 ];
		s1 = mat.strides[ 0 ];
	} else {
		// Compute along the columns...
		M = mat.shape[ 0 ];
		N = mat.shape[ 1 ];
		s0 = mat.strides[ 0 ];
		s1 = mat.strides[ 1 ];
	}
	if ( M === 0 || N === 0 ) {
		return null;
	}
	o = mat.offset;
	for ( i = 0; i < M; i++ ) {
		k = o + i*s0;
		mu = 0;
		for ( j = 0; j < N; j++ ) {
			delta = mat.data[ k + j*s1 ] - mu;
			mu += delta / (j+1);
		}
		out.data[ i ] = mu;
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{}],640:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim] - dimension
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'mean()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'mean()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dim' ) ) {
		opts.dim = options.dim;
		if ( !isPositiveInteger( opts.dim ) ) {
			return new TypeError( 'mean()::invalid option. Dimension option must be a positive integer. Option: `' + opts.dim + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'mean()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-function":693,"validate.io-object":695,"validate.io-positive-integer":697,"validate.io-string-primitive":700}],641:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],642:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":641,"dup":63}],643:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],644:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":647,"./iget.js":649,"./iset.js":652,"./mget.js":656,"./mset.js":658,"./set.js":666,"./sget.js":668,"./sset.js":670,"./toString.js":672,"dup":2}],645:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":648,"./iget.raw.js":650,"./iset.raw.js":653,"./mget.raw.js":657,"./mset.raw.js":659,"./set.raw.js":667,"./sget.raw.js":669,"./sset.raw.js":671,"./toString.js":672,"dup":3}],646:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],647:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":685}],648:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],649:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":683}],650:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],651:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":654,"./matrix.raw.js":655,"dup":9}],652:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":683,"validate.io-number-primitive":688}],653:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],654:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":643,"./ctor.js":644,"./dtypes.js":646,"compute-cast-arrays":673,"compute-dtype":676,"dup":12,"validate.io-array":680,"validate.io-contains":681,"validate.io-nonnegative-integer-array":684,"validate.io-string-primitive":700}],655:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":643,"./ctor.raw.js":645,"./dtypes.js":646,"compute-dtype":676,"dup":13,"validate.io-contains":681,"validate.io-string-primitive":700}],656:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":643,"dup":14,"validate.io-nonnegative-integer-array":684}],657:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":643,"dup":15}],658:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":660,"./mset2.js":661,"./mset3.js":662,"./mset4.js":663,"./mset5.js":664,"./mset6.js":665,"dup":16,"validate.io-function":693,"validate.io-nonnegative-integer-array":684,"validate.io-number-primitive":688}],659:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":660,"./mset2.js":661,"./mset3.js":662,"./mset4.js":663,"./mset5.js":664,"./mset6.js":665,"dup":17}],660:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],661:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],662:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],663:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],664:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],665:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],666:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":685,"validate.io-number-primitive":688}],667:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],668:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":643,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":700}],669:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":643,"compute-indexspace":585,"dup":27}],670:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":693,"validate.io-number-primitive":688,"validate.io-string-primitive":700}],671:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],672:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],673:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":641,"compute-array-dtype/lib/dtypes":674,"dup":31,"type-name":675,"validate.io-array-like":689}],674:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],675:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],676:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":678,"dup":36,"type-name":679}],677:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],678:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":677,"dup":38}],679:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],680:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],681:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":680,"validate.io-nan-primitive":682}],682:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],683:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":688}],684:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":680,"validate.io-nonnegative-integer":685}],685:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":686}],686:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":687}],687:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],688:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],689:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":690,"dup":34,"validate.io-integer-primitive":691}],690:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],691:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":692}],692:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],693:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],694:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],695:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":696}],696:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],697:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":698}],698:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":699}],699:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],700:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],701:[function(require,module,exports){
/**
*
*	COMPUTE: median
*
*
*	DESCRIPTION:
*		- Computes the median of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean' ),
	isFunction = require( 'validate.io-function' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MEDIAN //

/**
* FUNCTION: median( arr[, options] )
*	Computes the median of an array.
*
* @param {Array} arr - input array
* @param {Object} [options] - function options
* @param {Boolean} [options.sorted] - boolean flag indicating if the array is sorted in ascending order
* @param {Function} [options.accessor] - accessor function for accessing array values
* @returns {Number|null} median value or null
*/
function median( arr, options ) {
	var sorted,
		clbk,
		len,
		id,
		d, i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'median()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( options) ) {
			throw new TypeError( 'median()::invalid input argument. Options must be an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'sorted' ) ) {
			sorted = options.sorted;
			if ( !isBoolean( sorted ) ) {
				throw new TypeError( 'median()::invalid option. Sorted flag must be a boolean. Option: `' + sorted + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'accessor' ) ) {
			clbk = options.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'median()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
		}
	}
	len = arr.length;
	if ( !len ) {
		return null;
	}
	if ( !clbk && sorted ) {
		d = arr;
	}
	else if ( !clbk ) {
		d = [];
		for ( i = 0; i < len; i++ ) {
			d.push( arr[ i ] );
		}
	}
	else {
		d = [];
		for ( i = 0; i < len; i++ ) {
			d.push( clbk( arr[ i ] ) );
		}
	}
	if ( !sorted ) {
		d.sort( ascending );
	}
	// Get the middle index:
	id = Math.floor( len / 2 );

	if ( len % 2 ) {
		// The number of elements is not evenly divisible by two, hence we have a middle index:
		return d[ id ];
	}
	// Even number of elements, so must take the mean of the two middle values:
	return ( d[ id-1 ] + d[ id ] ) / 2.0;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"validate.io-array":702,"validate.io-boolean":703,"validate.io-function":704,"validate.io-object":705}],702:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],703:[function(require,module,exports){
/**
*
*	VALIDATE: boolean
*
*
*	DESCRIPTION:
*		- Validates if a value is a boolean.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isBoolean( value )
*	Validates if a value is a boolean.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a boolean
*/
function isBoolean( value ) {
	return ( typeof value === 'boolean' || Object.prototype.toString.call( value ) === '[object Boolean]' );
} // end FUNCTION isBoolean()


// EXPORTS //

module.exports = isBoolean;
},{}],704:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],705:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":702}],706:[function(require,module,exports){
/**
*
*	COMPUTE: midhinge
*
*
*	DESCRIPTION:
*		- Computes the midhinge of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	quantile = require( 'compute-quantile' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MIDHINGE //

/**
* FUNCTION: midhinge( arr[, opts] )
*	Computes the midhinge of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Object} [opts] - quantile options
* @returns {Number} midhinge
*/
function midhinge( arr, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'midhinge()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'midhinge()::invalid input argument. Options should be an object.' );
		}
	} else {
		opts = {
			'sorted': false
		};
	}
	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
		opts.sorted = true;
	}
	return ( quantile( arr, 0.25, opts ) + quantile( arr, 0.75, opts ) ) / 2.0;
} // end FUNCTION midhinge()


// EXPORTS //

module.exports = midhinge;

},{"compute-quantile":848,"validate.io-object":707}],707:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":708}],708:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],709:[function(require,module,exports){
/**
*
*	COMPUTE: midmean
*
*
*	DESCRIPTION:
*		- Computes the interquartile mean (midmean) of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MIDMEAN //

/**
* FUNCTION: midmean( arr[, sorted] )
*	Computes the interquartile mean (midmean) of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Boolean} [sorted] - boolean flag indicating if the input array is sorted in ascending order
* @returns {Number} midmean
*/
function midmean( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'midmean()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean' ) {
		throw new TypeError( 'midmean()::invalid input argument. Second argument must be a boolean.' );
	}
	if ( arr.length < 3 ) {
		throw new TypeError( 'midmean()::invalid input argument. Midmean not applicable.' );
	}
	if ( !sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}
	var len = arr.length,
		mean = 0,
		N = 0,
		delta,
		low,
		high;

	// Quartiles sit between values...
	if ( len%4 === 0 ) {
		low = len*0.25;
		high = len*0.75 - 1;
	}
	else {
		low = Math.ceil( len*0.25 );
		high = Math.floor( len*0.75 ) - 1;
	}

	// Compute an arithmetic mean...
	for ( var i = low; i <= high; i++ ) {
		N += 1;
		delta = arr[ i ] - mean;
		mean += delta / N;
	}
	return mean;
} // end FUNCTION midmean()


// EXPORTS //

module.exports = midmean;

},{}],710:[function(require,module,exports){
/**
*
*	COMPUTE: midrange
*
*
*	DESCRIPTION:
*		- Computes the midrange of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MIDRANGE //

/**
* FUNCTION: midrange( arr[, sorted] )
*	Computes the midrange of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Boolean} [sorted] - boolean flag indicating if the input array is already sorted in ascending order
* @returns {Number} midrange
*/
function midrange( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'midrange()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean') {
		throw new TypeError( 'midrange()::invalid input argument. Sorted flag should be a boolean.' );
	}
	var len = arr.length,
		val,
		min,
		max;

	if ( sorted ) {
		min = arr[ 0 ];
		max = arr[ len - 1 ];
	} else {
		// Find min and max values in the range...
		min = arr[ 0 ];
		max = arr[ 0 ];
		for ( var i = 1; i < len; i++) {
			val = arr[ i ];
			if ( val > max ) {
				max = val;
			}
			else if ( val < min ) {
				min = val;
			}
		}
	}
	return ( min + max ) / 2.0;
} // end FUNCTION midrange()


// EXPORTS //

module.exports = midrange;


},{}],711:[function(require,module,exports){
/**
*
*	COMPUTE: midsummary
*
*
*	DESCRIPTION:
*		- Computes a trimmed midrange of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	quantile = require( 'compute-quantile' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MIDSUMMARY //

/**
* FUNCTION: midsummary( arr, n[, opts] )
*	Computes the midsummary of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Number} n - % value between 0 and 0.50 by which to trim the data set
* @param {Object} [opts] - quantile options
* @returns {Number} midsummary
*/
function midsummary( arr, n, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'midsummary()::invalid input argument. Must provide an array.' );
	}
	if ( typeof n !== 'number' || n !== n ) {
		throw new TypeError( 'midsummary()::invalid input argument. Percentage must be numeric.' );
	}
	if ( n < 0.0 || n > 0.50 ) {
		throw new TypeError( 'midsummary()::invalid input argument. Must provide a percentage between 0 and 0.5 inclusive.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'midsummary()::invalid input argument. Options should be an object.' );
		}
	} else {
		opts = {
			'sorted': false
		};
	}
	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
		opts.sorted = true;
	}
	var len = arr.length,
		el = 0;

	if ( n === 0 ) {
		// special case: midrange
		return ( arr[0] + arr[len-1] ) / 2.0;
	}
	else if ( n === 0.5 ) {
		// special case: median
		el = Math.floor( len / 2.0 );
 		if ( len % 2.0 ) {
 			// Middle index exists
 			return arr[ el ];
 		}
 		else {
 			return ( arr[ el ] + arr[ el-1 ] ) / 2.0;
 		}
	}	
	else {
		return ( quantile( arr, n, opts ) + quantile( arr, 1 - n, opts ) ) / 2.0;
	}
} // end FUNCTION midsummary()


// EXPORTS //

module.exports = midsummary;

},{"compute-quantile":848,"validate.io-object":712}],712:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":713}],713:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],714:[function(require,module,exports){
/**
*
*	COMPUTE: min
*
*
*	DESCRIPTION:
*		- Computes the minimum value of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: min( arr )
*	Computes the minimum value of an array.
*
* @param {Array} arr - array of values
* @returns {Number} min value
*/
function min( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'min()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		val = arr[ 0 ];

	for ( var i = 1; i < len; i++ ) {
		if ( arr[ i ] < val ) {
			val = arr[ i ];
		}
	}
	return val;
} // end FUNCTION min()


// EXPORTS //

module.exports = min;

},{}],715:[function(require,module,exports){
/**
*
*	COMPUTE: mmax
*
*
*	DESCRIPTION:
*		- Computes a moving maximum over a numeric array.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

(function() {
	'use strict';

    /**
	* FUNCTION: mmax( arr , window )
	*	Computes a moving maximum over a numeric array.
	*
	* @param {Array} arr - array of data values
	* @param {Number} window - size of moving window
	* @returns {Array} array of maximum values
	*/
	function mmax( arr , W ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'mmax()::invalid input argument. Must provide an array.' );
		}
		if ( typeof W !== 'number' || W !== W ) {
            throw new TypeError( 'mmax()::invalid input argument. Window must be numeric.' );
        }
        if ( Math.floor( W ) !== W || W < 1 ) {
            throw new TypeError( 'mmax()::invalid input argument. Window must be a positive integer.' );
        }
		if ( W > arr.length ) {
			throw new TypeError( 'mmax()::invalid input argument. Window cannot exceed array length.' );
		}
		var len = arr.length,
			out = new Array( len-W+1 ),
			max = arr[ 0 ],
			val,
			i, j, k, n;

		// Compute the maximum value for the first window...
		for ( i = 1; i < W; i++ ) {
			val = arr[ i ];
			if ( val > max ) {
				max = val;
			}
		}
		out[ 0 ] = max;

		// Compute the remaining window maximums...
		for ( j = W; j < len; j++ ) {
			val = arr[ j ];
			k = j - W;

			// Cases:
			// [1] Incoming value is greater than current maximum. New maximum value.
			// [2] Outgoing value is the current maximum and the new value is less than the maximum. Find a new maximum among the current values.
			// [3] Maximum does not change. Move along.
			
			if ( val > max ) {
				max = val;
			}
			else if ( arr[ k ] === max && val < max ) {
				max = arr[ k+1 ];
				for ( n = k+2; n <= j; n++ ) {
					val = arr[ n ];
					if ( val > max ) {
						max = val;
					}
				}
			}
			out[ k+1 ] = max;
		}
		return out;
	} // end FUNCTION mmax()


	// EXPORTS //

	module.exports = mmax;

})();
},{}],716:[function(require,module,exports){
/**
*
*	COMPUTE: mmean
*
*
*	DESCRIPTION:
*		- Compute a moving mean (sliding window average) over an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' ),
	isFunction = require( 'validate.io-function' );


// MOVING MEAN //

/**
* FUNCTION: mmean( arr, W[, options] )
*	Computes a moving mean over an array.
*
* @param {Array} arr - input array
* @param {Number} W - size of moving window
* @param {Object} [options] - function options
* @param {Function} [options.accessor] - accessor function for accessing numeric values
* @param {Boolean} [options.copy=true] - boolean indicating whether to return a new array of window means
* @returns {Array} array of window mean values
*/
function mmean( arr , W, options ) {
	var copy = true,
		clbk;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'mmean()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isPositiveInteger( W ) ) {
    	throw new TypeError( 'mmean()::invalid input argument. Window must be a positive integer. Value: `' + W + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'mmean()::invalid input argument. Options must be an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'accessor' ) ) {
			clbk = options.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'mmean()::invalid option. Accessor option must be a function. Value: `' + clbk + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'copy' ) ) {
			copy = options.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'mmean()::invalid option. Copy option must be a boolean primitive. Value: `' + copy + '`.' );
			}
		}
	}
	if ( W > arr.length ) {
		throw new Error( 'mmean()::invalid input argument. Window cannot exceed the array length.' );
	}

	var len = arr.length,
		delta = 0,
		mu = 0,
		dropVal = 0,
		out;

	if ( copy && !clbk ) {
		// Case 1: numeric array and return a copy...
		len = len - W + 1;
		out = new Array( len );

		// Calculate the mean for the first window...
		for ( var i = 0; i < W; i++ ) {
			delta = arr[ i ] - mu;
			mu += delta / (i+1);
		}
		out[ 0 ] = mu;

		// Calculate means for the remaining windows...
		for ( var j = 0; j < len-1; j++ ) {
			delta = arr[ j+W ] - arr[ j ];
			mu += delta / W;
			out[ j+1 ] = mu;
		}
		return out;
	} 
	else if ( clbk ) {
		if ( copy ) {
			// Case 2: non-numeric array and return a copy...
			out = new Array( len );
			for ( var i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i] );
			}
		} else {
			// Case 3: non-numeric array and mutate the input array...
			out = arr;
			for ( var i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i] );
			}
		}
	} 
	else {
		// Case 4: numeric array and mutate the input array...
		out = arr;
	}

	len = len - W + 1;

	// Calculate the mean for the first window...
	for ( var i = 0; i < W; i++ ) {
		delta = out[ i ] - mu;
		mu += delta / (i+1);
	}
	dropVal = out[ 0 ];
	out[ 0 ] = mu;

	// Calculate means for the remaining windows...
	for ( var j = 1; j < len; j++ ) {
		delta = out[ j+W-1 ] - dropVal;
		mu += delta / W;
		dropVal = out[ j ];
		out[ j ] = mu;
	}

	// Trim the output array:
	out.length = len;
	return out;
	
} // end FUNCTION mmean()

// EXPORTS //

module.exports = mmean;

},{"validate.io-array":717,"validate.io-boolean-primitive":718,"validate.io-function":719,"validate.io-object":720,"validate.io-positive-integer":721}],717:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],718:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],719:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],720:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":717}],721:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":722}],722:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":723}],723:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],724:[function(require,module,exports){
/**
*
*	COMPUTE: mmin
*
*
*	DESCRIPTION:
*		- Computes a moving minimum over a numeric array.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// MOVING MIN //

    /**
	* FUNCTION: mmin( arr , window )
	*	Computes a moving minimum over a numeric array.
	*
	* @param {Array} arr - array of data values
	* @param {Number} window - size of moving window
	* @returns {Array} array of minimum values
	*/
	function mmin( arr , W ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'mmin()::invalid input argument. Must provide an array.' );
		}
		if ( typeof W !== 'number' || W !== W ) {
            throw new TypeError( 'mmin()::invalid input argument. Window must be numeric.' );
        }
        if ( Math.floor( W ) !== W || W < 1 ) {
            throw new TypeError( 'mmin()::invalid input argument. Window must be a positive integer.' );
        }
		if ( W > arr.length ) {
			throw new TypeError( 'mmin()::invalid input argument. Window cannot exceed array length.' );
		}
		var len = arr.length,
			out = new Array( len - W + 1 ),
			min = arr[ 0 ],
			val,
			i, j, k, n;

		// Compute the minimum for the first window...
		for ( i = 1; i < W; i++ ) {
			val = arr[ i ];
			if ( val < min ) {
				min = val;
			}
		}
		out[ 0 ] = min;

		// Compute the remaining window minimums..
		for ( j = W; j < len; j++ ) {
			val = arr[ j ];
			k = j - W;
			
			// Cases:
			// [1] Incoming value is less than current minimum. New minimum value.
			// [2] Outgoing value is the current minimum and the new value is greater than the minimum. Find a new minimum among the current values.
			// [3] Minimum does not change. Move along.

			if ( val < min ) {
				min = val;
			}
			else if ( arr[ k ] === min && val > min ) {
				min = arr[ k+1 ];
				for ( n = k+2; n <= j; n++ ) {
					val = arr[ n ];
					if ( val < min ) {
						min = val;
					}
				}
			}
			out[ k+1 ] = min;
		}
		return out;
	} // end FUNCTION mmin()


	// EXPORTS //

	module.exports = mmin;

})();
},{}],725:[function(require,module,exports){
/**
*
*	COMPUTE: mode
*
*
*	DESCRIPTION:
*		- Computes the mode of an array.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	/**
	* FUNCTION: mode( arr )
	*	Computes the mode of an array.
	*
	* @param {Array} arr - array of values
	* @returns {Array} mode
	*/
	function mode( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'mode()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			count = {},
			max = 0,
			vals = [],
			val;

		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( !count[ val ] ) {
				count[ val ] = 0;
			}
			count[ val ] += 1;
			if ( count[ val ] === max ) {
				vals.push( val );
			} else {
				max = count[ val ];
				vals = [ val ];
			}
		}
		return vals.sort( function sort( a, b ) {
			return a - b;
		});
	} // end FUNCTION mode()


	// EXPORTS //

	module.exports = mode;

})();
},{}],726:[function(require,module,exports){
/**
*
*	COMPUTE: mprod
*
*
*	DESCRIPTION:
*		- Computes a moving product over an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// MOVING PRODUCT //

/**
* FUNCTION: mprod( arr, window[, accessor] )
*	Computes a moving product over an array.
*
* @param {Array} arr - array of values
* @param {Number} window - size of moving window
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Array} array of window products
*/
function mprod( arr, W, clbk ) {
	var len,
		out,
		val,
		p,
		i, j;
	if ( !isArray( arr ) ) {
		throw new TypeError( 'mprod()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	len = arr.length;
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'mprod()::invalid input argument. Window must be a positive integer. Value: `' + W + '`.' );
	}
	if ( W > len ) {
		throw new Error( 'mprod()::invalid input argument. Window cannot exceed the array length.' );
	}
	if ( arguments.length > 2 ) {
		if ( typeof clbk !== 'function' ) {
			throw new TypeError( 'mprod()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	len = len - W + 1;
	out = new Array( len );

	// NOTE: unlike sum, mean, and other moving calculations, a simple in-place update procedure is hard to come by. Instead, the straightforward solution of two FOR loops is used. While possibly not optimal, this solution requires fewer conditionals and is arguably easier to maintain.
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			p = 1;
			for ( j = i; j < i+W; j++ ) {
				val = clbk( arr[ j ] );
				if ( val === 0 ) {
					p = 0;
					break;
				}
				p *= val;
			}
			out[ i ] = p;
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			p = 1;
			for ( j = i; j < i+W; j++ ) {
				val = arr[ j ];
				if ( val === 0 ) {
					p = 0;
					break;
				}
				p *= val;
			}
			out[ i ] = p;
		}
	}
	return out;
} // end FUNCTION mprod()


// EXPORTS //

module.exports = mprod;

},{"validate.io-array":727,"validate.io-positive-integer":728}],727:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],728:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":729}],729:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":730}],730:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],731:[function(require,module,exports){
/**
*
*	COMPUTE: mstdev
*
*
*	DESCRIPTION:
*		- Computes a moving sample standard deviation over a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MOVING SAMPLE STANDARD DEVIATION //

/**
* FUNCTION: mstdev( arr, window )
*	Computes a moving sample standard deviation over a numeric array.
*
* @param {Array} arr - array of data values
* @param {Number} window - size of moving window
* @returns {Array} array of sample standard deviation values
*/
function mstdev( arr, W ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'mstdev()::invalid input argument. Must provide an array.' );
	}
	if ( typeof W !== 'number' || W !== W ) {
        throw new TypeError( 'mstdev()::invalid input argument. Window must be numeric.' );
    }
    if ( (W%1) !== 0 || W < 1 ) {
        throw new TypeError( 'mstdev()::invalid input argument. Window must be a positive integer.' );
    }
	if ( W > arr.length ) {
		throw new TypeError( 'mstdev()::invalid input argument. Window cannot exceed the array length.' );
	}
	var len = arr.length,
		out = new Array( len-W+1 ),
		n = W - 1,
		mu = 0,
		M2 = 0,
		delta,
		x1,
		x2,
		d1,
		d2,
		i, j;

	if ( W === 1 ) {
		for ( i = 0; i < out.length; i++ ) {
			out[ i ] = 0;
		}
		return out;
	}

	// Compute the sample standard deviation for the first window...
	for ( i = 0; i < W; i++ ) {
		x1 = arr[ i ];
		delta = x1 - mu;
		mu += delta / (i+1);
		M2 += delta * (x1 - mu);
	}
	out[ 0 ] = Math.sqrt( M2 / n );

	// Compute the remaining sample standard deviations...
	for ( j = W; j < len; j++ ) {
		i = j - W;
		x1 = arr[ i ];
		x2 = arr[ j ];
		delta = x2 - x1;
		d1 = x1 - mu;
		mu += delta / W;
		d2 = x2 - mu;
		M2 += delta * (d1+d2);
		out[ i+1 ] = Math.sqrt( M2 / n );
	}
	return out;
} // end FUNCTION mstdev()


// EXPORTS //

module.exports = mstdev;

},{}],732:[function(require,module,exports){
/**
*
*	COMPUTE: msum
*
*
*	DESCRIPTION:
*		- Compute a moving sum over an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' ),
	isFunction = require( 'validate.io-function' );


// MOVING SUM //

/**
* FUNCTION: msum( arr, W[, options] )
*	Computes a moving sum over an array.
*
* @param {Array} arr - input array
* @param {Number} W - size of moving window
* @param {Object} [options] - function options
* @param {Function} [options.accessor] - accessor function for accessing numeric values
* @param {Boolean} [options.copy=true] - boolean indicating whether to return a new array of window sums
* @returns {Array} array of window sum values
*/
function msum( arr, W, options ) {
	var copy = true,
		clbk,
		len,
		sum,
		dropVal,
		out,
		i;
	if ( !isArray( arr ) ) {
		throw new TypeError( 'msum()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isPositiveInteger( W ) ) {
        throw new TypeError( 'msum()::invalid input argument. Window must be a positive integer. Value: `' + W + '`.' );
    }
	if ( arguments.length > 2 ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'msum()::invalid input argument. Options must be an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'accessor' ) ) {
			clbk = options.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'msum()::invalid option. Accessor option must be a function. Value: `' + clbk + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'copy' ) ) {
			copy = options.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'msum()::invalid option. Copy option must be a boolean primitive. Value: `' + copy + '`.' );
			}
		}
	}
	if ( W > arr.length ) {
		throw new Error( 'msum()::invalid input argument. Window cannot exceed the array length.' );
	}
	len = arr.length;
	sum = 0;

	if ( copy && !clbk ) {
		// Case 1: numeric array and return a copy...
		len = len - W + 1;
		out = new Array( len );

		// Calculate the sum for the first window...
		for ( i = 0; i < W; i++ ) {
			sum += arr[ i ];
		}
		out[ 0 ] = sum;

		// Calculate sums for the remaining windows...
		for ( i = 0; i < len-1; i++ ){
			sum += arr[ i+W ] - arr[ i ];
			out[ i+1 ] = sum;
		}
		return out;
	}
	else if ( clbk ) {
		if ( copy ) {
			// Case 2: non-numeric array and return a copy...
			out = new Array( len );
			for ( i = 0; i < len; i++ ){
				out[ i ] = clbk( arr[i] );
			}
		} else {
			// Case 3: non-numeric array and mutate the input array...
			out = arr;
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i] );
			}
		}
	}
	else {
		// Case 4: numeric array and mutate the input array...
		out = arr;
	}
	len = len - W + 1;

	// Calculate the sum for the first window...
	for ( i = 0; i < W; i++ ) {
		sum += out[ i ];
	}
	dropVal = out[ 0 ];
	out[ 0 ] = sum;

	// Calculate sums for the remaining windows...
	for ( i = 1; i < len; i++ ){
		sum += out[ i+W-1 ] - dropVal;
		dropVal = out[ i ];
		out[ i ] = sum;
	}
	// Trim the output array:
	out.length = len;
	return out;
} // end FUNCTION msum()


// EXPORTS //

module.exports = msum;


},{"validate.io-array":733,"validate.io-boolean-primitive":734,"validate.io-function":735,"validate.io-object":736,"validate.io-positive-integer":737}],733:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],734:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],735:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],736:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":733}],737:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":738}],738:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":739}],739:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],740:[function(require,module,exports){
/**
*
*	COMPUTE: multiply
*
*
*	DESCRIPTION:
*		- Computes an element-wise multiplication of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MULTIPLY //

/**
* FUNCTION: multiply( arr, x )
*	Computes an element-wise multiplication of an array.
*
* @param {Array} arr - numeric array
* @param {Array|Number} x - either an array of equal length or a scalar
*/
function multiply( arr, x ) {
	var isArray = Array.isArray( x ),
		len,
		i;

	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'multiply()::invalid input argument. Must provide an array.' );
	}
	len = arr.length;
	if ( !isArray && ( typeof x !== 'number' || x !== x ) ) {
		throw new TypeError( 'multiply()::invalid input argument. Second argument must be either an array or a scalar.' );
	}
	if ( isArray ) {
		if ( len !== x.length ) {
			throw new Error( 'multiply()::invalid input argument. Arrays must be of equal length.' );
		}
		for ( i = 0; i < len; i++ ) {
			arr[ i ] *= x[ i ];
		}
		return;
	}
	for ( i = 0; i < len; i++ ) {
		arr[ i ] *= x;
	}
} // end FUNCTION multiply()


// EXPORTS //

module.exports = multiply;

},{}],741:[function(require,module,exports){
/**
*
*	COMPUTE: mvariance
*
*
*	DESCRIPTION:
*		- Computes a moving sample variance over a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MOVING SAMPLE VARIANCE //

/**
* FUNCTION: mvariance( arr , window )
*	Computes a moving sample variance over a numeric array.
*
* @param {Array} arr - array of data values
* @param {Number} window - size of moving window
* @returns {Array} array of sample variance values
*/
function mvariance( arr , W ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'mvariance()::invalid input argument. Must provide an array.' );
	}
	if ( typeof W !== 'number' || W !== W ) {
        throw new TypeError( 'mvariance()::invalid input argument. Window must be numeric.' );
    }
    if ( (W%1) !== 0 || W < 1 ) {
        throw new TypeError( 'mvariance()::invalid input argument. Window must be a positive integer.' );
    }
	if ( W > arr.length ) {
		throw new TypeError( 'mvariance()::invalid input argument. Window cannot exceed the array length.' );
	}
	var len = arr.length,
		out = new Array( len-W+1 ),
		n = W - 1,
		mu = 0,
		M2 = 0,
		delta,
		x1,
		x2,
		d1,
		d2,
		i, j;

	if ( W === 1 ) {
		for ( i = 0; i < out.length; i++ ) {
			out[ i ] = 0;
		}
		return out;
	}

	// Compute the sample variance for the first window...
	for ( i = 0; i < W; i++ ) {
		x1 = arr[ i ];
		delta = x1 - mu;
		mu += delta / (i+1);
		M2 += delta * (x1 - mu);
	}
	out[ 0 ] = M2 / n;

	// Compute the remaining sample variances...
	for ( j = W; j < len; j++ ) {
		i = j - W;
		x1 = arr[ i ];
		x2 = arr[ j ];
		delta = x2 - x1;
		d1 = x1 - mu;
		mu += delta / W;
		d2 = x2 - mu;
		M2 += delta * (d1+d2);
		out[ i+1 ] = M2 / n;
	}
	return out;
} // end FUNCTION mvariance()


// EXPORTS //

module.exports = mvariance;

},{}],742:[function(require,module,exports){
/**
*
*	COMPUTE: nangmean
*
*
*	DESCRIPTION:
*		- Computes the geometric mean of an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANGMEAN //

	/**
	* FUNCTION: nangmean( arr )
	*	Computes the geometric mean over an array of values ignoring non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} gmean value
	*/
	function nangmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'gmean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			sum = 0,
			val;

		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( typeof val !== 'number' || val !== val ) {
				continue;
			}
			if ( val <= 0 ) {
				return NaN;
			}
			N += 1;
			sum += Math.log( val );
		}
		return Math.exp( sum / N );
	} // end FUNCTION nangmean()


	// EXPORTS //

	module.exports = nangmean;

})();
},{}],743:[function(require,module,exports){
/**
*
*	COMPUTE: nanhmean
*
*
*	DESCRIPTION:
*		- Computes the harmonic mean of an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANHMEAN //

	/**
	* FUNCTION: nanhmean( arr )
	*	Computes the harmonic mean over an array of values ignoring non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} harmonic mean
	*/
	function nanhmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'hmean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			sum = 0,
			N = 0,
			val;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( typeof val !== 'number' || val !== val ) {
				continue;
			}
			if ( val <= 0 ) {
				return NaN;
			}
			N += 1;
			sum += 1 / val;
		}
		return N / sum;
	} // end FUNCTION nanhmean()


	// EXPORTS //

	module.exports = nanhmean;

})();
},{}],744:[function(require,module,exports){
/**
*
*	COMPUTE: nanmax
*
*
*	DESCRIPTION:
*		- Computes the maximum value of an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: nanmax( arr )
*	Computes the maximum value of an array ignoring any non-numeric values.
*
* @param {Array} arr - array of values
* @returns {Number} max value
*/
function nanmax( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'nanmax()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		max = null,
		val;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( typeof val !== 'number' || val !== val ) {
			continue;
		}
		if ( max === null || val > max ) {
			max = val;
		}
	}
	return max;
} // end FUNCTION nanmax()


// EXPORTS //

module.exports = nanmax;

},{}],745:[function(require,module,exports){
/**
*
*	COMPUTE: nanmean
*
*
*	DESCRIPTION:
*		- Computes the arithmetic mean over an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANMEAN //

	/**
	* FUNCTION: nanmean( arr )
	*	Computes the arithmetic mean over an array of values ignoring any non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} mean value
	*/
	function nanmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'mean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			mu = 0,
			diff = 0,
			val;

		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( typeof val !== 'number' || val !== val ) {
				continue;
			}
			N += 1;
			diff = val - mu;
			mu += diff / N;
		}
		return mu;
	} // end FUNCTION nanmean()


	// EXPORTS //

	module.exports = nanmean;

})();
},{}],746:[function(require,module,exports){
/**
*
*	COMPUTE: nanmedian
*
*
*	DESCRIPTION:
*		- Computes the median of an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean' ),
	isNumber = require( 'validate.io-number' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MEDIAN //

/**
* FUNCTION: nanmedian( arr[, options] )
*	Computes the median of an array ignoring non-numeric values.
*
* @param {Array} arr - input array
* @param {Object} [options] - function options
* @param {Boolean} [options.sorted] - boolean flag indicating if the array is sorted in ascending order
* @param {Function} [options.accessor] - accessor function for accessing array values
* @returns {Number|null} median value or null
*/
function nanmedian( arr, options ) {
	var sorted,
		clbk,
		len,
		id,
		d,
		x;
	if ( !isArray( arr ) ) {
		throw new TypeError( 'nanmedian()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'nanmedian()::invalid input argument. Options must be an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'sorted' ) ) {
			sorted = options.sorted;
			if ( !isBoolean( sorted ) ) {
				throw new TypeError( 'nanmedian()::invalid option. Sorted flag must be a boolean. Option: `' + sorted + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'accessor' ) ) {
			clbk = options.accessor;
			if ( typeof clbk !== 'function' ) {
				throw new TypeError( 'nanmedian()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
		}
	}
	d = [];
	for ( var i = 0; i < arr.length; i++ ) {
		x = ( clbk ) ? clbk( arr[ i ] ) : arr[ i ];
		if ( isNumber( x ) ) {
			d.push( x );
		}
	}
	len = d.length;
	if ( !len ) {
		return null;
	}
	if ( !sorted ) {
		d.sort( ascending );
	}
	// Get the middle index:
	id = Math.floor( len / 2 );

	if ( len % 2 ) {
		// The number of elements is not evenly divisible by two, hence we have a middle index:
		return d[ id ];
	}
	// Even number of elements, so must take the mean of the two middle values:
	return ( d[ id-1 ] + d[ id ] ) / 2.0;
} // end FUNCTION nanmedian()


// EXPORTS //

module.exports = nanmedian;

},{"validate.io-array":747,"validate.io-boolean":748,"validate.io-number":749,"validate.io-object":750}],747:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],748:[function(require,module,exports){
arguments[4][703][0].apply(exports,arguments)
},{"dup":703}],749:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],750:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":747}],751:[function(require,module,exports){
/**
*
*	COMPUTE: nanmin
*
*
*	DESCRIPTION:
*		- Computes the minimum value of an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: nanmin( arr )
*	Computes the minimum value of an array ignoring any non-numeric values.
*
* @param {Array} arr - array of values
* @returns {Number} min value
*/
function nanmin( arr ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'nanmin()::invalid input argument. Must provide an array.' );
	}
	var len = arr.length,
		min = null,
		val;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( typeof val !== 'number' || val !== val ) {
			continue;
		}
		if ( min === null || val < min ) {
			min = val;
		}
	}
	return min;
} // end FUNCTION nanmin()


// EXPORTS //

module.exports = nanmin;

},{}],752:[function(require,module,exports){
/**
*
*	COMPUTE: nanprod
*
*
*	DESCRIPTION:
*		- Computes the product of an array ignoring any non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number' );


// NANPROD //

/**
* FUNCTION: nanprod( arr[, accessor] )
*	Computes the product of an array ignoring any non-numeric values.
*
* @param {Array} arr - array of values
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Number|Null} product
*/
function nanprod( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'nanprod()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( typeof clbk !== 'function' ) {
			throw new TypeError( 'nanprod()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	var len = arr.length,
		flg = false,
		p = 1,
		val,
		i;

	if ( !len ) {
		return null;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			val = clbk( arr[ i ] );
			if ( !isNumber( val ) ) {
				continue;
			} else {
				flg = true;
			}
			if ( val === 0 ) {
				return 0;
			}
			p *= val;
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( !isNumber( val ) ) {
				continue;
			} else {
				flg = true;
			}
			if ( val === 0 ) {
				return 0;
			}
			p *= val;
		}
	}
	return ( flg ) ? p : NaN;
} // end FUNCTION nanprod()


// EXPORTS //

module.exports = nanprod;

},{"validate.io-array":753,"validate.io-number":754}],753:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],754:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],755:[function(require,module,exports){
/**
*
*	COMPUTE: nanqmean
*
*
*	DESCRIPTION:
*		- Computes the quadratic mean (root mean square) of an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANQMEAN //

	/**
	* FUNCTION: nanqmean( arr )
	*	Calculates the quadratic mean (root mean square) ignoring any non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} quadratic mean
	*/
	function nanqmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'nanqmean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			t = 0,
			s = 1,
			r,
			val,
			abs;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( typeof val !== 'number' || val !== val ) {
				continue;
			}
			N += 1;
			abs = val;
			if ( abs < 0 ) {
				abs = -abs;
			}
			if ( abs > 0 ) {
				if ( abs > t ) {
					r = t / val;
					s = 1 + s*r*r;
					t = abs;
				} else {
					r = val / t;
					s = s + r*r;
				}
			}
		}
		return t * Math.sqrt( s/N );
	} // end FUNCTION nanqmean()


	// EXPORTS //

	module.exports = nanqmean;

})();
},{}],756:[function(require,module,exports){
/**
*
*	COMPUTE: nanquantiles
*
*
*	DESCRIPTION:
*		-  Computes quantiles for an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' ),
	isNumber = require( 'validate.io-number' ),
	isBoolean = require( 'validate.io-boolean' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// NANQUANTILES //

/**
* FUNCTION: nanquantiles( arr, num[, opts] )
*	Computes quantiles for an array ignoring non-numeric values.
*
* @param {Array} arr - array of values
* @param {Number} num - number of quantiles
* @param {Object} [opts] - function options
* @param {Boolean} [opts.sorted=false] - boolean flag indicating if the input array is sorted in ascending order.
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Array|null} array of quantiles or null
*/
function nanquantiles( arr, num, opts ) {
	var sorted,
		clbk,
		qValues,
		id,
		val,
		len,
		d,
		x,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'nanquantiles()::invalid input argument. First argument must be an array. Value: `' + arr + '`.' );
	}
	if ( !isNonNegativeInteger( num ) ) {
		throw new TypeError( 'nanquantiles()::invalid input argument. Number of quantiles must be a nonnegative integer. Value: `' + num + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'nanquantiles()::invalid input argument. Options must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'sorted' ) ) {
			sorted = opts.sorted;
			if ( !isBoolean( sorted ) ) {
				throw new TypeError( 'nanquantiles()::invalid option. Sorted flag must be a boolean. Option: `' + sorted + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( typeof clbk !== 'function' ) {
				throw new TypeError( 'nanquantiles()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
		}
	}
	d = [];
	for ( i = 0; i < arr.length; i++ ) {
		x = ( clbk ) ? clbk( arr[i] ) : arr[ i ];
		if ( isNumber( x ) ) {
			d.push( x );
		}
	}
	len = d.length;
	if ( !len ) {
		return null;
	}
	if ( !sorted ) {
		d.sort( ascending );
	}
	qValues = new Array( num+1 );

	// 0th quantile is the min:
	qValues[ 0 ] = d[ 0 ];

	// Max defines the quantile upper bound:
	qValues[ num ] = d[ len-1 ];

	// Get the quantiles...
	for ( i = 1; i < num; i++ ) {
		// Calculate the vector index marking the quantile:
		id = ( len * i / num ) - 1;

		// Is the index an integer?
		if ( id%1 === 0 ) {
			// Value is the average between the value at id and id+1:
			val = ( d[ id ] + d[ id+1 ] ) / 2.0;
		} else {
			// Round up to the next index:
			id = Math.ceil( id );
			val = d[ id ];
		}
		qValues[ i ] = val;
	} // end FOR i
	return qValues;
} // end FUNCTION nanquantiles()


// EXPORTS //

module.exports = nanquantiles;

},{"validate.io-array":757,"validate.io-boolean":758,"validate.io-nonnegative-integer":759,"validate.io-number":761,"validate.io-object":762}],757:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],758:[function(require,module,exports){
arguments[4][703][0].apply(exports,arguments)
},{"dup":703}],759:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":760}],760:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":761}],761:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],762:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":757}],763:[function(require,module,exports){
/**
*
*	COMPUTE: nanrange
*
*
*	DESCRIPTION:
*		- Computes the arithmetic range of an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),isNumber = require( 'validate.io-number' );


// NANRANGE //

/**
* FUNCTION: nanrange( arr[, accessor] )
*	Computes the arithmetic range of an array ignoring non-numeric values.
*
* @param {Array} arr - input array
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Array|null} arithmetic range or null
*/
function nanrange( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'range()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 && typeof clbk !== 'function' ) {
		throw new TypeError( 'range()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
	}
	var len = arr.length,
		min = null,
		max = min,
		flg = true,
		x;

	for ( var i = 0; i < len; i++ ) {
		x = ( clbk ) ? clbk( arr[i] ) : arr[ i ];
		if ( !isNumber( x ) ) {
			continue;
		}
		if ( flg ) {
			min = x;
			max = x;
			flg = false;
			continue;
		}
		if ( x < min ) {
			min = x;
		} else if ( x > max ) {
			max = x;
		}
	}
	return ( flg ) ? null : [ min, max ];
} // end FUNCTION nanrange()


// EXPORTS //

module.exports = nanrange;

},{"validate.io-array":764,"validate.io-number":765}],764:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],765:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],766:[function(require,module,exports){
/**
*
*	COMPUTE: nanstdev
*
*
*	DESCRIPTION:
*		- Computes the sample standard deviation over an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANSTDEV //

	/**
	* FUNCTION: nanstdev( arr )
	*	Computes the sample standard deviation over an array of values ignoring non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} sample standard deviation
	*/
	function nanstdev( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'nanstdev()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			mean = 0,
			M2 = 0,
			delta = 0,
			x;

		for ( var i = 0; i < len; i++ ) {
			x = arr[ i ];
			if ( typeof x !== 'number' || x !== x ) {
				continue;
			}
			N += 1;
			delta = x - mean;
			mean += delta / N;
			M2 += delta * ( x - mean );
		}
		if ( N < 2 ) {
			return 0;
		}
		return Math.sqrt( M2 / ( N-1 ) );
	} // end FUNCTION nanstdev()


	// EXPORTS //

	module.exports = nanstdev;

})();
},{}],767:[function(require,module,exports){
/**
*
*	COMPUTE: nansum
*
*
*	DESCRIPTION:
*		- Computes the sum of an array ignoring non-numeric values.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/


'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNumber = require( 'validate.io-number' );


// NANSUM //

/**
* FUNCTION: nansum( arr[, accessor] )
*	Computes the sum of an array ignoring non-numeric values.
*
* @param {Array} arr - input array
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Number|null} sum or null
*/
function nansum( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'nansum()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 && typeof clbk !== 'function' ) {
		throw new TypeError( 'nansum()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
	}
	var len = arr.length,
		s = 0,
		val,
		i;

	if ( !len ) {
		return null;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			val = clbk( arr[ i ] );
			if ( !isNumber( val ) ) {
				continue;
			}
			s += val;
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			val = arr[ i ];
			if ( !isNumber( val ) ) {
				continue;
			}
			s += val;
		}
	}
	return s;
} // end FUNCTION nansum()


// EXPORTS //

module.exports = nansum;

},{"validate.io-array":768,"validate.io-number":769}],768:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],769:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],770:[function(require,module,exports){
/**
*
*	COMPUTE: nanvariance
*
*
*	DESCRIPTION:
*		- Computes the sample variance over an array of values ignoring any values which are not numeric.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// NANVARIANCE //

	/**
	* FUNCTION: nanvariance( arr )
	*	Computes the sample variance over an array of values ignoring non-numeric values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} sample variance
	*/
	function nanvariance( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'nanvariance()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			mean = 0,
			M2 = 0,
			delta = 0,
			x;

		for ( var i = 0; i < len; i++ ) {
			x = arr[ i ];
			if ( typeof x !== 'number' || x !== x ) {
				continue;
			}
			N += 1;
			delta = x - mean;
			mean += delta / N;
			M2 += delta * ( x - mean );
		}
		if ( N < 2 ) {
			return 0;
		}
		return M2 / ( N-1 );
	} // end FUNCTION nanvariance()


	// EXPORTS //

	module.exports = nanvariance;

})();
},{}],771:[function(require,module,exports){
/**
*
*	COMPUTE: neq
*
*
*	DESCRIPTION:
*		- Computes an element-wise comparison (not equal) of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' );


// NOT EQUAL //

/**
* FUNCTION: neq( arr, x[, opts] )
*	Computes an element-wise comparison (not equal) of an array.
*
* @param {Array} arr - input array
* @param {*} x - comparator
* @param {Object} [opts] - function options
* @param {Boolean} [opts.strict] - option indicating whether to enforce type equality (default: true)
* @param {Boolean} [opts.array] - option indicating whether to not perform element-by-element comparison when provided arrays of equal length (default: false)
* @returns {Array} array of 1s and 0s, where a `1` indicates that an input array element is not equal to a compared value and `0` indicates that an input array element is equal to a compared value
*/
function neq( arr, x, opts ) {
	var isArray = Array.isArray( x ),
		strict = true,
		arrCompare = false,
		out,
		len,
		i;

	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'neq()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'neq()::invalid input argument. Options must be an object.' );
		}
		if ( opts.hasOwnProperty( 'strict' ) ) {
			strict = opts.strict;
			if ( typeof strict !== 'boolean' ) {
				throw new TypeError( 'neq()::invalid input argument. Strict option must be a boolean.' );
			}
		}
		if ( opts.hasOwnProperty( 'array' ) ) {
			arrCompare = opts.array;
			if ( typeof arrCompare !== 'boolean' ) {
				throw new TypeError( 'neq()::invalid input argument. Array option must be a boolean.' );
			}
		}
	}
	len = arr.length;
	out = new Array( len );
	if ( strict ) {
		if ( !isArray || x.length !== len || arrCompare ) {
			for ( i = 0; i < len; i++ ) {
				if ( arr[ i ] !== x ) {
					out[ i ] = 1;
				} else {
					out[ i ] = 0;
				}
			}
			return out;
		}
		for ( i = 0; i < len; i++ ) {
			if ( arr[ i ] !== x[ i ] ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
		return out;
	}
	if ( !isArray || x.length !== len || arrCompare ) {
		for ( i = 0; i < len; i++ ) {
			/* jshint eqeqeq:false */
			if ( arr[ i ] != x ) {
				out[ i ] = 1;
			} else {
				out[ i ] = 0;
			}
		}
		return out;
	}
	for ( i = 0; i < len; i++ ) {
		/* jshint eqeqeq:false */
		if ( arr[ i ] != x[ i ] ) {
			out[ i ] = 1;
		} else {
			out[ i ] = 0;
		}
	}
	return out;
} // end FUNCTION neq()


// EXPORTS //

module.exports = neq;

},{"validate.io-object":772}],772:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":773}],773:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],774:[function(require,module,exports){
/**
*
*	COMPUTE: pcorr
*
*
*	DESCRIPTION:
*		- Computes Pearson product-moment correlation coefficients between one or more numeric arrays.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// LINEAR CORRELATION //

/**
* FUNCTION: pcorr( arr1[, arr2,...] )
*	Computes Pearson product-moment correlation coefficients between one or more numeric arrays.
*
* @param {...Array} arr - numeric array
* @returns {Array} correlation matrix
*/
function pcorr() {
	var args,
		nArgs,
		len,
		deltas,
		delta,
		means,
		stdevs,
		C,
		cov,
		corr,
		arr,
		N, r, A, B, sum, val, sigma,
		i, j, n;

	args = Array.prototype.slice.call( arguments );
	nArgs = args.length;

	if ( !nArgs ) {
		throw new Error( 'pcorr()::insufficient input arguments. Must provide array arguments.' );
	}
	for ( i = 0; i < nArgs; i++ ) {
		if ( !Array.isArray( args[i] ) ) {
			throw new TypeError( 'pcorr()::invalid input argument. Must provide array arguments.' );
		}
	}
	if ( Array.isArray( args[0][0] ) ) {
		// If the first argument is an array of arrays, calculate the correlation matrix over the nested arrays, disregarding any other arguments...
		args = args[ 0 ];
	}
	nArgs = args.length;
	len = args[ 0 ].length;
	for ( i = 1; i < nArgs; i++ ) {
		if ( args[i].length !== len ) {
			throw new Error( 'pcorr()::invalid input argument. All arrays must have equal length.' );
		}
	}
	// [0] Initialization...
	deltas = new Array( nArgs );
	means = new Array( nArgs );
	stdevs = new Array( nArgs );
	C = new Array( nArgs );
	cov = new Array( nArgs );
	corr = new Array( nArgs );
	for ( i = 0; i < nArgs; i++ ) {
		means[ i ] = args[ i ][ 0 ];
		arr = new Array( nArgs );
		for ( j = 0; j < nArgs; j++ ) {
			arr[ j ] = 0;
		}
		C[ i ] = arr;
		cov[ i ] = arr.slice(); // copy!
		corr[ i ] = arr.slice(); // copy!
	}
	if ( len < 2 ) {
		return corr;
	}
	// [1] Compute the covariance...
	for ( n = 1; n < len; n++ ) {

		N = n + 1;
		r = n / N;

		// [a] Extract the values and compute the deltas...
		for ( i = 0; i < nArgs; i++ ) {
			deltas[ i ] = args[ i ][ n ] - means[ i ];
		}

		// [b] Update the covariance between one array and every other array...
		for ( i = 0; i < nArgs; i++ ) {
			arr = C[ i ];
			delta = deltas[ i ];
			for ( j = i; j < nArgs; j++ ) {
				A = arr[ j ];
				B = r * delta * deltas[ j ];
				sum = A + B;
				// Exploit the fact that the covariance matrix is symmetric...
				if ( i !== j ) {
					C[ j ][ i ] = sum;
				}
				arr[ j ] = sum;
			} // end FOR j
		} // end FOR i

		// [c] Update the means...
		for ( i = 0; i < nArgs; i++ ) {
			means[ i ] += deltas[ i ] / N;
		}
	} // end FOR n

	// [2] Normalize the co-moments...
	n = N - 1;
	for ( i = 0; i < nArgs; i++ ) {
		arr = C[ i ];
		for ( j = i; j < nArgs; j++ ) {
			val = arr[ j ] / n;
			cov[ i ][ j ] = val;
			if ( i !== j ) {
				cov[ j ][ i ] = val;
			}
		}
	}

	// [3] Compute the standard deviations...
	for ( i = 0; i < nArgs; i++ ) {
		// Diagonal elements of covariance matrix...
		stdevs[ i ] = Math.sqrt( cov[i][i] );
	}

	// [4] Set the diagonal elements to 1:
	for ( i = 0; i < nArgs; i++ ) {
		corr[ i ][ i ] = 1;
	}

	// [5] Compute the correlation coefficients...
	for ( i = 0; i < nArgs; i++ ) {
		arr = cov[ i ];
		sigma = stdevs[ i ];
		for ( j = i+1; j < nArgs; j++ ) {
			val = arr[ j ] / ( sigma*stdevs[j] );
			// Address floating point errors introduced by taking the sqrt and enforce strict [-1,1] bounds...
			if ( val > 1 ) {
				val = 1;
			} else if ( val < -1 ) {
				val = -1;
			}
			corr[ i ][ j ] = val;
			corr[ j ][ i ] = val;
		}
	}
	return corr;
} // end FUNCTION pcorr()


// EXPORTS //

module.exports = pcorr;

},{}],775:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArray = require( 'validate.io-array' ),
	isNumberArray = require( 'validate.io-number-primitive-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' );


// POLYVAL //

/**
* FUNCTION: polyval( coef, x )
*	Evaluates a polynomial.
*
* @private
* @param {Number[]} coef - array of coefficients sorted in descending degree
* @param {Number} x - value at which to evaluate the polynomial
* @return {Number} evaluated polynomial
*/
function polyval( c, x ) {
	var len = c.length,
		p = 0,
		i = 0;
	for ( ; i < len; i++ ) {
		p = p*x + c[ i ];
	}
	return p;
} // end FUNCTION polyval()


// EVALUATE //

/**
* FUNCTION: evaluate( coef, x[, options] )
*	Evaluates a polynomial.
*
* @param {Number[]} coef - array of coefficients sorted in descending degree
* @param {Array|Number[]|Number} x - value(s) at which to evaluate the polynomial
* @param {Object} [options] - function options
* @param {Boolean} [options.copy=true] - boolean indicating whether to return a new array
* @param {Function} [options.accessor] - accessor function for accessing array values
* @returns {Number|Number[]} evaluated polynomial
*/
function evaluate( c, x, opts ) {
	var copy = true,
		clbk,
		len,
		arr,
		v, i;
	if ( !isNumberArray( c ) ) {
		throw new TypeError( 'polynomial()::invalid input argument. Coefficients must be provided as an array of number primitives. Value: `' + c + '`.' );
	}
	if ( isNumber( x ) ) {
		return polyval( c, x );
	}
	if ( !isArray( x ) ) {
		throw new TypeError( 'polynomial()::invalid input argument. Second argument must be either a single number primitive or an array of values. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'polynomial()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'polynomial()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'polynomial()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
		}
	}
	len = x.length;
	if ( copy ) {
		arr = new Array( len );
	} else {
		arr = x;
	}
	if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			v = clbk( x[ i ], i );
			if ( !isNumber( v ) ) {
				throw new TypeError( 'polynomial()::invalid input argument. Accessed array values must be number primitives. Value: `' + v + '`.' );
			}
			arr[ i ] = polyval( c, v );
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			v = x[ i ];
			if ( !isNumber( v ) ) {
				throw new TypeError( 'polynomial()::invalid input argument. Array values must be number primitives. Value: `' + v + '`.' );
			}
			arr[ i ] = polyval( c, v );
		}
	}
	return arr;
} // end FUNCTION evaluate()


// EXPORTS //

module.exports = evaluate;

},{"validate.io-array":776,"validate.io-boolean-primitive":777,"validate.io-function":778,"validate.io-number-primitive":780,"validate.io-number-primitive-array":779,"validate.io-object":781}],776:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],777:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],778:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],779:[function(require,module,exports){
/**
*
*	VALIDATE: number-primitive-array
*
*
*	DESCRIPTION:
*		- Validates if a value is an array of primitive numbers.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' );


// IS NUMBER ARRAY //

/**
* FUNCTION: isNumberArray( value )
*	Validates if a value is an array of number primitives, excluding NaN.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is an array of number primitives
*/
function isNumberArray( value ) {
	var len, v;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( var i = 0; i < len; i++ ) {
		v = value[ i ];
		if ( typeof v !== 'number' || v !== v ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isNumberArray()


// EXPORTS //

module.exports = isNumberArray;

},{"validate.io-array":776}],780:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],781:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":776}],782:[function(require,module,exports){
'use strict';

/**
* FUNCTION: prod( arr, clbk )
*	Computes an array product using an accessor.
*
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number} product
*/
function prod( arr, clbk ) {
	var len = arr.length,
		p = 1,
		v,
		i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( v === 0 ) {
			return 0;
		}
		p *= v;
	}
	return p;
} // end FUNCTION prod()


// EXPORTS //

module.exports = prod;

},{}],783:[function(require,module,exports){
'use strict';

/**
* FUNCTION: prod( arr )
*	Computes an array product.
*
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number} product
*/
function prod( arr ) {
	var len = arr.length,
		p = 1,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( arr[ i ] === 0 ) {
			return 0;
		}
		p *= arr[ i ];
	}
	return p;
} // end FUNCTION prod()


// EXPORTS //

module.exports = prod;

},{}],784:[function(require,module,exports){
'use strict';

// MODULES //

var isArrayLike = require( 'validate.io-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ).raw,
	validate = require( './validate.js' );


// FUNCTIONS //

var prod1 = require( './array.js' ),
	prod2 = require( './accessor.js' ),
	prod3 = require( './matrix.js' );


// PROD //

/*
* FUNCTION: prod( x[, options] )
*	Computes the product of elements in x.
*
* @param {Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [options] - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim=2] - dimension along which to compute the product
* @param {String} [options.dtype="float64"] - output data type
* @returns {Number|Matrix} product(s)
*/
function prod( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		shape,
		ctor,
		err,
		len,
		dim,
		dt,
		d,
		m;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		dt = opts.dtype || 'float64';
		dim = opts.dim;

		// Determine if provided a vector...
		if ( x.shape[ 0 ] === 1 || x.shape[ 1 ] === 1 ) {
			// Treat as an array-like object:
			return prod1( x.data );
		}
		if ( dim > 2 ) {
			throw new RangeError( 'prod()::invalid option. Dimension option exceeds number of matrix dimensions. Option: `' + dim + '`.' );
		}
		if ( dim === void 0 || dim === 2 ) {
			len = x.shape[ 0 ];
			shape = [ len, 1 ];
		} else {
			len = x.shape[ 1 ];
			shape = [ 1, len ];
		}
		ctor = ctors( dt );
		if ( ctor === null ) {
			throw new Error( 'prod()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
		}
		// Create an output matrix and calculate the products:
		d = new ctor( len );
		m = matrix( d, shape, dt );
		return prod3( m, x, dim );
	}
	if ( isArrayLike( x ) ) {
		if ( opts.accessor ) {
			return prod2( x, opts.accessor );
		}
		return prod1( x );
	}
	throw new TypeError( 'prod()::invalid input argument. First argument must be either an array or a matrix. Value: `' + x + '`.' );
} // end FUNCTION prod()


// EXPORTS //

module.exports = prod;

},{"./accessor.js":782,"./array.js":783,"./matrix.js":785,"./validate.js":786,"compute-array-constructors":788,"dstructs-matrix":797,"validate.io-array-like":835,"validate.io-matrix-like":840}],785:[function(require,module,exports){
'use strict';

/**
* FUNCTION: prod( out, mat[, dim] )
*	Computes the product along a matrix dimension.
*
* @param {Matrix} out - output matrix
* @param {Matrix} mat - input matrix
* @param {Number} [dim=2] - matrix dimension along which to compute the product. If `dim=1`, compute along matrix rows. If `dim=2`, compute along matrix columns.
* @returns {Matrix|Number} product or 1
*/
function prod( out, mat, dim ) {
	var p,
		M, N,
		s0, s1,
		o,
		i, j, k;

	if ( dim === 1 ) {
		// Compute along the rows...
		M = mat.shape[ 1 ];
		N = mat.shape[ 0 ];
		s0 = mat.strides[ 1 ];
		s1 = mat.strides[ 0 ];
	} else {
		// Compute along the columns...
		M = mat.shape[ 0 ];
		N = mat.shape[ 1 ];
		s0 = mat.strides[ 0 ];
		s1 = mat.strides[ 1 ];
	}
	if ( M === 0 || N === 0 ) {
		return 1;
	}
	o = mat.offset;
	for ( i = 0; i < M; i++ ) {
		k = o + i*s0;
		p = 1;
		for ( j = 0; j < N; j++ ) {
			p *= mat.data[ k + j*s1 ];
		}
		out.data[ i ] = p;
	}
	return out;
} // end FUNCTION prod()


// EXPORTS //

module.exports = prod;

},{}],786:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim] - dimension
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'prod()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'prod()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dim' ) ) {
		opts.dim = options.dim;
		if ( !isPositiveInteger( opts.dim ) ) {
			return new TypeError( 'prod()::invalid option. Dimension option must be a positive integer. Option: `' + opts.dim + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'prod()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-function":839,"validate.io-object":841,"validate.io-positive-integer":843,"validate.io-string-primitive":846}],787:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],788:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":787,"dup":63}],789:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],790:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":793,"./iget.js":795,"./iset.js":798,"./mget.js":802,"./mset.js":804,"./set.js":812,"./sget.js":814,"./sset.js":816,"./toString.js":818,"dup":2}],791:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":794,"./iget.raw.js":796,"./iset.raw.js":799,"./mget.raw.js":803,"./mset.raw.js":805,"./set.raw.js":813,"./sget.raw.js":815,"./sset.raw.js":817,"./toString.js":818,"dup":3}],792:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],793:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":831}],794:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],795:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":829}],796:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],797:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":800,"./matrix.raw.js":801,"dup":9}],798:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":829,"validate.io-number-primitive":834}],799:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],800:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":789,"./ctor.js":790,"./dtypes.js":792,"compute-cast-arrays":819,"compute-dtype":822,"dup":12,"validate.io-array":826,"validate.io-contains":827,"validate.io-nonnegative-integer-array":830,"validate.io-string-primitive":846}],801:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":789,"./ctor.raw.js":791,"./dtypes.js":792,"compute-dtype":822,"dup":13,"validate.io-contains":827,"validate.io-string-primitive":846}],802:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":789,"dup":14,"validate.io-nonnegative-integer-array":830}],803:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":789,"dup":15}],804:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":806,"./mset2.js":807,"./mset3.js":808,"./mset4.js":809,"./mset5.js":810,"./mset6.js":811,"dup":16,"validate.io-function":839,"validate.io-nonnegative-integer-array":830,"validate.io-number-primitive":834}],805:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":806,"./mset2.js":807,"./mset3.js":808,"./mset4.js":809,"./mset5.js":810,"./mset6.js":811,"dup":17}],806:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],807:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],808:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],809:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],810:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],811:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],812:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":831,"validate.io-number-primitive":834}],813:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],814:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":789,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":846}],815:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":789,"compute-indexspace":585,"dup":27}],816:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":839,"validate.io-number-primitive":834,"validate.io-string-primitive":846}],817:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],818:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],819:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":787,"compute-array-dtype/lib/dtypes":820,"dup":31,"type-name":821,"validate.io-array-like":835}],820:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],821:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],822:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":824,"dup":36,"type-name":825}],823:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],824:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":823,"dup":38}],825:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],826:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],827:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":826,"validate.io-nan-primitive":828}],828:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],829:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":834}],830:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":826,"validate.io-nonnegative-integer":831}],831:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":832}],832:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":833}],833:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],834:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],835:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":836,"dup":34,"validate.io-integer-primitive":837}],836:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],837:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":838}],838:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],839:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],840:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],841:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":842}],842:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],843:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":844}],844:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":845}],845:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],846:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],847:[function(require,module,exports){
/**
*
*	COMPUTE: qmean
*
*
*	DESCRIPTION:
*		- Computes the quadratic mean (root mean square) of an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// QMEAN //

	/**
	* FUNCTION: qmean( arr )
	*	Calculates the quadratic mean (root mean square) of an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} quadratic mean
	*/
	function qmean( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'qmean()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			t = 0,
			s = 1,
			r,
			val,
			abs;
		for ( var i = 0; i < len; i++ ) {
			val = arr[ i ];
			abs = val;
			if ( abs < 0 ) {
				abs = -abs;
			}
			if ( abs > 0 ) {
				if ( abs > t ) {
					r = t / val;
					s = 1 + s*r*r;
					t = abs;
				} else {
					r = val / t;
					s = s + r*r;
				}
			}
		}
		return t * Math.sqrt( s/len );
	} // end FUNCTION qmean()


	// EXPORTS //

	module.exports = qmean;

})();
},{}],848:[function(require,module,exports){
/**
*
*	COMPUTE: quantile
*
*
*	DESCRIPTION:
*		- Computes a quantile for a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// QUANTILE //

/**
* FUNCTION: quantile( arr, prob[, opts] )
*	Computes a quantile for a numeric array.
*
* @private
* @param {Array} arr - 1d array
* @param {Number} prob - quantile prob [0,1]
* @param {Object} [opts] - method options:
	`method`: method used to interpolate a quantile value
	`sorted`: boolean flag indicating if the input array is sorted
* @returns {Number} quantile value
*/
function quantile( arr, p, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'quantile()::invalid input argument. First argument must be an array.' );
	}
	if ( typeof p !== 'number' || p !== p ) {
		throw new TypeError( 'quantile()::invalid input argument. Quantile probability must be numeric.' );
	}
	if ( p < 0 || p > 1 ) {
		throw new TypeError( 'quantile()::invalid input argument. Quantile probability must be on the interval [0,1].' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'quantile()::invalid input argument. Options must be an object.' );
		}
		if ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {
			throw new TypeError( 'quantile()::invalid input argument. Sorted flag must be a boolean.' );
		}
		if ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {
			throw new TypeError( 'quantile()::invalid input argument. Method must be a string.' );
		}
		// TODO: validate that the requested method is supported. list.indexOf( method )
	} else {
		opts = {};
	}
	var len = arr.length,
		id;

	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}

	// Cases...

	// [0] 0th percentile is the minimum value...
	if ( p === 0.0 ) {
		return arr[ 0 ];
	}
	// [1] 100th percentile is the maximum value...
	if ( p === 1.0 ) {
		return arr[ len-1 ];
	}
	// Calculate the vector index marking the quantile:
	id = ( len*p ) - 1;

	// [2] Is the index an integer?
	if ( id === Math.floor( id ) ) {
		// Value is the average between the value at id and id+1:
		return ( arr[ id ] + arr[ id+1 ] ) / 2.0;
	}
	// [3] Round up to the next index:
	id = Math.ceil( id );
	return arr[ id ];
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"validate.io-object":849}],849:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":850}],850:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],851:[function(require,module,exports){
/**
*
*	COMPUTE: quantiles
*
*
*	DESCRIPTION:
*		- Computes quantiles for numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isInteger = require( 'validate.io-integer' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// QUANTILES //

/**
* FUNCTION: quantiles( arr, num[, opts] )
*	Computes quantiles for a numeric array.
*
* @param {Array} arr - array of values
* @param {Number} num - number of quantiles
* @param {Object} [options] - function options
* @returns {Array} quantiles
*/
function quantiles( arr, num, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'quantiles()::invalid input argument. First argument must be an array.' );
	}
	if ( !isInteger( num ) || num <= 0 ) {
		throw new TypeError( 'quantiles()::invalid input argument. Second argument must be a positive integer.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'quantiles()::invalid input argument. Options should be an object.' );
		}
		if ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {
			throw new TypeError( 'quantiles()::invalid input argument. Sorted flag must be a boolean.' );
		}
		if ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {
			throw new TypeError( 'quantiles()::invalid input argument. Method must be a string.' );
		}
		// TODO: validate that the requested method is supported. list.indexOf( method )
	} else {
		opts = {};
	}
	var len = arr.length,
		qValues = new Array( num+1 ),
		id,
		val;

	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}

	// 0th quantile is the min:
	qValues[ 0 ] = arr[ 0 ];

	// Max defines the quantile upper bound:
	qValues[ num ] = arr[ len-1 ];

	// Get the quantiles...
	for ( var i = 1; i < num; i++ ) {

		// Calculate the vector index marking the quantile:
		id = ( len * i / num ) - 1;

		// Is the index an integer?
		if ( id === Math.floor( id ) ) {
			// Value is the average between the value at id and id+1:
			val = ( arr[ id ] + arr[ id+1 ] ) / 2.0;
		} else {
			// Round up to the next index:
			id = Math.ceil( id );
			val = arr[ id ];
		}
		qValues[ i ] = val;
	} // end FOR i
	return qValues;
} // end FUNCTION quantiles()


// EXPORTS //

module.exports = quantiles;

},{"validate.io-integer":852,"validate.io-object":854}],852:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":853}],853:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],854:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":855}],855:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],856:[function(require,module,exports){
/**
*
*	COMPUTE: rad2deg
*
*
*	DESCRIPTION:
*		- Converts radians to degrees.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// RADIANS-TO-DEGREES //

/**
* FUNCTION: rad2deg( x )
*	Converts radians to degrees. Note: if provided an array, the array is mutated.
*
* @param {Array|Number} x - value(s) to be converted to degrees
* @returns {Array|Number|Null} degree value(s). If `x` is an empty `array`, returns `null`.
*/
function rad2deg( x ) {
	var isArray = Array.isArray( x ),
		len;
	if ( !isArray && ( typeof x !== 'number' || x !== x ) ) {
		throw new TypeError( 'rad2deg()::invalid input argument. Must provide either a single numeric value or a numeric array.' );
	}
	if ( !isArray ) {
		return x * 180 / Math.PI;
	}
	len = x.length;
	if ( !len ) {
		return null;
	}
	for ( var i = 0; i < len; i++ ) {
		x[ i ] *= 180 / Math.PI;
	}
	return x;
} // end FUNCTION rad2deg()


// EXPORTS //

module.exports = rad2deg;

},{}],857:[function(require,module,exports){
/**
*
*	COMPUTE: range
*
*
*	DESCRIPTION:
*		- Computes the arithmetic range of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isFunction = require( 'validate.io-function' );


// RANGE //

/**
* FUNCTION: range( arr[, accessor] )
*	Returns the arithmetic range of an array.
*
* @param {Array} arr - input array
* @param {Function} [accessor] - accessor function for accessing array values
* @returns {Array|null} arithmetic range or null
*/
function range( arr, clbk ) {
	if ( !isArray( arr ) ) {
		throw new TypeError( 'range()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}

	if ( arguments.length > 1 && !isFunction( clbk ) ) {
		throw new TypeError( 'range()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
	}
	var len = arr.length,
		min,
		max,
		x, i;

	if ( len === 0 ) {
		return null;
	}
	if ( clbk ) {
		min = clbk( arr[ 0 ] );
		max = min;
		for ( i = 1; i < len; i++ ) {
			x = clbk( arr[ i ] );
			if ( x < min ) {
				min = x;
			} else if ( x > max ) {
				max = x;
			}
		}
	} else {
		min = arr[ 0 ];
		max = min;
		for ( i = 1; i < len; i++ ) {
			x = arr[ i ];
			if ( x < min ) {
				min = x;
			} else if ( x > max ) {
				max = x;
			}
		}
	}
	return [ min, max ];
} // end FUNCTION range()


// EXPORTS //

module.exports = range;

},{"validate.io-array":858,"validate.io-function":859}],858:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],859:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],860:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' );


// REVERSE //

/**
* FUNCTION: reverse( arr[, options] )
*	Reverses an `array`.
*
* @param {Array} arr - input array
* @param {Object} [options] - function options
* @param {Boolean} [options.copy=true] - boolean indicating whether to return a new array
* @returns {Array} reversed array
*/
function reverse( arr, opts ) {
	var copy,
		half,
		len,
		tmp,
		out,
		N,
		i, j;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'reverse()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'reverse()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'reverse()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
	}
	len = arr.length;
	N = len - 1;
	if ( copy ) {
		out = new Array( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = arr[ N-i ];
		}
		return out;
	}
	half = Math.floor( len / 2 );
	for ( i = 0; i < half; i++ ) {
		tmp = arr[ i ];
		j = N - i;
		arr[ i ] = arr[ j ];
		arr[ j ] = tmp;
	}
	return arr;
} // end FUNCTION reverse()


// EXPORTS //

module.exports = reverse;

},{"validate.io-array":861,"validate.io-boolean-primitive":862,"validate.io-object":863}],861:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],862:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],863:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":861}],864:[function(require,module,exports){
/**
*
*	COMPUTE: roundn
*
*
*	DESCRIPTION:
*		- Round values to the nearest multiple of 10^n.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: roundn( x, n )
*	Rounds values to the nearest multiple of 10^n. Notes: if provided an array, mutates the array.
*
* @param {Array|Number} x - value(s) to be rounded
* @param {Number} n - power of 10; should be an integer value
* @returns {Array|Number} rounded value(s). If `x` is an empty array, returns `null`.
*/
function roundn( x, n ) {
	var isArray = Array.isArray( x ),
		scalar,
		len;
	if ( !isArray && ( typeof x !== 'number' || x !== x ) ) {
		throw new TypeError( 'roundn()::invalid input argument. Must provide either a single numeric value or a numeric array.' );
	}
	if ( typeof n !== 'number' || n !== n || n !== ( n | 0) ) {
		throw new TypeError( 'roundn()::invalid input argument. Power of 10 must be an integer value.' );
	}
	n = -n;
	scalar = Math.pow( 10, n );
	if ( !isArray ) {
		return Math.round( x*scalar ) / scalar;
	}
	len = x.length;
	if ( !len ) {
		return null;
	}
	for ( var i = 0; i < len; i++ ) {
		x[ i ] = Math.round( x[i]*scalar ) / scalar;
	}
	return x;
} // end FUNCTION roundn()


// EXPORTS //

module.exports = roundn;

},{}],865:[function(require,module,exports){
/**
*
*	COMPUTE: shuffle
*
*
*	DESCRIPTION:
*		- Shuffles array elements in place.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	// SHUFFLE //

	/**
	* FUNCTION: shuffle( arr )
	*	Mutates an input `array` to generate a random permutation of `array` elements.
	*
	* @param {Array} arr - `array` to shuffle
	*/
	function shuffle( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'shuffle()::invalid input argument. Must provide an array.' );
		}
		var N = arr.length,
			j,
			tmp;

		// Note: we skip the first element, as no further swaps are possible given that all other indices are excluded from swapping...
		for ( var i = N - 1; i > 0; i-- ) {
			// Generate an integer index on the interval: [0,i]
			j = Math.floor( Math.random() * (i+1) );

			// Swap elements:
			tmp = arr[ i ];
			arr[ i ] = arr[ j ];
			arr[ j ] = tmp;
		}
	} // end FUNCTION shuffle()


	// EXPORTS //

	module.exports = shuffle;

})();
},{}],866:[function(require,module,exports){
'use strict';

// FUNCTIONS

var SIGN = require( './number.js' );


// SIGNUM FUNCTION //

/**
* FUNCTION: signum( out, arr, accessor )
*	Evaluates the signum function for each array element using an accessor function.
*
* @param {Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]} output array
*/
function signum( y, x, clbk ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		y[ i ] = SIGN( clbk( x[ i ], i ) );
	}
	return y;
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{"./number.js":871}],867:[function(require,module,exports){
'use strict';

// MODULES //

var SIGN = require( './number.js' );


// SIGNUM FUNCTION //

/**
* FUNCTION: signum( out, arr )
*	Evaluates the signum function for each array element.
*
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function signum( y, x ) {
	var len = x.length,
		i;
	for ( i = 0; i < len; i++ ) {
		y[ i ] = SIGN( x[ i ] );
	}
	return y;
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{"./number.js":871}],868:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	SIGN = require( './number.js' );


// SIGNUM FUNCTION //

/**
* FUNCTION: signum( arr, path[, sep] )
*	Evaluates the signum function for each array element and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function signum( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			dset( x[i], SIGN( dget( x[i] ) ) );
		}
	}
	return x;
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{"./number.js":871,"utils-deep-get":921,"utils-deep-set":926}],869:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isNaN = require( 'validate.io-nan'),
	isArray = require( 'validate.io-array' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var signum1 = require( './number.js' ),
	signum2 = require( './array.js' ),
	signum3 = require( './accessor.js' ),
	signum4 = require( './deepset.js' ),
	signum5 = require( './matrix.js' );


// SIGNUM FUNCTION //

/**
* FUNCTION: signum( x[, opts] )
*	Evaluates the signum function.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix|Null} signum function value(s) or null
*/
function signum( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		err,
		out,
		d;

	if ( isNumber( x ) || isNaN( x ) ) {
		return signum1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			d = new Int8Array( x.length );
			out = matrix( d, x.shape, 'int8' );
		} else {
			out = x;
		}
		return signum5( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return signum4( x, opts.path, opts.sep );
		}
		// Handle regular, typed, and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( !isArray( x ) ) {
			out = new Int8Array( x.length );
		} else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return signum3( out, x, opts.accessor );
		}
		return signum2( out, x );
	}
	throw new TypeError( 'signum()::invalid input argument. Input value type not currently supported. Value: `' + x + '`.' );
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{"./accessor.js":866,"./array.js":867,"./deepset.js":868,"./matrix.js":870,"./number.js":871,"./validate.js":872,"dstructs-matrix":882,"validate.io-array":931,"validate.io-array-like":928,"validate.io-matrix-like":934,"validate.io-nan":935,"validate.io-number-primitive":936}],870:[function(require,module,exports){
'use strict';

// MODULES //

var SIGN = require( './number.js' );


// SIGNUM FUNCTION //

/**
* FUNCTION: signum( out, matrix )
*	Evaluates the signum function for each matrix element.
*
* @param {Matrix} out - output matirx
* @param {Matrix} arr - input matrix
* @returns {Matrix} output matrix
*/
function signum( y, x ) {
	var len = x.length,
		i;
	if ( y.length !== len ) {
		throw new Error( 'signum()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = SIGN( x.data[ i ] );
	}
	return y;
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{"./number.js":871}],871:[function(require,module,exports){
'use strict';

// SIGNUM //

/**
* FUNCTION: signum( x )
*	Determines the sign of a numeric value.
*
* @param {Number} x - input value
* @returns {Number} value indicating the sign
*/
function signum( x ) {
	// [0] NaN
	if ( x !== x ) {
		return NaN;
	}
	// [1] +-0
	if ( !x ) {
		return x;
	}
	// [2] x < 0
	if ( x < 0 ) {
		return -1;
	}
	// [3] x > 0
	return 1;
} // end FUNCTION signum()


// EXPORTS //

module.exports = signum;

},{}],872:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'signum()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'signum()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'signum()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'signum()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'signum()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":932,"validate.io-function":933,"validate.io-object":937,"validate.io-string-primitive":938}],873:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],874:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],875:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":878,"./iget.js":880,"./iset.js":883,"./mget.js":887,"./mset.js":889,"./set.js":897,"./sget.js":899,"./sset.js":901,"./toString.js":903,"dup":2}],876:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":879,"./iget.raw.js":881,"./iset.raw.js":884,"./mget.raw.js":888,"./mset.raw.js":890,"./set.raw.js":898,"./sget.raw.js":900,"./sset.raw.js":902,"./toString.js":903,"dup":3}],877:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],878:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":915}],879:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],880:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":913}],881:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],882:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":885,"./matrix.raw.js":886,"dup":9}],883:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":913,"validate.io-number-primitive":936}],884:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],885:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":874,"./ctor.js":875,"./dtypes.js":877,"compute-cast-arrays":904,"compute-dtype":907,"dup":12,"validate.io-array":931,"validate.io-contains":911,"validate.io-nonnegative-integer-array":914,"validate.io-string-primitive":938}],886:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":874,"./ctor.raw.js":876,"./dtypes.js":877,"compute-dtype":907,"dup":13,"validate.io-contains":911,"validate.io-string-primitive":938}],887:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":874,"dup":14,"validate.io-nonnegative-integer-array":914}],888:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":874,"dup":15}],889:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":891,"./mset2.js":892,"./mset3.js":893,"./mset4.js":894,"./mset5.js":895,"./mset6.js":896,"dup":16,"validate.io-function":933,"validate.io-nonnegative-integer-array":914,"validate.io-number-primitive":936}],890:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":891,"./mset2.js":892,"./mset3.js":893,"./mset4.js":894,"./mset5.js":895,"./mset6.js":896,"dup":17}],891:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],892:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],893:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],894:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],895:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],896:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],897:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":915,"validate.io-number-primitive":936}],898:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],899:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":874,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":938}],900:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":874,"compute-indexspace":585,"dup":27}],901:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":933,"validate.io-number-primitive":936,"validate.io-string-primitive":938}],902:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],903:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],904:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":873,"compute-array-dtype/lib/dtypes":905,"dup":31,"type-name":906,"validate.io-array-like":928}],905:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],906:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],907:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":909,"dup":36,"type-name":910}],908:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],909:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":908,"dup":38}],910:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],911:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":931,"validate.io-nan-primitive":912}],912:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],913:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":936}],914:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":931,"validate.io-nonnegative-integer":915}],915:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":916}],916:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":917}],917:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],918:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],919:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],920:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":918,"./defaults.js":919,"./validate.js":922,"dup":111,"validate.io-array":931,"validate.io-string-primitive":938}],921:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":918,"./defaults.js":919,"./factory.js":920,"./validate.js":922,"dup":112,"validate.io-array":931,"validate.io-string-primitive":938}],922:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":937,"validate.io-string-primitive":938}],923:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],924:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],925:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":923,"./defaults.js":924,"./validate.js":927,"dup":117,"validate.io-array":931,"validate.io-string-primitive":938}],926:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":923,"./defaults.js":924,"./factory.js":925,"./validate.js":927,"dup":118,"validate.io-array":931,"validate.io-string-primitive":938}],927:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":932,"validate.io-object":937,"validate.io-string-primitive":938}],928:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":929,"dup":34,"validate.io-integer-primitive":930}],929:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],930:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":936}],931:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],932:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],933:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],934:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],935:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],936:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],937:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":931}],938:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],939:[function(require,module,exports){
/**
*
*	COMPUTE: skewness
*
*
*	DESCRIPTION:
*		- Computes the sample skewness of an array of values.
*
*
*	NOTES:
*		[1] The formula for corrected sample skewness comes from: Jones and Gill (1998). Comparing measures of sample skewness and kurtosis. The Statistician. DOI: 10.1111/1467-9884.00122
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	/**
	* FUNCTION: skewness( arr )
	*	Computes the sample skewness of an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} sample skewness
	*/
	function skewness( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'skewness()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			delta = 0,
			delta_n = 0,
			term1 = 0,
			N = 0,
			mean = 0,
			M2 = 0,
			M3 = 0,
			g;

		for ( var i = 0; i < len; i++ ) {
			N += 1;

			delta = arr[ i ] - mean;
			delta_n = delta / N;

			term1 = delta * delta_n * (N-1);

			M3 += term1*delta_n*(N-2) - 3*delta_n*M2;
			M2 += term1;
			mean += delta_n;
		}
		// Calculate the population skewness:
		g = Math.sqrt( N )*M3 / Math.pow( M2, 3/2 );
		// Return the corrected sample skewness:
		return Math.sqrt( N*N-1)*g / (N-2);
	} // end FUNCTION skewness()


	// EXPORTS //

	module.exports = skewness;

})();
},{}],940:[function(require,module,exports){
'use strict';

// MODULES //

var SQRT = require( './number.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( out, arr, accessor )
*	Computes an element-wise principal square root using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function sqrt( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = SQRT( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./number.js":945}],941:[function(require,module,exports){
'use strict';

// MODULES //

var SQRT = require( './number.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( out, arr )
*	Computes an element-wise principal square root.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function sqrt( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = SQRT( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./number.js":945}],942:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	SQRT = require( './number.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( arr, path[, sep] )
*	Computes an element-wise principal square root and deep sets the input array.
*
* @param {Array} arr - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function sqrt( x, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], SQRT( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./number.js":945,"utils-deep-get":998,"utils-deep-set":1004}],943:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var sqrt1 = require( './number.js' ),
	sqrt2 = require( './array.js' ),
	sqrt3 = require( './accessor.js' ),
	sqrt4 = require( './deepset.js' ),
	sqrt5 = require( './matrix.js' ),
	sqrt6 = require( './typedarray.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( x[, opts] )
*	Computes an element-wise principal square root.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} square root(s)
*/
function sqrt( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( x ) || isnan( x ) ) {
		return sqrt1( x );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'sqrt()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return sqrt5( out, x );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'sqrt()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return sqrt6( out, x );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return sqrt4( x, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'sqrt()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return sqrt3( out, x, opts.accessor );
		}
		return sqrt2( out, x );
	}
	return NaN;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./accessor.js":940,"./array.js":941,"./deepset.js":942,"./matrix.js":944,"./number.js":945,"./typedarray.js":946,"./validate.js":947,"compute-array-constructors":949,"dstructs-matrix":958,"validate.io-array-like":1007,"validate.io-matrix-like":1012,"validate.io-nan":1013,"validate.io-number-primitive":1014,"validate.io-typed-array-like":1018}],944:[function(require,module,exports){
'use strict';

// MODULES //

var SQRT = require( './number.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( out, x )
*	Computes an element-wise principal square root.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function sqrt( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'sqrt()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = SQRT( x.data[ i ] );
	}
	return out;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./number.js":945}],945:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.sqrt;

},{}],946:[function(require,module,exports){
'use strict';

// MODULES //

var SQRT = require( './number.js' );


// SQUARE ROOT //

/**
* FUNCTION: sqrt( out, arr )
*	Computes an element-wise principal square root.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function sqrt( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = SQRT( arr[ i ] );
	}
	return out;
} // end FUNCTION sqrt()


// EXPORTS //

module.exports = sqrt;

},{"./number.js":945}],947:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'sqrt()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'sqrt()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'sqrt()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'sqrt()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'sqrt()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'sqrt()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1010,"validate.io-function":1011,"validate.io-object":1015,"validate.io-string-primitive":1017}],948:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],949:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":948,"dup":63}],950:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],951:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":954,"./iget.js":956,"./iset.js":959,"./mget.js":963,"./mset.js":965,"./set.js":973,"./sget.js":975,"./sset.js":977,"./toString.js":979,"dup":2}],952:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":955,"./iget.raw.js":957,"./iset.raw.js":960,"./mget.raw.js":964,"./mset.raw.js":966,"./set.raw.js":974,"./sget.raw.js":976,"./sset.raw.js":978,"./toString.js":979,"dup":3}],953:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],954:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":992}],955:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],956:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":990}],957:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],958:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":961,"./matrix.raw.js":962,"dup":9}],959:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":990,"validate.io-number-primitive":1014}],960:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],961:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":950,"./ctor.js":951,"./dtypes.js":953,"compute-cast-arrays":980,"compute-dtype":983,"dup":12,"validate.io-array":987,"validate.io-contains":988,"validate.io-nonnegative-integer-array":991,"validate.io-string-primitive":1017}],962:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":950,"./ctor.raw.js":952,"./dtypes.js":953,"compute-dtype":983,"dup":13,"validate.io-contains":988,"validate.io-string-primitive":1017}],963:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":950,"dup":14,"validate.io-nonnegative-integer-array":991}],964:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":950,"dup":15}],965:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":967,"./mset2.js":968,"./mset3.js":969,"./mset4.js":970,"./mset5.js":971,"./mset6.js":972,"dup":16,"validate.io-function":1011,"validate.io-nonnegative-integer-array":991,"validate.io-number-primitive":1014}],966:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":967,"./mset2.js":968,"./mset3.js":969,"./mset4.js":970,"./mset5.js":971,"./mset6.js":972,"dup":17}],967:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],968:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],969:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],970:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],971:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],972:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],973:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":992,"validate.io-number-primitive":1014}],974:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],975:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":950,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":1017}],976:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":950,"compute-indexspace":585,"dup":27}],977:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":1011,"validate.io-number-primitive":1014,"validate.io-string-primitive":1017}],978:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],979:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],980:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":948,"compute-array-dtype/lib/dtypes":981,"dup":31,"type-name":982,"validate.io-array-like":1007}],981:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],982:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],983:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":985,"dup":36,"type-name":986}],984:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],985:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":984,"dup":38}],986:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],987:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],988:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":987,"validate.io-nan-primitive":989}],989:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],990:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1014}],991:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":987,"validate.io-nonnegative-integer":992}],992:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":993}],993:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":994}],994:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],995:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],996:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],997:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":995,"./defaults.js":996,"./validate.js":999,"dup":111,"validate.io-array":1000,"validate.io-string-primitive":1017}],998:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":995,"./defaults.js":996,"./factory.js":997,"./validate.js":999,"dup":112,"validate.io-array":1000,"validate.io-string-primitive":1017}],999:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1015,"validate.io-string-primitive":1017}],1000:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1001:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1002:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1003:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1001,"./defaults.js":1002,"./validate.js":1005,"dup":117,"validate.io-array":1006,"validate.io-string-primitive":1017}],1004:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1001,"./defaults.js":1002,"./factory.js":1003,"./validate.js":1005,"dup":118,"validate.io-array":1006,"validate.io-string-primitive":1017}],1005:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1010,"validate.io-object":1015,"validate.io-string-primitive":1017}],1006:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1007:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1008,"dup":34,"validate.io-integer-primitive":1009}],1008:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1009:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1014}],1010:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1011:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1012:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1013:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1014:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1015:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1016}],1016:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1017:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1018:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1019,"dup":132,"validate.io-integer-primitive":1020}],1019:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1020:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1014}],1021:[function(require,module,exports){
/**
*
*	COMPUTE: stdev
*
*
*	DESCRIPTION:
*		- Computes the sample standard deviation over an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	/**
	* FUNCTION: stdev( arr )
	*	Computes the sample standard deviation over an array of values.
	*
	* @param {Array} arr - array of values
	* @returns {Number} sample standard deviation
	*/
	function stdev( arr ) {
		if ( !Array.isArray( arr ) ) {
			throw new TypeError( 'stdev()::invalid input argument. Must provide an array.' );
		}
		var len = arr.length,
			N = 0,
			mean = 0,
			M2 = 0,
			delta = 0;

		if ( len < 2 ) {
			return 0;
		}
		for ( var i = 0; i < len; i++ ) {
			N += 1;
			delta = arr[ i ] - mean;
			mean += delta / N;
			M2 += delta * ( arr[i] - mean );
		}
		return Math.sqrt( M2 / ( N-1 ) );
	} // end FUNCTION stdev()


	// EXPORTS //

	module.exports = stdev;

})();
},{}],1022:[function(require,module,exports){
'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isNumber = require( 'validate.io-number-primitive' );


// SUBTRACT //

/**
* FUNCTION: subtract( arr, x[, opts] )
*	Computes an element-wise subtraction.
*
* @param {Number[]|Array} arr - input array
* @param {Number[]|Array|Number} x - either an array of equal length or a scalar
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating whether to return a new array
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @returns {Number[]} output array
*/
function subtract( arr, x, opts ) {
	var isArr = isArray( x ),
		copy = true,
		arity,
		clbk,
		out,
		len,
		i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'subtract()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	if ( !isArr && !isNumber( x ) ) {
		throw new TypeError( 'subtract()::invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );
	}
	if ( arguments.length > 2 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'subtract()::invalid input argument. Options argument must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'copy' ) ) {
			copy = opts.copy;
			if ( !isBoolean( copy ) ) {
				throw new TypeError( 'subtract()::invalid option. Copy option must be a boolean primitive. Option: `' + copy + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'accessor' ) ) {
			clbk = opts.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'subtract()::invalid option. Accessor must be a function. Option: `' + clbk + '`.' );
			}
			arity = clbk.length;
		}
	}
	len = arr.length;
	if ( copy ) {
		out = new Array( len );
	} else {
		out = arr;
	}
	// Case 1: x is an array
	if ( isArr ) {
		if ( len !== x.length ) {
			throw new Error( 'subtract()::invalid input argument. Array to be added must have a length equal to that of the input array.' );
		}
		if ( arity === 3 ) { // clbk implied
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i, 0 ) - clbk( x[i], i, 1 );
			}
		}
		else if ( clbk ) {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = clbk( arr[i], i ) - x[ i ];
			}
		}
		else {
			for ( i = 0; i < len; i++ ) {
				out[ i ] = arr[ i ] - x[ i ];
			}
		}
	}
	// Case 2: accessor and scalar
	else if ( clbk ) {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = clbk( arr[i], i ) - x;
		}
	}
	// Case 3: scalar
	else {
		for ( i = 0; i < len; i++ ) {
			out[ i ] = arr[ i ] - x;
		}
	}
	return out;
} // end FUNCTION subtract()


// EXPORTS //

module.exports = subtract;

},{"validate.io-array":1023,"validate.io-boolean-primitive":1024,"validate.io-function":1025,"validate.io-number-primitive":1026,"validate.io-object":1027}],1023:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1024:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1025:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1026:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1027:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1023}],1028:[function(require,module,exports){
'use strict';

/**
* FUNCTION: sum( arr, clbk )
*	Computes a sum using an accessor.
*
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number} sum
*/
function sum( arr, clbk ) {
	var len = arr.length,
		s = 0,
		i;
	for ( i = 0; i < len; i++ ) {
		s += clbk( arr[ i ], i );
	}
	return s;
} // end FUNCTION sum()


// EXPORTS //

module.exports = sum;

},{}],1029:[function(require,module,exports){
'use strict';

/**
* FUNCTION: sum( arr )
*	Computes the sum.
*
* @param {Array} arr - input array
* @returns {Number} sum
*/
function sum( arr ) {
	var len = arr.length,
		s = 0,
		i;
	for ( i = 0; i < len; i++ ) {
		s += arr[ i ];
	}
	return s;
} // end FUNCTION sum()


// EXPORTS //

module.exports = sum;

},{}],1030:[function(require,module,exports){
'use strict';

// MODULES //

var isArrayLike = require( 'validate.io-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ).raw,
	validate = require( './validate.js' );


// FUNCTIONS //

var sum1 = require( './array.js' ),
	sum2 = require( './accessor.js' ),
	sum3 = require( './matrix.js' );


// SUM //

/*
* FUNCTION: sum( x[, options] )
*	Computes the sum of elements in x.
*
* @param {Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [options] - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim=2] - dimension along which to compute the sum
* @param {String} [options.dtype="float64"] - output data type
* @returns {Number|Matrix} sum(s)
*/
function sum( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		shape,
		ctor,
		err,
		len,
		dim,
		dt,
		d,
		m;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		dt = opts.dtype || 'float64';
		dim = opts.dim;

		// Determine if provided a vector...
		if ( x.shape[ 0 ] === 1 || x.shape[ 1 ] === 1 ) {
			// Treat as an array-like object:
			return sum1( x.data );
		}
		if ( dim > 2 ) {
			throw new RangeError( 'sum()::invalid option. Dimension option exceeds number of matrix dimensions. Option: `' + dim + '`.' );
		}
		if ( dim === void 0 || dim === 2 ) {
			len = x.shape[ 0 ];
			shape = [ len, 1 ];
		} else {
			len = x.shape[ 1 ];
			shape = [ 1, len ];
		}
		ctor = ctors( dt );
		if ( ctor === null ) {
			throw new Error( 'sum()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
		}
		// Create an output matrix and calculate the sums:
		d = new ctor( len );
		m = matrix( d, shape, dt );
		return sum3( m, x, dim );
	}
	if ( isArrayLike( x ) ) {
		if ( opts.accessor ) {
			return sum2( x, opts.accessor );
		}
		return sum1( x );
	}
	throw new TypeError( 'sum()::invalid input argument. First argument must be either an array or a matrix. Value: `' + x + '`.' );
} // end FUNCTION sum()


// EXPORTS //

module.exports = sum;

},{"./accessor.js":1028,"./array.js":1029,"./matrix.js":1031,"./validate.js":1032,"compute-array-constructors":1034,"dstructs-matrix":1043,"validate.io-array-like":1081,"validate.io-matrix-like":1086}],1031:[function(require,module,exports){
'use strict';

/**
* FUNCTION: sum( out, mat[, dim] )
*	Computes the sum along a matrix dimension.
*
* @param {Matrix} out - output matrix
* @param {Matrix} mat - input matrix
* @param {Number} [dim=2] - matrix dimension along which to compute the sum. If `dim=1`, compute along matrix rows. If `dim=2`, compute along matrix columns.
* @returns {Matrix|Number} sums or 0
*/
function sum( out, mat, dim ) {
	var s,
		M, N,
		s0, s1,
		o,
		i, j, k;

	if ( dim === 1 ) {
		// Compute along the rows...
		M = mat.shape[ 1 ];
		N = mat.shape[ 0 ];
		s0 = mat.strides[ 1 ];
		s1 = mat.strides[ 0 ];
	} else {
		// Compute along the columns...
		M = mat.shape[ 0 ];
		N = mat.shape[ 1 ];
		s0 = mat.strides[ 0 ];
		s1 = mat.strides[ 1 ];
	}
	if ( M === 0 || N === 0 ) {
		return 0;
	}
	o = mat.offset;
	for ( i = 0; i < M; i++ ) {
		k = o + i*s0;
		s = 0;
		for ( j = 0; j < N; j++ ) {
			s += mat.data[ k + j*s1 ];
		}
		out.data[ i ] = s;
	}
	return out;
} // end FUNCTION sum()


// EXPORTS //

module.exports = sum;

},{}],1032:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim] - dimension
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'sum()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'sum()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dim' ) ) {
		opts.dim = options.dim;
		if ( !isPositiveInteger( opts.dim ) ) {
			return new TypeError( 'sum()::invalid option. Dimension option must be a positive integer. Option: `' + opts.dim + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'sum()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-function":1085,"validate.io-object":1087,"validate.io-positive-integer":1089,"validate.io-string-primitive":1092}],1033:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1034:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1033,"dup":63}],1035:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1036:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1039,"./iget.js":1041,"./iset.js":1044,"./mget.js":1048,"./mset.js":1050,"./set.js":1058,"./sget.js":1060,"./sset.js":1062,"./toString.js":1064,"dup":2}],1037:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1040,"./iget.raw.js":1042,"./iset.raw.js":1045,"./mget.raw.js":1049,"./mset.raw.js":1051,"./set.raw.js":1059,"./sget.raw.js":1061,"./sset.raw.js":1063,"./toString.js":1064,"dup":3}],1038:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1039:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1077}],1040:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1041:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1075}],1042:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1043:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1046,"./matrix.raw.js":1047,"dup":9}],1044:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1075,"validate.io-number-primitive":1080}],1045:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1046:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1035,"./ctor.js":1036,"./dtypes.js":1038,"compute-cast-arrays":1065,"compute-dtype":1068,"dup":12,"validate.io-array":1072,"validate.io-contains":1073,"validate.io-nonnegative-integer-array":1076,"validate.io-string-primitive":1092}],1047:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1035,"./ctor.raw.js":1037,"./dtypes.js":1038,"compute-dtype":1068,"dup":13,"validate.io-contains":1073,"validate.io-string-primitive":1092}],1048:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1035,"dup":14,"validate.io-nonnegative-integer-array":1076}],1049:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1035,"dup":15}],1050:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1052,"./mset2.js":1053,"./mset3.js":1054,"./mset4.js":1055,"./mset5.js":1056,"./mset6.js":1057,"dup":16,"validate.io-function":1085,"validate.io-nonnegative-integer-array":1076,"validate.io-number-primitive":1080}],1051:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1052,"./mset2.js":1053,"./mset3.js":1054,"./mset4.js":1055,"./mset5.js":1056,"./mset6.js":1057,"dup":17}],1052:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1053:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1054:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1055:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1056:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1057:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1058:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1077,"validate.io-number-primitive":1080}],1059:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1060:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1035,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":1092}],1061:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1035,"compute-indexspace":585,"dup":27}],1062:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":1085,"validate.io-number-primitive":1080,"validate.io-string-primitive":1092}],1063:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],1064:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1065:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1033,"compute-array-dtype/lib/dtypes":1066,"dup":31,"type-name":1067,"validate.io-array-like":1081}],1066:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1067:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1068:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1070,"dup":36,"type-name":1071}],1069:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1070:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1069,"dup":38}],1071:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1072:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1073:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1072,"validate.io-nan-primitive":1074}],1074:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1075:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1080}],1076:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1072,"validate.io-nonnegative-integer":1077}],1077:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1078}],1078:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1079}],1079:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1080:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1081:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1082,"dup":34,"validate.io-integer-primitive":1083}],1082:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1083:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1084}],1084:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1085:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1086:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1087:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1088}],1088:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1089:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":1090}],1090:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1091}],1091:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1092:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1093:[function(require,module,exports){
/**
*
*	COMPUTE: trimean
*
*
*	DESCRIPTION:
*		- Computes the trimean of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	median = require( 'compute-median' ),
	quantile = require( 'compute-quantile' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// TRIMEAN //

/**
* FUNCTION: trimean( arr[, opts] )
*	Computes the trimean of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Object} [opts] - quantile function options
* @returns {Number} trimean
*/
function trimean( arr, opts ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'trimean()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'trimean()::invalid input argument. Options should be an object.' );
		}
	} else {
		opts = {
			'sorted': false
		};
	}
	if ( !opts.sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
		opts.sorted = true;
	}
	var q1 = quantile( arr, 0.25, opts ),
		q2 = median( arr, true ),
		q3 = quantile( arr, 0.75, opts );

	return ( q1 + 2*q2 + q3 ) / 4.0;
} // end FUNCTION trimean()


// EXPORTS //
module.exports = trimean;

},{"compute-median":1094,"compute-quantile":848,"validate.io-object":1095}],1094:[function(require,module,exports){
/**
*
*	COMPUTE: median
*
*
*	DESCRIPTION:
*		- Computes the median of a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// MEDIAN //

/**
* FUNCTION: median( arr[, sorted] )
*	Computes the median of a numeric array.
*
* @param {Array} arr - numeric array
* @param {Boolean} [sorted] - boolean flag indicating if the array is sorted in ascending order
* @returns {Number} median value
*/
function median( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'median()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean' ) {
		throw new TypeError( 'median()::invalid input argument. Second argument must be a boolean.' );
	}
	var len = arr.length,
		id;

	if ( !sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}

	// Get the middle index:
	id = Math.floor( len / 2 );

	if ( len % 2 ) {
		// The number of elements is not evenly divisible by two, hence we have a middle index:
		return arr[ id ];
	}
	// Even number of elements, so must take the mean of the two middle values:
	return ( arr[ id-1 ] + arr[ id ] ) / 2.0;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{}],1095:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1096}],1096:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1097:[function(require,module,exports){
/**
*
*	COMPUTE: truncmean
*
*
*	DESCRIPTION:
*		- Computes the truncated mean of an array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
    isNumber = require( 'validate.io-number-primitive' ),
    isBoolean = require( 'validate.io-boolean-primitive' ),
    isObject = require( 'validate.io-object' ),
    isFunction = require( 'validate.io-function' ),
    isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// TRUNCATED MEAN //

/**
* FUNCTION: truncmean( arr, discard[, options] )
*	Computes the truncated mean of an array.
*
* @param {Array} arr - input array
* @param {Number} discard - either a percentage expressed on the interval [0,0.5] or a non-negative integer.
* @param {Object} [options] - function options
* @param {Boolean} [options.sorted=false] - boolean indicating if the input array is sorted in ascending order
* @param {Function} [options.accessor] - accessor function for accessing numeric array values
* @param {Boolean} [options.interpolate=false] - boolean indicating whether to interpolate between truncated means when a discard percentage does not yield an integer number of array values to discard
* @returns {Number|null} truncated mean
*/
function truncmean( arr, discard, options ) {
	var sorted,
		clbk,
		interp,
		delta,
		diff,
		len,
		mu,
		lo,
		hi,
		N,
		tmp,
		w1, w2,
		d, i;

	if ( !isArray( arr ) ) {
		throw new TypeError( 'truncmean()::invalid input argument. Must provide an array. Value: `' + arr + '`.' );
	}
	len = arr.length;
	if ( isNumber( discard ) ) {
		if ( !isNonNegativeInteger( discard ) ) {
			if ( discard < 0 || discard > 0.5 ) {
				throw new RangeError( 'truncmean()::invalid input argument. Discard must be either a number on the interval [0,0.5] or a nonnegative integer. Value: `' + discard + '`.' );
			}
		}
		else if ( discard > len/2 ) {
			throw new RangeError( 'truncmean()::invalid input argument. Number of discard values cannot exceed half the array length. Value: `' + discard + '`.' );
		}
	} else {
		throw new TypeError( 'truncmean()::invalid input argument. Discard must be either a number on the interval [0,0.5] or a nonnegative integer. Value: `' + discard + '`.' );
	}
	if ( arguments.length > 2  ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'truncmean()::invalid input argument. Options must be an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'sorted' ) ) {
			sorted = options.sorted;
			if ( !isBoolean( sorted ) ) {
				throw new TypeError( 'truncmean()::invalid option. Sorted option must be a boolean. Value: `' + sorted + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'accessor' ) ) {
			clbk = options.accessor;
			if ( !isFunction( clbk ) ) {
				throw new TypeError( 'truncmean()::invalid option. Accessor must be a function. Value: `' + clbk + '`.' );
			}
		}
		if ( options.hasOwnProperty( 'interpolate' ) ) {
			interp = options.interpolate;
			if ( !isBoolean( interp ) ) {
				throw new TypeError( 'truncmean()::invalid option. Interpolate option must be a boolean. Value: `' + interp + '`.' );
			}
		}
	}
	if ( !len ) {
		return null;
	}
	if ( !clbk && sorted ) {
		d = arr;
	}
	else if ( !clbk ) {
		d = [];
		for ( i = 0; i < len; i++ ) {
			d.push( arr[ i ] );
		}
	} else {
		d = [];
		for ( i = 0; i < len; i++ ) {
			d.push( clbk( arr[ i ] ) );
		}
	}
	if ( !sorted ) {
		d.sort( ascending );
	}
	// Case 1: no interpolation...
	if ( discard >= 1 || discard === 0 || discard === 0.5 || !interp ) {
		if ( discard < 1 && discard !== 0 ) {
			// Convert the discard percentage to a number of values:
			discard = Math.floor( len * discard );
		}
		lo = discard;
		hi = len - discard - 1;

		// Handle case where discard = 0.5 and array length is even...
		if ( hi < lo ) {
			tmp = lo;
			lo = hi;
			hi = tmp;
		}
		mu = 0;
		N = 0;
		for ( i = lo; i <= hi; i++ ) {
			N += 1;
			delta = d[ i ] - mu;
			mu += delta / N;
		}
		return mu;
	}
	// Case 2: interpolation...
	N = Math.floor( len * discard );

	// Compute the discard percentages used for interpolation...
	w1 = N / len;
	w2 = (N+1) / len;

	lo = N;
	hi = len - N - 1;

	// Compute the first mean...
	mu = 0;
	N = 0;
	for ( i = lo; i <= hi; i++ ) {
		N += 1;
		delta = d[ i ] - mu;
		mu += delta / N;
	}
	// If w2 exceeds 50%, then we are interpolating from the median to the median, which, regardless of weights, is just the median...
	if ( w2*2 >= 1 ) {
		return mu;
	}
	tmp = mu;

	// Convert the discard percentages to weights...
	diff = w2 - w1;
	i = w1;
	w1 = (w2-discard) / diff;
	w2 = (discard-i) / diff;

	// Compute the second mean by removing the lowest and highest previously included elements (see TODO)...
	N -= 1;
	delta = d[ lo ] - mu;
	mu -= delta / N;

	N -= 1;
	delta = d[ hi ] - mu;
	mu -= delta / N;

	// Compute the weighted average:
	return w1*tmp + w2*mu;
} // end FUNCTION truncmean()


// EXPORTS //

module.exports = truncmean;

},{"validate.io-array":1098,"validate.io-boolean-primitive":1099,"validate.io-function":1100,"validate.io-nonnegative-integer":1101,"validate.io-number-primitive":1104,"validate.io-object":1105}],1098:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1099:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1100:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1101:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1102}],1102:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1103}],1103:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1104:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1105:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1098}],1106:[function(require,module,exports){
/**
*
*	COMPUTE: tversky-index
*
*
*	DESCRIPTION:
*   -	Computes the Tversky index between two sequences.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Philipp Burckhardt.
*
*
*	AUTHOR:
*		Philipp Burckhardt. pburckhardt@outlook.com. 2015.
*
*/

'use strict';

// MODULES //

var intersect = require( 'intersect' ),
	isArray = require( 'validate.io-array' ),
	isString = require( 'validate.io-string' ),
	isBoolean = require( 'validate.io-boolean' ),
	isObject = require( 'validate.io-object' ),
	isNonNegative = require( 'validate.io-nonnegative' );


// FUNCTIONS //

/**
* FUNCTION: unique( arr )
*	Computes the unique elements of an array.
*
* @private
* @param {Array} arr - input array
* @returns {Array} array of unique elements
*/
function unique( arr ) {
	var len = arr.length,
		hash = {},
		vals = [],
		val;

	for ( var i = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( !hash.hasOwnProperty( val ) ) {
			hash[ val ] = true;
			vals.push( val );
		}
	}
	return vals;
} // end FUNCTION unique()


// TVERSKY INDEX //

/**
* FUNCTION: tversky( a, b[, options] )
*   Computes the Tversky index between two sequences. For alpha = beta = 0.5, the index is equal to Dice's coefficient. For alpha = beta = 1, the index is equal to the Tanimoto coefficient.
*
* @param {String|Array} a - array or string sequence
* @param {String|Array} b - array or string sequence
* @param {Object} [options] - method options
* @param {Number} [options.alpha=1] - weight of prototype
* @param {Number} [options.beta=1] - weight of variant
* @param {Boolean} [options.symmetric=false] - boolean specifying whether the index should be symmetric
* @returns {Number} Tversky index
*/
function tversky( a, b, options ) {
	var symmetric = false,
		alpha = 1,
		beta = 1,
		aType,
		bType,
		opts,
		anb,
		len,
		aCompl,
		bCompl,
		hash,
		min,
		max,
		i;

	aType = isString( a );
	if ( !isArray( a ) && !aType ) {
		throw new TypeError( 'tversky()::invalid input argument. Sequence must be either an array or a string. Value: `' + a + '`.' );
	}
	bType = isString( b );
	if ( !isArray( b )  && !bType ) {
		throw new TypeError( 'tversky()::invalid input argument. Sequence must be either an array or a string. Value: `' + b + '`.' );
	}
	if ( aType !== bType ) {
		throw new Error( 'tversky()::invalid input arguments. Sequences must be the same type; i.e., both strings or both arrays.' );
	}
	if ( arguments.length > 2 ) {
		opts = options;
		if ( !isObject( opts ) ) {
			throw new TypeError( 'tversky()::invalid input argument. Options must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'alpha' ) ) {
			alpha = opts.alpha;
			if ( !isNonNegative( alpha ) ) {
				throw new TypeError( 'tversky()::invalid option. Alpha must be a nonnegative number. Value: `' + alpha + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'beta' ) ) {
			beta = opts.beta;
			if ( !isNonNegative( beta ) ) {
				throw new TypeError( 'tversky()::invalid option. Beta must be a nonnegative number. Value: `' + beta + '`.' );
			}
		}
		if ( opts.hasOwnProperty( 'symmetric' ) ) {
			symmetric = opts.symmetric;
			if ( !isBoolean( symmetric ) ) {
				throw new TypeError( 'tversky()::invalid option. Symmetric flag must be a boolean. Value: `' + symmetric + '`.' );
			}
		}
	}
	if ( aType ){
		a = a.split( '' );
		b = b.split( '' );
	}
	// Determine the unique elements for each array:
	a = unique( a );
	b = unique( b );

	// Compute the intersection between the unique sets:
	anb = intersect( a, b );
	len = anb.length;

	// Create a hash...
	hash = {};
	for ( i = 0; i < len; i++ ) {
		hash[ anb[i] ] = true;
	}
	// Compute the relative complements...
	aCompl = 0;
	for ( i = 0; i < a.length; i++ ) {
		if ( !hash.hasOwnProperty( a[i] ) ) {
			aCompl++;
		}
	}
	bCompl = 0;
	for ( i = 0; i < b.length; i++ ) {
		if ( !hash.hasOwnProperty( b[i] ) ) {
			bCompl++;
		}
	}
	if ( symmetric ) {
		if ( aCompl > bCompl ) {
			min = bCompl;
			max = aCompl;
		} else {
			min = aCompl;
			max = bCompl;
		}
		return len / ( len + beta*(alpha*min + max*(1-alpha))  );
	}
	return len / ( len + alpha*aCompl + beta*bCompl );
} // end FUNCTION tversky()


// EXPORTS //

module.exports = tversky;

},{"intersect":1107,"validate.io-array":1108,"validate.io-boolean":1109,"validate.io-nonnegative":1110,"validate.io-object":1112,"validate.io-string":1113}],1107:[function(require,module,exports){
module.exports = intersect;

function intersect (a, b) {
  var res = [];
  for (var i = 0; i < a.length; i++) {
    if (indexOf(b, a[i]) > -1) res.push(a[i]);
  }
  return res;
}

intersect.big = function(a, b) {
  var ret = [];
  var temp = {};
  
  for (var i = 0; i < b.length; i++) {
    temp[b[i]] = true;
  }
  for (var i = 0; i < a.length; i++) {
    if (temp[a[i]]) ret.push(a[i]);
  }
  
  return ret;
}

function indexOf(arr, el) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === el) return i;
  }
  return -1;
}

},{}],1108:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1109:[function(require,module,exports){
arguments[4][703][0].apply(exports,arguments)
},{"dup":703}],1110:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// IS NONNEGATIVE //

/**
* FUNCTION: isNonNegative( value )
*	Validates if a value is a nonnegative number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative number
*/
function isNonNegative( value ) {
	return isNumber( value ) && value >= 0;
} // end FUNCTION isNonNegative()


// EXPORTS //

module.exports = isNonNegative;

},{"validate.io-number":1111}],1111:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1112:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1108}],1113:[function(require,module,exports){
arguments[4][551][0].apply(exports,arguments)
},{"dup":551}],1114:[function(require,module,exports){
/**
*
*	COMPUTE: umidmean
*
*
*	DESCRIPTION:
*		- Computes the interquartile mean of the values above the median for a numeric array (upper midmean).
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Rebekah Smith.
*
*
*	AUTHOR:
*		Rebekah Smith. rebekahjs17@gmail.com. 2014.
*
*/

'use strict';

// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function used to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// UPPER MIDMEAN //

/**
* FUNCTION: umidmean( arr[, sorted] )
*	Computes the interquartile mean of the values above the median in a numeric array (upper midmean).
*
* @param {Array} arr - numeric array
* @param {Boolean} [sorted] - boolean flag indicating if the input array is sorted in ascending order
* @returns {Number} upper midmean
*/
function umidmean( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'umidmean()::invalid input argument. Must provide an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean' ) {
		throw new TypeError( 'umidmean()::invalid input argument. Second argument must be a boolean.' );
	}
	if ( arr.length < 6 ) {
		throw new Error( 'umidmean()::invalid input argument. Input array must have 6 or more elements.' );
	}
	if ( !sorted ) {
		arr = arr.slice();
		arr.sort( ascending );
	}
	var len = arr.length,
		mean = 0,
		N = 0,
		delta,
		low,
		high;

	// Quartiles sit between values
	if ( len%8 === 0 ) {
		low = len*0.625;
		high = len*0.875 - 1;
	}
	else {
		low = Math.ceil( len*0.625 );
		high = Math.floor( len*0.875 ) - 1;
	}

	// Compute an arithmetic mean...
	for ( var i = low; i <= high; i++ ) {
		N += 1;
		delta = arr[ i ] - mean;
		mean += delta / N;
	}

	return mean;
} // end FUNCTION umidmean()


// EXPORTS //

module.exports = umidmean;

},{}],1115:[function(require,module,exports){
/**
*
*	COMPUTE: unique
*
*
*	DESCRIPTION:
*		- Removes duplicate values from a numeric array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// FUNCTIONS //

/**
* FUNCTION: ascending( a, b )
*	Comparator function to sort values in ascending order.
*
* @private
* @param {Number} a
* @param {Number} b
* @returns {Number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
} // end FUNCTION ascending()


// UNIQUE //

/**
* FUNCTION: unique( arr, sorted )
*	Removes duplicate values from a numeric array. Note: the input array is mutated.
*
* @param {Array} arr - array to be deduped
* @param {Boolean} sorted - boolean flag indicating if the input array is sorted
*/
function unique( arr, sorted ) {
	if ( !Array.isArray( arr ) ) {
		throw new TypeError( 'unique()::invalid input argument. First argument must be an array.' );
	}
	if ( arguments.length > 1 && typeof sorted !== 'boolean' ) {
		throw new TypeError( 'unique()::invalid input argument. Second argument must be an array.' );
	}
	var len = arr.length,
		i, j,
		val;

	if ( !len ) {
		return;
	}
	if ( !sorted ) {
		arr.sort( ascending );
	}
	// Loop through the array, only incrementing a pointer when successive values are different. When a succeeding value is different, move the pointer and set the next value. In the trivial case where all array elements are unique, we incur a slight penalty in resetting the element value for each unique value. In other cases, we simply move a unique value to a new position in the array. The end result is a sorted array with unique values.
	for ( i = 1, j = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( arr[ j ] !== val ) {
			j++;
			arr[ j ] = val;
		}
	}
	// Truncate the array:
	arr.length = j+1;
} // end FUNCTION unique()


// EXPORTS //

module.exports = unique;

},{}],1116:[function(require,module,exports){
/**
*
*	COMPUTE: unzip
*
*
*	DESCRIPTION:
*		- Unzips a zipped array (i.e., a nested array of tuples).
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' ),
	isNonNegativeInteger = require( 'validate.io-nonnegative-integer' ),
	isArrayArray = require( 'validate.io-array-array' );


// UNZIP //

/**
* FUNCTION: unzip( arr[, idx] )
*	Unzips a zipped array (i.e., a nested array of tuples).
*
* @param {Array} arr - zipped array
* @param {Array} [idx] - array of indices specifying which tuple elements to unzip
* @returns {Array} array of unzipped arrays
*/
function unzip( arr, idx ) {
	var len,
		out,
		tmp,
		numVals,
		i, j, k;

	if ( !isArrayArray( arr ) ) {
		throw new TypeError( 'unzip()::invalid input argument. Must provide a zipped array (an array of arrays). Value: `' + arr + '`.' );
	}
	// Assume that the first tuple is representative of all tuples...
	numVals = arr[ 0 ].length;
	if ( arguments.length > 1 ) {
		if ( !isArray( idx ) ) {
			throw new TypeError( 'unzip()::invalid input argument. Indices must be specified as an array.' );
		}
		for ( i = 0; i < idx.length; i++ ) {
			k = idx[ i ];
			if ( !isNonNegativeInteger( k ) ) {
				throw new TypeError( 'unzip()::invalid input argument. All indices must be nonnegative integers. Value: `' + k + '`.' );
			}
			if ( k > numVals ) {
				throw new RangeError( 'unzip()::invalid input argument. Must provide valid indices; i.e., an index must be on the interval [0,' + numVals + ']. Value: `' + k + '`.' );
			}
		}
		numVals = idx.length;
	} else {
		idx = new Array( numVals );
		for ( i = 0; i < numVals; i++ ) {
			idx[ i ] = i;
		}
	}
	out = new Array( numVals );
	len = arr.length;
	for ( j = 0; j < numVals; j++ ) {
		tmp = new Array( len );
		k = idx[ j ];
		for ( i = 0; i < len; i++ ) {
			tmp[ i ] = arr[ i ][ k ];
		}
		out[ j ] = tmp;
	}
	return out;
} // end FUNCTION unzip()


// EXPORTS //

module.exports = unzip;

},{"validate.io-array":1118,"validate.io-array-array":1117,"validate.io-nonnegative-integer":1119}],1117:[function(require,module,exports){
/**
*
*	VALIDATE: array-array
*
*
*	DESCRIPTION:
*		- Validates if a value is an array of arrays.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isArray = require( 'validate.io-array' );


// IS ARRAY OF ARRAYS //

/**
* FUNCTION: isArrayArray( value )
*	Validates if a value is an array of arrays.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is an array of arrays
*/
function isArrayArray( value ) {
	var len;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( var i = 0; i < len; i++ ) {
		if ( !isArray( value[i] ) ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isArrayArray()


// EXPORTS //

module.exports = isArrayArray;

},{"validate.io-array":1118}],1118:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1119:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1120}],1120:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1121}],1121:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1122:[function(require,module,exports){
'use strict';

/**
* FUNCTION: variance( arr, clbk[, bias] )
*	Computes the variance of an array using an accessor.
*
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @param {Boolean} [bias=false] - boolean indicating whether to calculate a biased or unbiased estimate of the variance
* @returns {Number|Null} variance or null
*/
function variance( arr, clbk, bias ) {
	var len = arr.length,
		delta = 0,
		mean = 0,
		M2 = 0,
		x, i;

	if ( !len ) {
		return null;
	}
	if ( len < 2 ) {
		return 0;
	}
	for ( i = 0; i < len; i++ ) {
		x = clbk( arr[ i ], i );
		delta = x - mean;
		mean += delta / (i+1);
		M2 += delta * ( x - mean );
	}
	if ( bias ) {
		return M2 / ( i );
	}
	return M2 / ( i - 1 );
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{}],1123:[function(require,module,exports){
'use strict';

/**
* FUNCTION: variance( arr[, bias] )
*	Computes the variance of an array.
*
* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Boolean} [bias=false] - boolean indicating whether to calculate a biased or unbiased estimate of the variance
* @returns {Number|Null} variance or null
*/
function variance( arr, bias ) {
	var len = arr.length,
		delta = 0,
		mean = 0,
		M2 = 0,
		x, i;

	if ( !len ) {
		return null;
	}
	if ( len < 2 ) {
		return 0;
	}
	for ( i = 0; i < len; i++ ) {
		x = arr[ i ];
		delta = x - mean;
		mean += delta / (i+1);
		M2 += delta * ( x - mean );
	}
	if ( bias ) {
		return M2 / ( i );
	}
	return M2 / ( i - 1 );
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{}],1124:[function(require,module,exports){
'use strict';

// MODULES //

var isArrayLike = require( 'validate.io-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ).raw,
	validate = require( './validate.js' );


// FUNCTIONS //

var variance1 = require( './array.js' ),
	variance2 = require( './accessor.js' ),
	variance3 = require( './matrix.js' );


// VARIANCE //

/*
* FUNCTION: variance( x[, options] )
*	Computes the variance of elements in x.
*
* @param {Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.bias=false] - - boolean indicating whether to calculate a biased or unbiased estimate of the variance
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {Number} [opts.dim=2] - dimension along which to compute the variance
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Matrix|Null} variance value(s) or null
*/
function variance( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		shape,
		ctor,
		err,
		len,
		dim,
		dt,
		d,
		m;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( x ) ) {
		dt = opts.dtype || 'float64';
		dim = opts.dim;

		// Determine if provided a vector...
		if ( x.shape[ 0 ] === 1 || x.shape[ 1 ] === 1 ) {
			// Treat as an array-like object:
			return variance1( x.data );
		}
		if ( dim > 2 ) {
			throw new RangeError( 'variance()::invalid option. Dimension option exceeds number of matrix dimensions. Option: `' + dim + '`.' );
		}
		if ( dim === void 0 || dim === 2 ) {
			len = x.shape[ 0 ];
			shape = [ len, 1 ];
		} else {
			len = x.shape[ 1 ];
			shape = [ 1, len ];
		}
		ctor = ctors( dt );
		if ( ctor === null ) {
			throw new Error( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
		}
		// Create an output matrix and calculate the variance(s):
		d = new ctor( len );
		m = matrix( d, shape, dt );
		return variance3( m, x, opts.bias, dim );
	}
	if ( isArrayLike( x ) ) {
		if ( opts.accessor ) {
			return variance2( x, opts.accessor, opts.bias );
		}
		return variance1( x, opts.bias );
	}
	throw new TypeError( 'variance()::invalid input argument. First argument must be either an array or a matrix. Value: `' + x + '`.' );
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./accessor.js":1122,"./array.js":1123,"./matrix.js":1125,"./validate.js":1126,"compute-array-constructors":1128,"dstructs-matrix":1137,"validate.io-array-like":1175,"validate.io-matrix-like":1181}],1125:[function(require,module,exports){
'use strict';

/**
* FUNCTION: variance( out, mat[, bias[, dim] ] )
*	Computes the variance along a matrix dimension.
*
* @param {Matrix} out - output matrix
* @param {Matrix} mat - input matrix
* @param {Boolean} [bias=false] - boolean indicating whether to calculate a biased or unbiased estimate of the variance
* @param {Number} [dim=2] - matrix dimension along which to compute the maximum. If `dim=1`, compute along matrix rows. If `dim=2`, compute along matrix columns.
* @returns {Matrix|Null} variance or null
*/
function variance( out, mat, bias, dim ) {
	var delta,
		M2,
		mu,
		x,
		M, N,
		s0, s1,
		o,
		i, j, k;

	if ( dim === 1 ) {
		// Compute along the rows...
		M = mat.shape[ 1 ];
		N = mat.shape[ 0 ];
		s0 = mat.strides[ 1 ];
		s1 = mat.strides[ 0 ];
	} else {
		// Compute along the columns...
		M = mat.shape[ 0 ];
		N = mat.shape[ 1 ];
		s0 = mat.strides[ 0 ];
		s1 = mat.strides[ 1 ];
	}
	if ( M === 0 || N === 0 ) {
		return null;
	}
	o = mat.offset;
	for ( i = 0; i < M; i++ ) {
		k = o + i*s0;
		M2 = 0;
		mu = 0;
		delta = 0;
		for ( j = 0; j < N; j++ ) {
			x = mat.data[ k + j*s1 ];
			delta = x - mu;
			mu += delta / (j+1);
			M2 += delta * ( x - mu );
		}
		if ( bias ) {
			out.data[ i ] = M2 / ( N );
		} else {
			out.data[ i ] = M2 / ( N - 1 );
		}
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{}],1126:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive'),
	isPositiveInteger = require( 'validate.io-positive-integer' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {Number} [options.dim] - dimension
* @param {String} [options.dtype] - output data type
* @param {Boolean} [options.bias=false] - boolean indicating whether to calculate a biased or unbiased estimate of the variance
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'variance()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'variance()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dim' ) ) {
		opts.dim = options.dim;
		if ( !isPositiveInteger( opts.dim ) ) {
			return new TypeError( 'variance()::invalid option. Dimension option must be a positive integer. Option: `' + opts.dim + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'variance()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'bias' ) ) {
		opts.bias = options.bias;
		if ( !isBoolean( opts.bias ) ) {
			return new TypeError( 'variance()::invalid option. Bias option must be a boolean primitive. Option: `' + opts.dim + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1179,"validate.io-function":1180,"validate.io-object":1182,"validate.io-positive-integer":1184,"validate.io-string-primitive":1187}],1127:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1128:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1127,"dup":63}],1129:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1130:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1133,"./iget.js":1135,"./iset.js":1138,"./mget.js":1142,"./mset.js":1144,"./set.js":1152,"./sget.js":1154,"./sset.js":1156,"./toString.js":1158,"dup":2}],1131:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1134,"./iget.raw.js":1136,"./iset.raw.js":1139,"./mget.raw.js":1143,"./mset.raw.js":1145,"./set.raw.js":1153,"./sget.raw.js":1155,"./sset.raw.js":1157,"./toString.js":1158,"dup":3}],1132:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1133:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1171}],1134:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1135:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1169}],1136:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1137:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1140,"./matrix.raw.js":1141,"dup":9}],1138:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1169,"validate.io-number-primitive":1174}],1139:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1140:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1129,"./ctor.js":1130,"./dtypes.js":1132,"compute-cast-arrays":1159,"compute-dtype":1162,"dup":12,"validate.io-array":1166,"validate.io-contains":1167,"validate.io-nonnegative-integer-array":1170,"validate.io-string-primitive":1187}],1141:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1129,"./ctor.raw.js":1131,"./dtypes.js":1132,"compute-dtype":1162,"dup":13,"validate.io-contains":1167,"validate.io-string-primitive":1187}],1142:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1129,"dup":14,"validate.io-nonnegative-integer-array":1170}],1143:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1129,"dup":15}],1144:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1146,"./mset2.js":1147,"./mset3.js":1148,"./mset4.js":1149,"./mset5.js":1150,"./mset6.js":1151,"dup":16,"validate.io-function":1180,"validate.io-nonnegative-integer-array":1170,"validate.io-number-primitive":1174}],1145:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1146,"./mset2.js":1147,"./mset3.js":1148,"./mset4.js":1149,"./mset5.js":1150,"./mset6.js":1151,"dup":17}],1146:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1147:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1148:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1149:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1150:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1151:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1152:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1171,"validate.io-number-primitive":1174}],1153:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1154:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1129,"compute-indexspace":585,"dup":26,"validate.io-string-primitive":1187}],1155:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1129,"compute-indexspace":585,"dup":27}],1156:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":28,"validate.io-function":1180,"validate.io-number-primitive":1174,"validate.io-string-primitive":1187}],1157:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":585,"dup":29}],1158:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1159:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1127,"compute-array-dtype/lib/dtypes":1160,"dup":31,"type-name":1161,"validate.io-array-like":1175}],1160:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1161:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1162:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1164,"dup":36,"type-name":1165}],1163:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1164:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1163,"dup":38}],1165:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1166:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1167:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1166,"validate.io-nan-primitive":1168}],1168:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1169:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1174}],1170:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1166,"validate.io-nonnegative-integer":1171}],1171:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1172}],1172:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1173}],1173:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1174:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1175:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1176,"dup":34,"validate.io-integer-primitive":1177}],1176:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1177:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1178}],1178:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1179:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1180:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1181:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1182:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1183}],1183:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1184:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":1185}],1185:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1186}],1186:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1187:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1188:[function(require,module,exports){
/**
*
*	COMPUTE: wmean
*
*
*	DESCRIPTION:
*		- Computes a weighted mean over an array of values.
*
*
*	NOTES:
*		[1] 
*
*
*	TODO:
*		[1] 
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

(function() {
	'use strict';

	/**
	* FUNCTION: wmean( arr, weights )
	*	Computes a weighted mean over an array of values.
	*
	* @param {Array} arr - array of values
	* @param {Array} weights - array of weights
	* @returns {Number} weighted mean value
	*/
	function wmean( arr, weights ) {
		if ( !Array.isArray( arr ) || !Array.isArray( weights ) ) {
			throw new TypeError( 'wmean()::invalid input argument. Must provide arrays.' );
		}
		if ( arr.length !== weights.length ) {
			throw new Error( 'wmean()::invalid input arguments. Value array and weights array must be the same length.' );
		}
		var len = arr.length,
			sum = 0,
			mu = 0,
			w;

		// Normalize the weights to sum to 1 and calculate the weighted mean...
		for ( var i = 0; i < len; i++ ) {
			sum += weights[ i ];
		}
		for ( var j = 0; j < len; j++ ) {
			w = weights[ j ] / sum;
			mu += arr[ j ] * w;
		}
		return mu;
	} // end FUNCTION wmean()


	// EXPORTS //

	module.exports = wmean;

})();
},{}],1189:[function(require,module,exports){
/**
*
*	COMPUTE: zip
*
*
*	DESCRIPTION:
*		- Generates array tuples from input arrays.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014-2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isArray = require( 'validate.io-array' ),
	isBoolean = require( 'validate.io-boolean-primitive' );


// ZIP //

/**
* FUNCTION: zip( arr1, arr2,...[, opts] )
*	Generates array tuples from input arrays.
*
* @param {...Array} arr - input arrays to be zipped
* @param {Object} [opts] - function options
* @param {Boolean} [opts.trunc=true] - boolean indicating whether to truncate arrays longer than the shortest input array
* @param {*} [opts.fill=null] - fill value used for arrays of unequal length
* @param {Boolean} [opts.arrays=false] - boolean indicating whether an input array should be interpreted as an array of arrays to be zipped
*/
function zip() {
	var args = Array.prototype.slice.call( arguments ),
		numArgs = args.length,
		opts = {},
		fill = null,
		arg,
		flg,
		len,
		out,
		arr,
		val,
		i, j;

	for ( i = 0; i < numArgs-1; i++ ) {
		if ( !isArray( args[i] ) ) {
			throw new TypeError( 'zip()::invalid input argument. Must provide array arguments. Value: `' + args[i] + '`.' );
		}
	}
	arg = args[ numArgs-1 ];
	flg = isObject( arg );
	if ( !flg && !isArray( arg ) ) {
		throw new TypeError( 'zip()::invalid input argument. Last argument must be either an array or an options object. Value: `' + arg + '`.' );
	}
	if ( flg ) {
		opts = args.pop();
	}
	numArgs = args.length;
	if ( numArgs === 0 ) {
		throw new Error( 'zip()::insufficient input arguments. Must provide at least one array.' );
	}
	if ( opts.hasOwnProperty( 'trunc' ) ) {
		if ( !isBoolean( opts.trunc ) ) {
			throw new TypeError( 'zip()::invalid option. `trunc` option must be a boolean.  Value: `' + opts.trunc + '`.' );
		}
	} else {
		opts.trunc = true;
	}
	if ( opts.hasOwnProperty( 'fill' ) ) {
		fill = opts.fill;
	}
	if ( opts.hasOwnProperty( 'arrays' ) ) {
		if ( !isBoolean( opts.arrays ) ) {
			throw new TypeError( 'zip()::invalid option. `arrays` option must be a boolean. Value: `' + opts.arrays + '`.' );
		}
	} else {
		opts.arrays = false;
	}
	if ( numArgs === 1 && opts.arrays ) {
		// Treat the lone array argument as an array of arrays to be zipped...
		args = args[ 0 ];
		numArgs = args.length;
	}
	len = args[ 0 ].length;
	if ( opts.trunc ) {
		// Find the min array length...
		for ( i = 0; i < numArgs; i++ ) {
			val = args[ i ].length;
			if ( val < len ) {
				len = val;
			}
		}
	} else {
		// Find the max array length...
		for ( i = 0; i < numArgs; i++ ) {
			val = args[ i ].length;
			if ( val > len ) {
				len = val;
			}
		}
	}
	out = new Array( len );
	for ( j = 0; j < len; j++ ) {
		// Temporary array to store tuples...
		arr = new Array( numArgs );

		// Create the tuples...
		for ( i = 0; i < numArgs; i++ ) {
			arg = args[ i ];

			// If an array is too short, use a fill value...
			if ( arg.length <= j ) {
				arr[ i ] = fill;
				continue;
			}
			arr[ i ] = arg[ j ];
		}
		out[ j ] = arr;
	}
	return out;
} // end FUNCTION zip()


// EXPORTS //

module.exports = zip;

},{"validate.io-array":1190,"validate.io-boolean-primitive":1191,"validate.io-object":1192}],1190:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1191:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1192:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1190}],1193:[function(require,module,exports){
'use strict';

// DISTRIBUTIONS //

var dist = {};

// DISCRETE DISTRIBUTIONS //

/**
* Binomial distribution.
*/

dist.binom = {};

/*
dist.binom.pmf = require( 'distributions-binomial-pmf' );
dist.binom.cdf = require( 'distributions-binomial-cdf' );
dist.binom.quantile = require( 'distributions-binomial-quantile' );
dist.binom.mgf = require( 'distributions-binomial-mgf' );

dist.binom.random = require( 'distributions-binomial-random' );

dist.binom.mean = require( 'distributions-binomial-mean' );
dist.binom.median = require( 'distributions-binomial-median' );
dist.binom.variance = require( 'distributions-binomial-variance' );
dist.binom.skewness = require( 'distributions-binomial-skewness' );
dist.binom.ekurtosis = require( 'distributions-binomial-ekurtosis' );
dist.binom.entropy = require( 'distributions-binomial-entropy' );
*/

/**
* Geometric distribution.
*/

dist.geom = {};

/*
dist.geom.pmf = require( 'distributions-geometric-pmf' );
dist.geom.cdf = require( 'distributions-geometric-cdf' );
dist.geom.quantile = require( 'distributions-geometric-quantile' );
dist.geom.mgf = require( 'distributions-geometric-mgf' );

dist.geom.random = require( 'distributions-geometric-random' );

dist.geom.mean = require( 'distributions-geometric-mean' );
dist.geom.median = require( 'distributions-geometric-median' );
dist.geom.variance = require( 'distributions-geometric-variance' );
dist.geom.skewness = require( 'distributions-geometric-skewness' );
dist.geom.ekurtosis = require( 'distributions-geometric-ekurtosis' );
dist.geom.entropy = require( 'distributions-geometric-entropy' );
*/

/**
* Hypergeometric distribution.
*/

dist.hypergeom = {};

/*
dist.hypergeom.pmf = require( 'distributions-hypergeometric-pmf' );
dist.hypergeom.cdf = require( 'distributions-hypergeometric-cdf' );
dist.hypergeom.quantile = require( 'distributions-hypergeometric-quantile' );
dist.hypergeom.mgf = require( 'distributions-hypergeometric-mgf' );

dist.hypergeom.random = require( 'distributions-hypergeometric-random' );

dist.hypergeom.mean = require( 'distributions-hypergeometric-mean' );
dist.hypergeom.median = require( 'distributions-hypergeometric-median' );
dist.hypergeom.variance = require( 'distributions-hypergeometric-variance' );
dist.hypergeom.skewness = require( 'distributions-hypergeometric-skewness' );
dist.hypergeom.ekurtosis = require( 'distributions-hypergeometric-ekurtosis' );
dist.hypergeom.entropy = require( 'distributions-hypergeometric-entropy' );
*/

/**
* Negative binomial distribution.
*/

dist.nbinom = {};

/*
dist.nbinom.pmf = require( 'distributions-negative-binomial-pmf' );
dist.nbinom.cdf = require( 'distributions-negative-binomial-cdf' );
dist.nbinom.quantile = require( 'distributions-negative-binomial-quantile' );
dist.nbinom.mgf = require( 'distributions-negative-binomial-mgf' );

dist.nbinom.random = require( 'distributions-negative-binomial-random' );

dist.nbinom.mean = require( 'distributions-negative-binomial-mean' );
dist.nbinom.median = require( 'distributions-negative-binomial-median' );
dist.nbinom.variance = require( 'distributions-negative-binomial-variance' );
dist.nbinom.skewness = require( 'distributions-negative-binomial-skewness' );
dist.nbinom.ekurtosis = require( 'distributions-negative-binomial-ekurtosis' );
dist.nbinom.entropy = require( 'distributions-negative-binomial-entropy' );
*/

/**
* Poisson distribution.
*/

dist.poisson = {};

/*
dist.poisson.pmf = require( 'distributions-poisson-pmf' );
dist.poisson.cdf = require( 'distributions-poisson-cdf' );
dist.poisson.quantile = require( 'distributions-poisson-quantile' );
dist.poisson.mgf = require( 'distributions-poisson-mgf' );

dist.poisson.random = require( 'distributions-poisson-random' );
*/
dist.poisson.mean = require( 'distributions-poisson-mean' );
dist.poisson.median = require( 'distributions-poisson-median' );
dist.poisson.variance = require( 'distributions-poisson-variance' );
// dist.poisson.skewness = require( 'distributions-poisson-skewness' );
dist.poisson.ekurtosis = require( 'distributions-poisson-ekurtosis' );
// dist.poisson.entropy = require( 'distributions-poisson-entropy' );


// CONTINUOUS DISTRIBUTIONS //

/**
* Beta distribution.
*/

dist.beta = {};

/*
dist.beta.pdf = require( 'distributions-beta-pdf' );
dist.beta.cdf = require( 'distributions-beta-cdf' );
dist.beta.quantile = require( 'distributions-beta-quantile' );
dist.beta.mgf = require( 'distributions-beta-mgf' );

dist.beta.random = require( 'distributions-beta-random' );

dist.beta.mean = require( 'distributions-beta-mean' );
dist.beta.median = require( 'distributions-beta-median' );
dist.beta.variance = require( 'distributions-beta-variance' );
dist.beta.skewness = require( 'distributions-beta-skewness' );
dist.beta.ekurtosis = require( 'distributions-beta-ekurtosis' );
dist.beta.entropy = require( 'distributions-beta-entropy' );
*/

/**
* Cauchy distribution.
*/

dist.cauchy = {};

/*
dist.cauchy.pdf = require( 'distributions-cauchy-pdf' );
dist.cauchy.cdf = require( 'distributions-cauchy-cdf' );
dist.cauchy.quantile = require( 'distributions-cauchy-quantile' );

dist.cauchy.random = require( 'distributions-cauchy-random' );

dist.cauchy.median = require( 'distributions-cauchy-median' );
dist.cauchy.entropy = require( 'distributions-cauchy-entropy' );
*/

/**
* Chi-squared distribution.
*/

dist.chisq = {};

/*
dist.chisq.pdf = require( 'distributions-chisquare-pdf' );
dist.chisq.cdf = require( 'distributions-chisquare-cdf' );
dist.chisq.quantile = require( 'distributions-chisquare-quantile' );
dist.chisq.mgf = require( 'distributions-chisquare-mgf' );

dist.chisq.random = require( 'distributions-chisquare-random' );

dist.chisq.mean = require( 'distributions-chisquare-mean' );
dist.chisq.median = require( 'distributions-chisquare-median' );
dist.chisq.variance = require( 'distributions-chisquare-variance' );
dist.chisq.skewness = require( 'distributions-chisquare-skewness' );
dist.chisq.ekurtosis = require( 'distributions-chisquare-ekurtosis' );
dist.chisq.entropy = require( 'distributions-chisquare-entropy' );
*/

/**
* Erlang distribution.
*/

dist.erlang = {};

/*
dist.erlang.pdf = require( 'distributions-erlang-pdf' );
dist.erlang.cdf = require( 'distributions-erlang-cdf' );
dist.erlang.quantile = require( 'distributions-erlang-quantile' );
dist.erlang.mgf = require( 'distributions-erlang-mgf' );

dist.erlang.random = require( 'distributions-erlang-random' );

dist.erlang.mean = require( 'distributions-erlang-mean' );
dist.erlang.median = require( 'distributions-erlang-median' );
dist.erlang.variance = require( 'distributions-erlang-variance' );
dist.erlang.skewness = require( 'distributions-erlang-skewness' );
dist.erlang.ekurtosis = require( 'distributions-erlang-ekurtosis' );
dist.erlang.entropy = require( 'distributions-erlang-entropy' );
*/

/**
* Exponential distribution.
*/

dist.exp = {};

dist.exp.pdf = require( 'distributions-exponential-pdf' );
dist.exp.cdf = require( 'distributions-exponential-cdf' );
dist.exp.quantile = require( 'distributions-exponential-quantile' );
dist.exp.mgf = require( 'distributions-exponential-mgf' );

// dist.exp.random = require( 'distributions-exponential-random' );

dist.exp.mean = require( 'distributions-exponential-mean' );
dist.exp.median = require( 'distributions-exponential-median' );
dist.exp.variance = require( 'distributions-exponential-variance' );
dist.exp.skewness = require( 'distributions-exponential-skewness' );
dist.exp.ekurtosis = require( 'distributions-exponential-ekurtosis' );
// dist.exp.entropy = require( 'distributions-exponential-entropy' );

/**
* F distribution.
*/

dist.f = {};

/*
dist.f.pdf = require( 'distributions-f-pdf' );
dist.f.cdf = require( 'distributions-f-cdf' );
dist.f.quantile = require( 'distributions-f-quantile' );

dist.f.random = require( 'distributions-f-random' );

dist.f.mean = require( 'distributions-f-mean' );
dist.f.median = require( 'distributions-f-median' );
dist.f.variance = require( 'distributions-f-variance' );
dist.f.skewness = require( 'distributions-f-skewness' );
dist.f.ekurtosis = require( 'distributions-f-ekurtosis' );
dist.f.entropy = require( 'distributions-f-entropy' );
*/

/**
* Gamma distribution.
*/

dist.gamma = {};

/*
dist.gamma.pdf = require( 'distributions-gamma-pdf' );
dist.gamma.cdf = require( 'distributions-gamma-cdf' );
dist.gamma.quantile = require( 'distributions-gamma-quantile' );
dist.gamma.mgf = require( 'distributions-gamma-mgf' );

dist.gamma.random = require( 'distributions-gamma-random' );

dist.gamma.mean = require( 'distributions-gamma-mean' );
dist.gamma.median = require( 'distributions-gamma-median' );
dist.gamma.variance = require( 'distributions-gamma-variance' );
dist.gamma.skewness = require( 'distributions-gamma-skewness' );
dist.gamma.ekurtosis = require( 'distributions-gamma-ekurtosis' );
dist.gamma.entropy = require( 'distributions-gamma-entropy' );
*/

/**
* Gumbel distribution.
*/

dist.gumbel = {};

/*
dist.gumbel.pdf = require( 'distributions-gumbel-pdf' );
dist.gumbel.cdf = require( 'distributions-gumbel-cdf' );
dist.gumbel.quantile = require( 'distributions-gumbel-quantile' );
dist.gumbel.mgf = require( 'distributions-gumbel-mgf' );

dist.gumbel.random = require( 'distributions-gumbel-random' );

dist.gumbel.mean = require( 'distributions-gumbel-mean' );
dist.gumbel.median = require( 'distributions-gumbel-median' );
dist.gumbel.variance = require( 'distributions-gumbel-variance' );
dist.gumbel.skewness = require( 'distributions-gumbel-skewness' );
dist.gumbel.ekurtosis = require( 'distributions-gumbel-ekurtosis' );
dist.gumbel.entropy = require( 'distributions-gumbel-entropy' );
*/

/**
* Inverse-Gamma distribution.
*/

dist.invgamma = {};

/*
dist.invgamma.pdf = require( 'distributions-invgamma-pdf' );
dist.invgamma.cdf = require( 'distributions-invgamma-cdf' );
dist.invgamma.quantile = require( 'distributions-invgamma-quantile' );
dist.invgamma.mgf = require( 'distributions-invgamma-mgf' );

dist.invgamma.random = require( 'distributions-invgamma-random' );

dist.invgamma.mean = require( 'distributions-invgamma-mean' );
dist.invgamma.median = require( 'distributions-invgamma-median' );
dist.invgamma.variance = require( 'distributions-invgamma-variance' );
dist.invgamma.skewness = require( 'distributions-invgamma-skewness' );
dist.invgamma.ekurtosis = require( 'distributions-invgamma-ekurtosis' );
dist.invgamma.entropy = require( 'distributions-invgamma-entropy' );
*/

/**
* Laplace distribution.
*/

dist.laplace = {};

/*
dist.laplace.pdf = require( 'distributions-laplace-pdf' );
dist.laplace.cdf = require( 'distributions-laplace-cdf' );
dist.laplace.quantile = require( 'distributions-laplace-quantile' );
dist.laplace.mgf = require( 'distributions-laplace-mgf' );

dist.laplace.random = require( 'distributions-laplace-random' );

dist.laplace.mean = require( 'distributions-laplace-mean' );
dist.laplace.median = require( 'distributions-laplace-median' );
dist.laplace.variance = require( 'distributions-laplace-variance' );
dist.laplace.skewness = require( 'distributions-laplace-skewness' );
dist.laplace.ekurtosis = require( 'distributions-laplace-ekurtosis' );
dist.laplace.entropy = require( 'distributions-laplace-entropy' );
*/

/**
* Logistic distribution.
*/

dist.logistic = {};

/*
dist.logistic.pdf = require( 'distributions-logistic-pdf' );
dist.logistic.cdf = require( 'distributions-logistic-cdf' );
dist.logistic.quantile = require( 'distributions-logistic-quantile' );
dist.logistic.mgf = require( 'distributions-logistic-mgf' );

dist.logistic.random = require( 'distributions-logistic-random' );

dist.logistic.mean = require( 'distributions-logistic-mean' );
dist.logistic.median = require( 'distributions-logistic-median' );
dist.logistic.variance = require( 'distributions-logistic-variance' );
dist.logistic.skewness = require( 'distributions-logistic-skewness' );
dist.logistic.ekurtosis = require( 'distributions-logistic-ekurtosis' );
dist.logistic.entropy = require( 'distributions-logistic-entropy' );
*/

/**
* Lognormal distribution.
*/

dist.lnorm = {};

/*
dist.lnorm.pdf = require( 'distributions-lognormal-pdf' );
dist.lnorm.cdf = require( 'distributions-lognormal-cdf' );
dist.lnorm.quantile = require( 'distributions-lognormal-quantile' );
dist.lnorm.mgf = require( 'distributions-lognormal-mgf' );

dist.lnorm.random = require( 'distributions-lognormal-random' );

dist.lnorm.mean = require( 'distributions-lognormal-mean' );
dist.lnorm.median = require( 'distributions-lognormal-median' );
dist.lnorm.variance = require( 'distributions-lognormal-variance' );
dist.lnorm.skewness = require( 'distributions-lognormal-skewness' );
dist.lnorm.ekurtosis = require( 'distributions-lognormal-ekurtosis' );
dist.lnorm.entropy = require( 'distributions-lognormal-entropy' );
*/

/**
* Rayleigh distribution.
*/

dist.rayleigh = {};

dist.rayleigh.pdf = require( 'distributions-rayleigh-pdf' );
dist.rayleigh.cdf = require( 'distributions-rayleigh-cdf' );
dist.rayleigh.quantile = require( 'distributions-rayleigh-quantile' );
// dist.rayleigh.mgf = require( 'distributions-rayleigh-mgf' );

// dist.rayleigh.random = require( 'distributions-rayleigh-random' );

dist.rayleigh.mean = require( 'distributions-rayleigh-mean' );
dist.rayleigh.median = require( 'distributions-rayleigh-median' );
dist.rayleigh.variance = require( 'distributions-rayleigh-variance' );
dist.rayleigh.skewness = require( 'distributions-rayleigh-skewness' );
dist.rayleigh.ekurtosis = require( 'distributions-rayleigh-ekurtosis' );
dist.rayleigh.entropy = require( 'distributions-rayleigh-entropy' );

/**
* Student's t distribution.
*/

dist.t = {};

dist.t.pdf = require( 'distributions-t-pdf' );
/*
dist.t.cdf = require( 'distributions-t-cdf' );
dist.t.quantile = require( 'distributions-t-quantile' );

dist.t.random = require( 'distributions-t-random' );

dist.t.mean = require( 'distributions-t-mean' );
dist.t.median = require( 'distributions-t-median' );
dist.t.variance = require( 'distributions-t-variance' );
dist.t.skewness = require( 'distributions-t-skewness' );
dist.t.ekurtosis = require( 'distributions-t-ekurtosis' );
dist.t.entropy = require( 'distributions-t-entropy' );
*/

/**
* Uniform distribution.
*/

dist.unif = {};

/*
dist.unif.pdf = require( 'distributions-uniform-pdf' );
dist.unif.cdf = require( 'distributions-uniform-cdf' );
dist.unif.quantile = require( 'distributions-uniform-quantile' );
dist.unif.mgf = require( 'distributions-uniform-mgf' );

dist.unif.random = require( 'distributions-uniform-random' );

dist.unif.mean = require( 'distributions-uniform-mean' );
dist.unif.median = require( 'distributions-uniform-median' );
dist.unif.variance = require( 'distributions-uniform-variance' );
dist.unif.skewness = require( 'distributions-uniform-skewness' );
dist.unif.ekurtosis = require( 'distributions-uniform-ekurtosis' );
dist.unif.entropy = require( 'distributions-uniform-entropy' );
*/

/**
* Normal distribution.
*/

dist.norm = {};

dist.norm.pdf = require( 'distributions-normal-pdf' );
dist.norm.cdf = require( 'distributions-normal-cdf' );
dist.norm.quantile = require( 'distributions-normal-quantile' );
// dist.norm.mgf = require( 'distributions-normal-mgf' );

dist.norm.random = require( 'distributions-normal-random' );

/*
dist.norm.mean = require( 'distributions-normal-mean' );
dist.norm.median = require( 'distributions-normal-median' );
dist.norm.variance = require( 'distributions-normal-variance' );
dist.norm.skewness = require( 'distributions-normal-skewness' );
dist.norm.ekurtosis = require( 'distributions-normal-ekurtosis' );
dist.norm.entropy = require( 'distributions-normal-entropy' );
*/

/**
* Pareto (Type 1) distribution.
*/

dist.pareto = {};

/*
dist.pareto.pdf = require( 'distributions-pareto-type1-pdf' );
dist.pareto.cdf = require( 'distributions-pareto-type1-cdf' );
dist.pareto.quantile = require( 'distributions-pareto-type1-quantile' );
dist.pareto.mgf = require( 'distributions-pareto-type1-mgf' );

dist.pareto.random = require( 'distributions-pareto-type1-random' );

dist.pareto.mean = require( 'distributions-pareto-type1-mean' );
dist.pareto.median = require( 'distributions-pareto-type1-median' );
dist.pareto.variance = require( 'distributions-pareto-type1-variance' );
dist.pareto.skewness = require( 'distributions-pareto-type1-skewness' );
dist.pareto.ekurtosis = require( 'distributions-pareto-type1-ekurtosis' );
dist.pareto.entropy = require( 'distributions-pareto-type1-entropy' );
*/

/**
* Triangular distribution.
*/

dist.triangular = {};

/*
dist.triangular.pdf = require( 'distributions-triangular-pdf' );
dist.triangular.cdf = require( 'distributions-triangular-cdf' );
dist.triangular.quantile = require( 'distributions-triangular-quantile' );
dist.triangular.mgf = require( 'distributions-triangular-mgf' );

dist.triangular.random = require( 'distributions-triangular-random' );

dist.triangular.mean = require( 'distributions-triangular-mean' );
dist.triangular.median = require( 'distributions-triangular-median' );
dist.triangular.variance = require( 'distributions-triangular-variance' );
dist.triangular.skewness = require( 'distributions-triangular-skewness' );
dist.triangular.ekurtosis = require( 'distributions-triangular-ekurtosis' );
dist.triangular.entropy = require( 'distributions-triangular-entropy' );
*/

/**
* Weibull distribution.
*/

dist.weibull = {};

/*
dist.weibull.pdf = require( 'distributions-weibull-pdf' );
dist.weibull.cdf = require( 'distributions-weibull-cdf' );
dist.weibull.quantile = require( 'distributions-weibull-quantile' );
dist.weibull.mgf = require( 'distributions-weibull-mgf' );

dist.weibull.random = require( 'distributions-weibull-random' );

dist.weibull.mean = require( 'distributions-weibull-mean' );
dist.weibull.median = require( 'distributions-weibull-median' );
dist.weibull.variance = require( 'distributions-weibull-variance' );
dist.weibull.skewness = require( 'distributions-weibull-skewness' );
dist.weibull.ekurtosis = require( 'distributions-weibull-ekurtosis' );
dist.weibull.entropy = require( 'distributions-weibull-entropy' );
*/

// EXPORTS //

module.exports = dist;

},{"distributions-exponential-cdf":1197,"distributions-exponential-ekurtosis":1280,"distributions-exponential-mean":1363,"distributions-exponential-median":1446,"distributions-exponential-mgf":1529,"distributions-exponential-pdf":1612,"distributions-exponential-quantile":1696,"distributions-exponential-skewness":1779,"distributions-exponential-variance":1862,"distributions-normal-cdf":1945,"distributions-normal-pdf":2030,"distributions-normal-quantile":2114,"distributions-normal-random":2202,"distributions-poisson-ekurtosis":2275,"distributions-poisson-mean":2358,"distributions-poisson-median":2441,"distributions-poisson-variance":2524,"distributions-rayleigh-cdf":2607,"distributions-rayleigh-ekurtosis":2690,"distributions-rayleigh-entropy":2773,"distributions-rayleigh-mean":2857,"distributions-rayleigh-median":2940,"distributions-rayleigh-pdf":3023,"distributions-rayleigh-quantile":3106,"distributions-rayleigh-skewness":3189,"distributions-rayleigh-variance":3272,"distributions-t-pdf":3355}],1194:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, lambda, accessor )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, lambda, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1200}],1195:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, lambda )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1200}],1196:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( arr, lambda, path[, sep] )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function cdf( x, lambda, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( lambda );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1200,"utils-deep-get":1251,"utils-deep-set":1257}],1197:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var cdf1 = require( './number.js' ),
	cdf2 = require( './array.js' ),
	cdf3 = require( './accessor.js' ),
	cdf4 = require( './deepset.js' ),
	cdf5 = require( './matrix.js' ),
	cdf6 = require( './typedarray.js' );


// CDF //

/**
* FUNCTION: cdf( x[, opts] )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.lambda=1] - rate parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated CDF
*/
function cdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.lambda = typeof opts.lambda !== 'undefined' ? opts.lambda : 1;

	if ( isNumber( x ) ) {
		return cdf1( x, opts.lambda );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return cdf5( out, x, opts.lambda );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return cdf6( out, x, opts.lambda );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return cdf4( x, opts.lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return cdf3( out, x, opts.lambda, opts.accessor );
		}
		return cdf2( out, x, opts.lambda );
	}
	return NaN;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./accessor.js":1194,"./array.js":1195,"./deepset.js":1196,"./matrix.js":1198,"./number.js":1199,"./typedarray.js":1201,"./validate.js":1202,"compute-array-constructors":1204,"dstructs-matrix":1213,"validate.io-array-like":1260,"validate.io-matrix-like":1265,"validate.io-number-primitive":1269,"validate.io-typed-array-like":1274}],1198:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, matrix, lambda )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} lambda - rate parameter
* @returns {Matrix} output matrix
*/
function cdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'cdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1200}],1199:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp;


// CDF //

/**
* FUNCTION: cdf( x, lambda )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} lambda - rate parameter
* @returns {Number} evaluated CDF
*/
function cdf( x, lambda ) {
	if ( x < 0 ) {
		return 0;
	} else {
		return 1 - exp( - lambda * x );
	}
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{}],1200:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp;


// PARTIAL //

/**
* FUNCTION: partial( lambda )
*	Partially applies rate parameter `lambda` and returns a function for evaluating the cumulative distribution function (CDF) for an exponential distribution.
*
* @param {Number} lambda - rate parameter
* @returns {Function} CDF
*/
function partial( lambda ) {

	/**
	* FUNCTION: cdf( x )
	*	Evaluates the cumulative distribution function (CDF) for an exponential distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated CDF
	*/
	return function cdf( x ) {
		if ( x < 0 ) {
			return 0;
		} else {
			return 1 - exp( - lambda * x );
		}
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],1201:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, lambda )
*	Evaluates the cumulative distribution function (CDF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( lambda );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1200}],1202:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.lambda] - rate parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'cdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'lambda' ) ) {
		opts.lambda = options.lambda;
		if ( !isPositive( opts.lambda ) ) {
			return new TypeError( 'cdf()::invalid option. Rate parameter `lambda` must be a positive number. Option: `' + opts.lambda + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'cdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'cdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'cdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'cdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'cdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1263,"validate.io-function":1264,"validate.io-object":1270,"validate.io-positive-primitive":1272,"validate.io-string-primitive":1273}],1203:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1204:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1203,"dup":63}],1205:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1206:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1209,"./iget.js":1211,"./iset.js":1214,"./mget.js":1218,"./mset.js":1220,"./set.js":1228,"./sget.js":1230,"./sset.js":1232,"./toString.js":1234,"dup":2}],1207:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1210,"./iget.raw.js":1212,"./iset.raw.js":1215,"./mget.raw.js":1219,"./mset.raw.js":1221,"./set.raw.js":1229,"./sget.raw.js":1231,"./sset.raw.js":1233,"./toString.js":1234,"dup":3}],1208:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1209:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1266}],1210:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1211:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1246}],1212:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1213:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1216,"./matrix.raw.js":1217,"dup":9}],1214:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1246,"validate.io-number-primitive":1269}],1215:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1216:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1205,"./ctor.js":1206,"./dtypes.js":1208,"compute-cast-arrays":1235,"compute-dtype":1238,"dup":12,"validate.io-array":1243,"validate.io-contains":1244,"validate.io-nonnegative-integer-array":1247,"validate.io-string-primitive":1273}],1217:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1205,"./ctor.raw.js":1207,"./dtypes.js":1208,"compute-dtype":1238,"dup":13,"validate.io-contains":1244,"validate.io-string-primitive":1273}],1218:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1205,"dup":14,"validate.io-nonnegative-integer-array":1247}],1219:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1205,"dup":15}],1220:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1222,"./mset2.js":1223,"./mset3.js":1224,"./mset4.js":1225,"./mset5.js":1226,"./mset6.js":1227,"dup":16,"validate.io-function":1264,"validate.io-nonnegative-integer-array":1247,"validate.io-number-primitive":1269}],1221:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1222,"./mset2.js":1223,"./mset3.js":1224,"./mset4.js":1225,"./mset5.js":1226,"./mset6.js":1227,"dup":17}],1222:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1223:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1224:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1225:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1226:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1227:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1228:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1266,"validate.io-number-primitive":1269}],1229:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1230:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1205,"compute-indexspace":1242,"dup":26,"validate.io-string-primitive":1273}],1231:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1205,"compute-indexspace":1242,"dup":27}],1232:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1242,"dup":28,"validate.io-function":1264,"validate.io-number-primitive":1269,"validate.io-string-primitive":1273}],1233:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1242,"dup":29}],1234:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1235:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1203,"compute-array-dtype/lib/dtypes":1236,"dup":31,"type-name":1237,"validate.io-array-like":1260}],1236:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1237:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1238:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1240,"dup":36,"type-name":1241}],1239:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1240:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1239,"dup":38}],1241:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1242:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1266,"validate.io-string-primitive":1273}],1243:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1244:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1243,"validate.io-nan-primitive":1245}],1245:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1246:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1269}],1247:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1243,"validate.io-nonnegative-integer":1266}],1248:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1249:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1250:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1248,"./defaults.js":1249,"./validate.js":1252,"dup":111,"validate.io-array":1253,"validate.io-string-primitive":1273}],1251:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1248,"./defaults.js":1249,"./factory.js":1250,"./validate.js":1252,"dup":112,"validate.io-array":1253,"validate.io-string-primitive":1273}],1252:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1270,"validate.io-string-primitive":1273}],1253:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1254:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1255:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1256:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1254,"./defaults.js":1255,"./validate.js":1258,"dup":117,"validate.io-array":1259,"validate.io-string-primitive":1273}],1257:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1254,"./defaults.js":1255,"./factory.js":1256,"./validate.js":1258,"dup":118,"validate.io-array":1259,"validate.io-string-primitive":1273}],1258:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1263,"validate.io-object":1270,"validate.io-string-primitive":1273}],1259:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1260:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1261,"dup":34,"validate.io-integer-primitive":1262}],1261:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1262:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1269}],1263:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1264:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1265:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1266:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1267}],1267:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1268}],1268:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1269:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1270:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1271}],1271:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1272:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' );


// IS POSITIVE //

/**
* FUNCTION: isPositive( value )
*	Validates if a value is a positive number primitive.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a positive number primitive
*/
function isPositive( value ) {
	return isNumber( value ) && value > 0;
} // end FUNCTION isPositive()


// EXPORTS //

module.exports = isPositive;

},{"validate.io-number-primitive":1269}],1273:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1274:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1275,"dup":132,"validate.io-integer-primitive":1276}],1275:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1276:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1269}],1277:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, arr, accessor )
*	Computes the distribution ekurtosis for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function ekurtosis( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = EKURTOSIS( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":1282}],1278:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, lambda )
*	Computes the distribution ekurtosis for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function ekurtosis( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = EKURTOSIS( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":1282}],1279:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	EKURTOSIS  = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( arr, path[, sep] )
*	Computes the distribution ekurtosis and deep sets the input array.
*
* @param {Array} arrays - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function ekurtosis( arr, path, sep ) {
	var len = arr.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( arr[ i ] );
			if ( typeof v === 'number' ) {
				dset( arr[i], EKURTOSIS ( v ) );
			} else {
				dset( arr[i], NaN );
			}
		}
	}
	return arr;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":1282,"utils-deep-get":1333,"utils-deep-set":1339}],1280:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var ekurtosis1 = require( './number.js' ),
	ekurtosis2 = require( './array.js' ),
	ekurtosis3 = require( './accessor.js' ),
	ekurtosis4 = require( './deepset.js' ),
	ekurtosis5 = require( './matrix.js' ),
	ekurtosis6 = require( './typedarray.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( lambda[, opts] )
*	Computes the distribution ekurtosis.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} lambda - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution ekurtosis(s)
*/
function ekurtosis( lambda, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( lambda ) || isnan( lambda ) ) {
		return ekurtosis1( lambda );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( lambda ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( lambda.length );
			out = matrix( d, lambda.shape, dt );
		} else {
			out = lambda;
		}
		return ekurtosis5( out, lambda );
	}
	if ( isTypedArrayLike( lambda ) ) {
		if ( opts.copy === false ) {
			out = lambda;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( lambda.length );
		}
		return ekurtosis6( out, lambda );
	}
	if ( isArrayLike( lambda ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return ekurtosis4( lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = lambda;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( lambda.length );
		}
		else {
			out = new Array( lambda.length );
		}
		if ( opts.accessor ) {
			return ekurtosis3( out, lambda, opts.accessor );
		}
		return ekurtosis2( out, lambda );
	}
	return NaN;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./accessor.js":1277,"./array.js":1278,"./deepset.js":1279,"./matrix.js":1281,"./number.js":1282,"./typedarray.js":1283,"./validate.js":1284,"compute-array-constructors":1286,"dstructs-matrix":1295,"validate.io-array-like":1342,"validate.io-matrix-like":1347,"validate.io-nan":1348,"validate.io-number-primitive":1352,"validate.io-typed-array-like":1357}],1281:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, x )
*	Computes the distribution ekurtosis for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function ekurtosis( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'ekurtosis()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = EKURTOSIS( x.data[ i ] );
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":1282}],1282:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// EKURTOSIS //

/**
* FUNCTION ekurtosis( lambda )
*	Computes the distribution ekurtosis for a exponential distribution with parameter lambda.
*
* @param {Number} lambda - rate parameter
* @returns {Number} distribution ekurtosis
*/
function ekurtosis( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return 6;
} // end FUNCTION ekurtosis()


// EXPORTS

module.exports =  ekurtosis;

},{"validate.io-positive-primitive":1355}],1283:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, lambda )
*	Computes the distribution ekurtosis for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function ekurtosis( out, lambda ) {
	var len = lambda.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = EKURTOSIS( lambda[ i ] );
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":1282}],1284:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'ekurtosis()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'ekurtosis()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'ekurtosis()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'ekurtosis()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'ekurtosis()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'ekurtosis()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1345,"validate.io-function":1346,"validate.io-object":1353,"validate.io-string-primitive":1356}],1285:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1286:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1285,"dup":63}],1287:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1288:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1291,"./iget.js":1293,"./iset.js":1296,"./mget.js":1300,"./mset.js":1302,"./set.js":1310,"./sget.js":1312,"./sset.js":1314,"./toString.js":1316,"dup":2}],1289:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1292,"./iget.raw.js":1294,"./iset.raw.js":1297,"./mget.raw.js":1301,"./mset.raw.js":1303,"./set.raw.js":1311,"./sget.raw.js":1313,"./sset.raw.js":1315,"./toString.js":1316,"dup":3}],1290:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1291:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1349}],1292:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1293:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1328}],1294:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1295:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1298,"./matrix.raw.js":1299,"dup":9}],1296:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1328,"validate.io-number-primitive":1352}],1297:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1298:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1287,"./ctor.js":1288,"./dtypes.js":1290,"compute-cast-arrays":1317,"compute-dtype":1320,"dup":12,"validate.io-array":1325,"validate.io-contains":1326,"validate.io-nonnegative-integer-array":1329,"validate.io-string-primitive":1356}],1299:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1287,"./ctor.raw.js":1289,"./dtypes.js":1290,"compute-dtype":1320,"dup":13,"validate.io-contains":1326,"validate.io-string-primitive":1356}],1300:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1287,"dup":14,"validate.io-nonnegative-integer-array":1329}],1301:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1287,"dup":15}],1302:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1304,"./mset2.js":1305,"./mset3.js":1306,"./mset4.js":1307,"./mset5.js":1308,"./mset6.js":1309,"dup":16,"validate.io-function":1346,"validate.io-nonnegative-integer-array":1329,"validate.io-number-primitive":1352}],1303:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1304,"./mset2.js":1305,"./mset3.js":1306,"./mset4.js":1307,"./mset5.js":1308,"./mset6.js":1309,"dup":17}],1304:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1305:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1306:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1307:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1308:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1309:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1310:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1349,"validate.io-number-primitive":1352}],1311:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1312:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1287,"compute-indexspace":1324,"dup":26,"validate.io-string-primitive":1356}],1313:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1287,"compute-indexspace":1324,"dup":27}],1314:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1324,"dup":28,"validate.io-function":1346,"validate.io-number-primitive":1352,"validate.io-string-primitive":1356}],1315:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1324,"dup":29}],1316:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1317:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1285,"compute-array-dtype/lib/dtypes":1318,"dup":31,"type-name":1319,"validate.io-array-like":1342}],1318:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1319:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1320:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1322,"dup":36,"type-name":1323}],1321:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1322:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1321,"dup":38}],1323:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1324:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1349,"validate.io-string-primitive":1356}],1325:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1326:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1325,"validate.io-nan-primitive":1327}],1327:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1328:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1352}],1329:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1325,"validate.io-nonnegative-integer":1349}],1330:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1331:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1332:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1330,"./defaults.js":1331,"./validate.js":1334,"dup":111,"validate.io-array":1335,"validate.io-string-primitive":1356}],1333:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1330,"./defaults.js":1331,"./factory.js":1332,"./validate.js":1334,"dup":112,"validate.io-array":1335,"validate.io-string-primitive":1356}],1334:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1353,"validate.io-string-primitive":1356}],1335:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1336:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1337:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1338:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1336,"./defaults.js":1337,"./validate.js":1340,"dup":117,"validate.io-array":1341,"validate.io-string-primitive":1356}],1339:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1336,"./defaults.js":1337,"./factory.js":1338,"./validate.js":1340,"dup":118,"validate.io-array":1341,"validate.io-string-primitive":1356}],1340:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1345,"validate.io-object":1353,"validate.io-string-primitive":1356}],1341:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1342:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1343,"dup":34,"validate.io-integer-primitive":1344}],1343:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1344:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1352}],1345:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1346:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1347:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1348:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1349:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1350}],1350:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1351}],1351:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1352:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1353:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1354}],1354:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1355:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1352}],1356:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1357:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1358,"dup":132,"validate.io-integer-primitive":1359}],1358:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1359:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1352}],1360:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, lambda, accessor )
*	Computes the distribution mean for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = MEAN( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":1365}],1361:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, lambda )
*	Computes the distribution mean for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = MEAN( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":1365}],1362:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	MEAN  = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( lambda, path[, sep] )
*	Computes the distribution mean and deep sets the input array.
*
* @param {Array} lambda - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function mean( lambda, path, sep ) {
	var len = lambda.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( lambda[ i ] );
			if ( typeof v === 'number' ) {
				dset( lambda[i], MEAN ( v ) );
			} else {
				dset( lambda[i], NaN );
			}
		}
	}
	return lambda;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":1365,"utils-deep-get":1416,"utils-deep-set":1422}],1363:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var mean1 = require( './number.js' ),
	mean2 = require( './array.js' ),
	mean3 = require( './accessor.js' ),
	mean4 = require( './deepset.js' ),
	mean5 = require( './matrix.js' ),
	mean6 = require( './typedarray.js' );


// MEAN //

/**
* FUNCTION: mean( lambda[, opts] )
*	Computes the distribution mean.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} lambda - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution mean(s)
*/
function mean( lambda, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( lambda ) || isnan( lambda ) ) {
		return mean1( lambda );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( lambda ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( lambda.length );
			out = matrix( d, lambda.shape, dt );
		} else {
			out = lambda;
		}
		return mean5( out, lambda );
	}
	if ( isTypedArrayLike( lambda ) ) {
		if ( opts.copy === false ) {
			out = lambda;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( lambda.length );
		}
		return mean6( out, lambda );
	}
	if ( isArrayLike( lambda ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return mean4( lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = lambda;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( lambda.length );
		}
		else {
			out = new Array( lambda.length );
		}
		if ( opts.accessor ) {
			return mean3( out, lambda, opts.accessor );
		}
		return mean2( out, lambda );
	}
	return NaN;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./accessor.js":1360,"./array.js":1361,"./deepset.js":1362,"./matrix.js":1364,"./number.js":1365,"./typedarray.js":1366,"./validate.js":1367,"compute-array-constructors":1369,"dstructs-matrix":1378,"validate.io-array-like":1425,"validate.io-matrix-like":1430,"validate.io-nan":1431,"validate.io-number-primitive":1435,"validate.io-typed-array-like":1440}],1364:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, x )
*	Computes the distribution mean for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function mean( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'mean()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = MEAN( x.data[ i ] );
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":1365}],1365:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// MEAN //

/**
* FUNCTION mean( lambda )
*	Computes the distribution mean for a Exponential with parameter lambda.
*
* @param {Number} lambda - rate parameter
* @returns {Number} distribution mean
*/
function mean( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return 1 / lambda;
} // end FUNCTION mean()


// EXPORTS

module.exports =  mean;

},{"validate.io-positive-primitive":1438}],1366:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, lambda )
*	Computes the distribution mean for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, lambda ) {
	var len = lambda.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = MEAN( lambda[ i ] );
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":1365}],1367:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'mean()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'mean()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'mean()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'mean()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'mean()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'mean()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1428,"validate.io-function":1429,"validate.io-object":1436,"validate.io-string-primitive":1439}],1368:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1369:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1368,"dup":63}],1370:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1371:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1374,"./iget.js":1376,"./iset.js":1379,"./mget.js":1383,"./mset.js":1385,"./set.js":1393,"./sget.js":1395,"./sset.js":1397,"./toString.js":1399,"dup":2}],1372:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1375,"./iget.raw.js":1377,"./iset.raw.js":1380,"./mget.raw.js":1384,"./mset.raw.js":1386,"./set.raw.js":1394,"./sget.raw.js":1396,"./sset.raw.js":1398,"./toString.js":1399,"dup":3}],1373:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1374:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1432}],1375:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1376:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1411}],1377:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1378:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1381,"./matrix.raw.js":1382,"dup":9}],1379:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1411,"validate.io-number-primitive":1435}],1380:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1381:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1370,"./ctor.js":1371,"./dtypes.js":1373,"compute-cast-arrays":1400,"compute-dtype":1403,"dup":12,"validate.io-array":1408,"validate.io-contains":1409,"validate.io-nonnegative-integer-array":1412,"validate.io-string-primitive":1439}],1382:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1370,"./ctor.raw.js":1372,"./dtypes.js":1373,"compute-dtype":1403,"dup":13,"validate.io-contains":1409,"validate.io-string-primitive":1439}],1383:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1370,"dup":14,"validate.io-nonnegative-integer-array":1412}],1384:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1370,"dup":15}],1385:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1387,"./mset2.js":1388,"./mset3.js":1389,"./mset4.js":1390,"./mset5.js":1391,"./mset6.js":1392,"dup":16,"validate.io-function":1429,"validate.io-nonnegative-integer-array":1412,"validate.io-number-primitive":1435}],1386:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1387,"./mset2.js":1388,"./mset3.js":1389,"./mset4.js":1390,"./mset5.js":1391,"./mset6.js":1392,"dup":17}],1387:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1388:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1389:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1390:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1391:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1392:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1393:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1432,"validate.io-number-primitive":1435}],1394:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1395:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1370,"compute-indexspace":1407,"dup":26,"validate.io-string-primitive":1439}],1396:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1370,"compute-indexspace":1407,"dup":27}],1397:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1407,"dup":28,"validate.io-function":1429,"validate.io-number-primitive":1435,"validate.io-string-primitive":1439}],1398:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1407,"dup":29}],1399:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1400:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1368,"compute-array-dtype/lib/dtypes":1401,"dup":31,"type-name":1402,"validate.io-array-like":1425}],1401:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1402:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1403:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1405,"dup":36,"type-name":1406}],1404:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1405:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1404,"dup":38}],1406:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1407:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1432,"validate.io-string-primitive":1439}],1408:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1409:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1408,"validate.io-nan-primitive":1410}],1410:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1411:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1435}],1412:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1408,"validate.io-nonnegative-integer":1432}],1413:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1414:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1415:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1413,"./defaults.js":1414,"./validate.js":1417,"dup":111,"validate.io-array":1418,"validate.io-string-primitive":1439}],1416:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1413,"./defaults.js":1414,"./factory.js":1415,"./validate.js":1417,"dup":112,"validate.io-array":1418,"validate.io-string-primitive":1439}],1417:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1436,"validate.io-string-primitive":1439}],1418:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1419:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1420:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1421:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1419,"./defaults.js":1420,"./validate.js":1423,"dup":117,"validate.io-array":1424,"validate.io-string-primitive":1439}],1422:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1419,"./defaults.js":1420,"./factory.js":1421,"./validate.js":1423,"dup":118,"validate.io-array":1424,"validate.io-string-primitive":1439}],1423:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1428,"validate.io-object":1436,"validate.io-string-primitive":1439}],1424:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1425:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1426,"dup":34,"validate.io-integer-primitive":1427}],1426:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1427:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1435}],1428:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1429:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1430:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1431:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1432:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1433}],1433:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1434}],1434:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1435:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1436:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1437}],1437:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1438:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1435}],1439:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1440:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1441,"dup":132,"validate.io-integer-primitive":1442}],1441:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1442:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1435}],1443:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, arr, accessor )
*	Computes the distribution median for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function median( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = MEDIAN( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":1448}],1444:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, lambda )
*	Computes the distribution median for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function median( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = MEDIAN( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":1448}],1445:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	MEDIAN  = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( arr, path[, sep] )
*	Computes the distribution median and deep sets the input array.
*
* @param {Array} arrays - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function median( arr, path, sep ) {
	var len = arr.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( arr[ i ] );
			if ( typeof v === 'number' ) {
				dset( arr[i], MEDIAN ( v ) );
			} else {
				dset( arr[i], NaN );
			}
		}
	}
	return arr;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":1448,"utils-deep-get":1499,"utils-deep-set":1505}],1446:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var median1 = require( './number.js' ),
	median2 = require( './array.js' ),
	median3 = require( './accessor.js' ),
	median4 = require( './deepset.js' ),
	median5 = require( './matrix.js' ),
	median6 = require( './typedarray.js' );


// MEDIAN //

/**
* FUNCTION: median( lambda[, opts] )
*	Computes the distribution median.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} lambda - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution median(s)
*/
function median( lambda, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( lambda ) || isnan( lambda ) ) {
		return median1( lambda );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( lambda ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( lambda.length );
			out = matrix( d, lambda.shape, dt );
		} else {
			out = lambda;
		}
		return median5( out, lambda );
	}
	if ( isTypedArrayLike( lambda ) ) {
		if ( opts.copy === false ) {
			out = lambda;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( lambda.length );
		}
		return median6( out, lambda );
	}
	if ( isArrayLike( lambda ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return median4( lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = lambda;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( lambda.length );
		}
		else {
			out = new Array( lambda.length );
		}
		if ( opts.accessor ) {
			return median3( out, lambda, opts.accessor );
		}
		return median2( out, lambda );
	}
	return NaN;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./accessor.js":1443,"./array.js":1444,"./deepset.js":1445,"./matrix.js":1447,"./number.js":1448,"./typedarray.js":1449,"./validate.js":1450,"compute-array-constructors":1452,"dstructs-matrix":1461,"validate.io-array-like":1508,"validate.io-matrix-like":1513,"validate.io-nan":1514,"validate.io-number-primitive":1518,"validate.io-typed-array-like":1523}],1447:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, x )
*	Computes the distribution median for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function median( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'median()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = MEDIAN( x.data[ i ] );
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":1448}],1448:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// FUNCTIONS //

var ln = Math.log;


// MEDIAN //

/**
* FUNCTION median( lambda )
*	Computes the distribution median for a exponential distribution with parameter lambda.
*
* @param {Number} lambda - rate parameter
* @returns {Number} distribution median
*/
function median( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return ( 1 / lambda ) * ln( 2 );
} // end FUNCTION median()


// EXPORTS

module.exports =  median;

},{"validate.io-positive-primitive":1521}],1449:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, lambda )
*	Computes the distribution median for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function median( out, lambda ) {
	var len = lambda.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = MEDIAN( lambda[ i ] );
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":1448}],1450:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'median()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'median()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'median()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'median()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'median()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'median()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1511,"validate.io-function":1512,"validate.io-object":1519,"validate.io-string-primitive":1522}],1451:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1452:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1451,"dup":63}],1453:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1454:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1457,"./iget.js":1459,"./iset.js":1462,"./mget.js":1466,"./mset.js":1468,"./set.js":1476,"./sget.js":1478,"./sset.js":1480,"./toString.js":1482,"dup":2}],1455:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1458,"./iget.raw.js":1460,"./iset.raw.js":1463,"./mget.raw.js":1467,"./mset.raw.js":1469,"./set.raw.js":1477,"./sget.raw.js":1479,"./sset.raw.js":1481,"./toString.js":1482,"dup":3}],1456:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1457:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1515}],1458:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1459:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1494}],1460:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1461:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1464,"./matrix.raw.js":1465,"dup":9}],1462:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1494,"validate.io-number-primitive":1518}],1463:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1464:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1453,"./ctor.js":1454,"./dtypes.js":1456,"compute-cast-arrays":1483,"compute-dtype":1486,"dup":12,"validate.io-array":1491,"validate.io-contains":1492,"validate.io-nonnegative-integer-array":1495,"validate.io-string-primitive":1522}],1465:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1453,"./ctor.raw.js":1455,"./dtypes.js":1456,"compute-dtype":1486,"dup":13,"validate.io-contains":1492,"validate.io-string-primitive":1522}],1466:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1453,"dup":14,"validate.io-nonnegative-integer-array":1495}],1467:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1453,"dup":15}],1468:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1470,"./mset2.js":1471,"./mset3.js":1472,"./mset4.js":1473,"./mset5.js":1474,"./mset6.js":1475,"dup":16,"validate.io-function":1512,"validate.io-nonnegative-integer-array":1495,"validate.io-number-primitive":1518}],1469:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1470,"./mset2.js":1471,"./mset3.js":1472,"./mset4.js":1473,"./mset5.js":1474,"./mset6.js":1475,"dup":17}],1470:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1471:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1472:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1473:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1474:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1475:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1476:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1515,"validate.io-number-primitive":1518}],1477:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1478:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1453,"compute-indexspace":1490,"dup":26,"validate.io-string-primitive":1522}],1479:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1453,"compute-indexspace":1490,"dup":27}],1480:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1490,"dup":28,"validate.io-function":1512,"validate.io-number-primitive":1518,"validate.io-string-primitive":1522}],1481:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1490,"dup":29}],1482:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1483:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1451,"compute-array-dtype/lib/dtypes":1484,"dup":31,"type-name":1485,"validate.io-array-like":1508}],1484:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1485:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1486:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1488,"dup":36,"type-name":1489}],1487:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1488:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1487,"dup":38}],1489:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1490:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1515,"validate.io-string-primitive":1522}],1491:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1492:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1491,"validate.io-nan-primitive":1493}],1493:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1494:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1518}],1495:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1491,"validate.io-nonnegative-integer":1515}],1496:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1497:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1498:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1496,"./defaults.js":1497,"./validate.js":1500,"dup":111,"validate.io-array":1501,"validate.io-string-primitive":1522}],1499:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1496,"./defaults.js":1497,"./factory.js":1498,"./validate.js":1500,"dup":112,"validate.io-array":1501,"validate.io-string-primitive":1522}],1500:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1519,"validate.io-string-primitive":1522}],1501:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1502:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1503:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1504:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1502,"./defaults.js":1503,"./validate.js":1506,"dup":117,"validate.io-array":1507,"validate.io-string-primitive":1522}],1505:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1502,"./defaults.js":1503,"./factory.js":1504,"./validate.js":1506,"dup":118,"validate.io-array":1507,"validate.io-string-primitive":1522}],1506:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1511,"validate.io-object":1519,"validate.io-string-primitive":1522}],1507:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1508:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1509,"dup":34,"validate.io-integer-primitive":1510}],1509:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1510:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1518}],1511:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1512:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1513:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1514:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1515:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1516}],1516:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1517}],1517:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1518:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1519:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1520}],1520:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1521:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1518}],1522:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1523:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1524,"dup":132,"validate.io-integer-primitive":1525}],1524:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1525:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1518}],1526:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// MGF //

/**
* FUNCTION: ( out, arr, lambda, accessor )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mgf( y, x, lambda, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./partial.js":1532}],1527:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// MGF //

/**
* FUNCTION: mgf( out, arr, lambda )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mgf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./partial.js":1532}],1528:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// MGF //

/**
* FUNCTION: mgf( arr, lambda, path[, sep] )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function mgf( x, lambda, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( lambda );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./partial.js":1532,"utils-deep-get":1583,"utils-deep-set":1589}],1529:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var mgf1 = require( './number.js' ),
	mgf2 = require( './array.js' ),
	mgf3 = require( './accessor.js' ),
	mgf4 = require( './deepset.js' ),
	mgf5 = require( './matrix.js' ),
	mgf6 = require( './typedarray.js' );


// MGF //

/**
* FUNCTION: mgf( t[, opts] )
*	Evaluates the moment-generating function (MGF) for an exponential distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} t - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.lambda=1] - rate parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated MGF
*/
function mgf( t, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.lambda = typeof opts.lambda !== 'undefined' ? opts.lambda : 1;

	if ( isNumber( t ) ) {
		return mgf1( t, opts.lambda );
	}
	if ( isMatrixLike( t ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mgf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( t.length );
			out = matrix( d, t.shape, dt );
		} else {
			out = t;
		}
		return mgf5( out, t, opts.lambda );
	}
	if ( isTypedArrayLike( t ) ) {
		if ( opts.copy === false ) {
			out = t;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mgf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( t.length );
		}
		return mgf6( out, t, opts.lambda );
	}
	if ( isArrayLike( t ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return mgf4( t, opts.lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = t;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'mgf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( t.length );
		}
		else {
			out = new Array( t.length );
		}
		if ( opts.accessor ) {
			return mgf3( out, t, opts.lambda, opts.accessor );
		}
		return mgf2( out, t, opts.lambda );
	}
	return NaN;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./accessor.js":1526,"./array.js":1527,"./deepset.js":1528,"./matrix.js":1530,"./number.js":1531,"./typedarray.js":1533,"./validate.js":1534,"compute-array-constructors":1536,"dstructs-matrix":1545,"validate.io-array-like":1592,"validate.io-matrix-like":1597,"validate.io-number-primitive":1601,"validate.io-typed-array-like":1606}],1530:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// MGF //

/**
* FUNCTION: mgf( out, matrix, lambda )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} lambda - rate parameter
* @returns {Matrix} output matrix
*/
function mgf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'mgf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./partial.js":1532}],1531:[function(require,module,exports){
'use strict';

// FUNCTIONS //


// MGF //

/**
* FUNCTION: mgf( x, lambda )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` at a value `t`.
*
* @param {Number} t - input value
* @param {Number} lambda - rate parameter
* @returns {Number} evaluated MGF
*/
function mgf( t, lambda ) {
	if ( t >= lambda ) {
		return NaN;
	}
	return lambda / ( lambda - t );
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{}],1532:[function(require,module,exports){
'use strict';

// FUNCTIONS //


// PARTIAL //

/**
* FUNCTION: partial( lambda )
*	Partially applies rate parameter `lambda` and returns a function for evaluating the moment-generating function (MGF) for an exponential distribution.
*
* @param {Number} lambda - rate parameter
* @returns {Function} MGF
*/
function partial( lambda ) {

	/**
	* FUNCTION: mgf( t )
	*	Evaluates the moment-generating function (MGF) for an exponential distribution.
	*
	* @private
	* @param {Number} t - input value
	* @returns {Number} evaluated MGF
	*/
	return function mgf( t ) {
		if ( t >= lambda ) {
			return NaN;
		}
		return lambda / ( lambda - t );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],1533:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// MGF //

/**
* FUNCTION: mgf( out, arr, lambda )
*	Evaluates the moment-generating function (MGF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mgf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( lambda );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION mgf()


// EXPORTS //

module.exports = mgf;

},{"./partial.js":1532}],1534:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.lambda] - rate parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'mgf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'lambda' ) ) {
		opts.lambda = options.lambda;
		if ( !isPositive( opts.lambda ) ) {
			return new TypeError( 'mgf()::invalid option. `lambda` parameter must be a positive number. Option: `' + opts.lambda + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'mgf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'mgf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'mgf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'mgf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'mgf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1595,"validate.io-function":1596,"validate.io-object":1602,"validate.io-positive-primitive":1604,"validate.io-string-primitive":1605}],1535:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1536:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1535,"dup":63}],1537:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1538:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1541,"./iget.js":1543,"./iset.js":1546,"./mget.js":1550,"./mset.js":1552,"./set.js":1560,"./sget.js":1562,"./sset.js":1564,"./toString.js":1566,"dup":2}],1539:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1542,"./iget.raw.js":1544,"./iset.raw.js":1547,"./mget.raw.js":1551,"./mset.raw.js":1553,"./set.raw.js":1561,"./sget.raw.js":1563,"./sset.raw.js":1565,"./toString.js":1566,"dup":3}],1540:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1541:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1598}],1542:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1543:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1578}],1544:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1545:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1548,"./matrix.raw.js":1549,"dup":9}],1546:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1578,"validate.io-number-primitive":1601}],1547:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1548:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1537,"./ctor.js":1538,"./dtypes.js":1540,"compute-cast-arrays":1567,"compute-dtype":1570,"dup":12,"validate.io-array":1575,"validate.io-contains":1576,"validate.io-nonnegative-integer-array":1579,"validate.io-string-primitive":1605}],1549:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1537,"./ctor.raw.js":1539,"./dtypes.js":1540,"compute-dtype":1570,"dup":13,"validate.io-contains":1576,"validate.io-string-primitive":1605}],1550:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1537,"dup":14,"validate.io-nonnegative-integer-array":1579}],1551:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1537,"dup":15}],1552:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1554,"./mset2.js":1555,"./mset3.js":1556,"./mset4.js":1557,"./mset5.js":1558,"./mset6.js":1559,"dup":16,"validate.io-function":1596,"validate.io-nonnegative-integer-array":1579,"validate.io-number-primitive":1601}],1553:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1554,"./mset2.js":1555,"./mset3.js":1556,"./mset4.js":1557,"./mset5.js":1558,"./mset6.js":1559,"dup":17}],1554:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1555:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1556:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1557:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1558:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1559:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1560:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1598,"validate.io-number-primitive":1601}],1561:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1562:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1537,"compute-indexspace":1574,"dup":26,"validate.io-string-primitive":1605}],1563:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1537,"compute-indexspace":1574,"dup":27}],1564:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1574,"dup":28,"validate.io-function":1596,"validate.io-number-primitive":1601,"validate.io-string-primitive":1605}],1565:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1574,"dup":29}],1566:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1567:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1535,"compute-array-dtype/lib/dtypes":1568,"dup":31,"type-name":1569,"validate.io-array-like":1592}],1568:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1569:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1570:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1572,"dup":36,"type-name":1573}],1571:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1572:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1571,"dup":38}],1573:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1574:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1598,"validate.io-string-primitive":1605}],1575:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1576:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1575,"validate.io-nan-primitive":1577}],1577:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1578:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1601}],1579:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1575,"validate.io-nonnegative-integer":1598}],1580:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1581:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1582:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1580,"./defaults.js":1581,"./validate.js":1584,"dup":111,"validate.io-array":1585,"validate.io-string-primitive":1605}],1583:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1580,"./defaults.js":1581,"./factory.js":1582,"./validate.js":1584,"dup":112,"validate.io-array":1585,"validate.io-string-primitive":1605}],1584:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1602,"validate.io-string-primitive":1605}],1585:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1586:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1587:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1588:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1586,"./defaults.js":1587,"./validate.js":1590,"dup":117,"validate.io-array":1591,"validate.io-string-primitive":1605}],1589:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1586,"./defaults.js":1587,"./factory.js":1588,"./validate.js":1590,"dup":118,"validate.io-array":1591,"validate.io-string-primitive":1605}],1590:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1595,"validate.io-object":1602,"validate.io-string-primitive":1605}],1591:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1592:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1593,"dup":34,"validate.io-integer-primitive":1594}],1593:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1594:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1601}],1595:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1596:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1597:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1598:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1599}],1599:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1600}],1600:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1601:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1602:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1603}],1603:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1604:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1601}],1605:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1606:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1607,"dup":132,"validate.io-integer-primitive":1608}],1607:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1608:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1601}],1609:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, lambda, accessor )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, lambda, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":1615}],1610:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, lambda )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":1615}],1611:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( arr, lambda, path[, sep] )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function pdf( x, lambda, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( lambda );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":1615,"utils-deep-get":1666,"utils-deep-set":1672}],1612:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var pdf1 = require( './number.js' ),
	pdf2 = require( './array.js' ),
	pdf3 = require( './accessor.js' ),
	pdf4 = require( './deepset.js' ),
	pdf5 = require( './matrix.js' ),
	pdf6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: pdf( x[, opts] )
*	Evaluates the probability density function (PDF) for an exponential distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.lambda=1] - rate parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated PDF
*/
function pdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.lambda = typeof opts.lambda !== 'undefined' ? opts.lambda : 1;

	if ( isNumber( x ) ) {
		return pdf1( x, opts.lambda );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return pdf5( out, x, opts.lambda );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return pdf6( out, x, opts.lambda );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return pdf4( x, opts.lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return pdf3( out, x, opts.lambda, opts.accessor );
		}
		return pdf2( out, x, opts.lambda );
	}
	return NaN;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./accessor.js":1609,"./array.js":1610,"./deepset.js":1611,"./matrix.js":1613,"./number.js":1614,"./typedarray.js":1616,"./validate.js":1617,"compute-array-constructors":1619,"dstructs-matrix":1628,"validate.io-array-like":1675,"validate.io-matrix-like":1680,"validate.io-number-primitive":1684,"validate.io-typed-array-like":1690}],1613:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, matrix, lambda )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} lambda - rate parameter
* @returns {Matrix} output matrix
*/
function pdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'pdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":1615}],1614:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp;


// PDF //

/**
* FUNCTION: pdf( x, lambda )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} lambda - rate parameter
* @returns {Number} evaluated PDF
*/
function pdf( x, lambda ) {
	if ( x >= 0 ) {
		return lambda * exp( -lambda*x );
	} else {
		return 0;
	}
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{}],1615:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp;


// PARTIAL //

/**
* FUNCTION: partial( lambda )
*	Partially applies rate parameter `lambda` and returns a function for evaluating the probability density function (PDF) for an exponential distribution.
*
* @param {Number} lambda - rate parameter
* @returns {Function} PDF
*/
function partial( lambda ) {

	/**
	* FUNCTION: pdf( x )
	*	Evaluates the probability density function (PDF) for an exponential distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated PDF
	*/
	return function pdf( x ) {
		if ( x >= 0 ) {
			return lambda * exp( -lambda*x );
		} else {
			return 0;
		}
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],1616:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, lambda )
*	Evaluates the probability density function (PDF) for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( lambda );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":1615}],1617:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.lambda] - rate parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'pdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'lambda' ) ) {
		opts.lambda = options.lambda;
		if ( !isPositive( opts.lambda ) ) {
			return new TypeError( 'pdf()::invalid option. `lambda` parameter must be a positive number. Option: `' + opts.lambda + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'pdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'pdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'pdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'pdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'pdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1678,"validate.io-function":1679,"validate.io-object":1685,"validate.io-positive":1687,"validate.io-string-primitive":1689}],1618:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1619:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1618,"dup":63}],1620:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1621:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1624,"./iget.js":1626,"./iset.js":1629,"./mget.js":1633,"./mset.js":1635,"./set.js":1643,"./sget.js":1645,"./sset.js":1647,"./toString.js":1649,"dup":2}],1622:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1625,"./iget.raw.js":1627,"./iset.raw.js":1630,"./mget.raw.js":1634,"./mset.raw.js":1636,"./set.raw.js":1644,"./sget.raw.js":1646,"./sset.raw.js":1648,"./toString.js":1649,"dup":3}],1623:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1624:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1681}],1625:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1626:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1661}],1627:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1628:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1631,"./matrix.raw.js":1632,"dup":9}],1629:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1661,"validate.io-number-primitive":1684}],1630:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1631:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1620,"./ctor.js":1621,"./dtypes.js":1623,"compute-cast-arrays":1650,"compute-dtype":1653,"dup":12,"validate.io-array":1658,"validate.io-contains":1659,"validate.io-nonnegative-integer-array":1662,"validate.io-string-primitive":1689}],1632:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1620,"./ctor.raw.js":1622,"./dtypes.js":1623,"compute-dtype":1653,"dup":13,"validate.io-contains":1659,"validate.io-string-primitive":1689}],1633:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1620,"dup":14,"validate.io-nonnegative-integer-array":1662}],1634:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1620,"dup":15}],1635:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1637,"./mset2.js":1638,"./mset3.js":1639,"./mset4.js":1640,"./mset5.js":1641,"./mset6.js":1642,"dup":16,"validate.io-function":1679,"validate.io-nonnegative-integer-array":1662,"validate.io-number-primitive":1684}],1636:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1637,"./mset2.js":1638,"./mset3.js":1639,"./mset4.js":1640,"./mset5.js":1641,"./mset6.js":1642,"dup":17}],1637:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1638:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1639:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1640:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1641:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1642:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1643:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1681,"validate.io-number-primitive":1684}],1644:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1645:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1620,"compute-indexspace":1657,"dup":26,"validate.io-string-primitive":1689}],1646:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1620,"compute-indexspace":1657,"dup":27}],1647:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1657,"dup":28,"validate.io-function":1679,"validate.io-number-primitive":1684,"validate.io-string-primitive":1689}],1648:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1657,"dup":29}],1649:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1650:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1618,"compute-array-dtype/lib/dtypes":1651,"dup":31,"type-name":1652,"validate.io-array-like":1675}],1651:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1652:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1653:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1655,"dup":36,"type-name":1656}],1654:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1655:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1654,"dup":38}],1656:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1657:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1681,"validate.io-string-primitive":1689}],1658:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1659:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1658,"validate.io-nan-primitive":1660}],1660:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1661:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1684}],1662:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1658,"validate.io-nonnegative-integer":1681}],1663:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1664:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1665:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1663,"./defaults.js":1664,"./validate.js":1667,"dup":111,"validate.io-array":1668,"validate.io-string-primitive":1689}],1666:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1663,"./defaults.js":1664,"./factory.js":1665,"./validate.js":1667,"dup":112,"validate.io-array":1668,"validate.io-string-primitive":1689}],1667:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1685,"validate.io-string-primitive":1689}],1668:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1669:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1670:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1671:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1669,"./defaults.js":1670,"./validate.js":1673,"dup":117,"validate.io-array":1674,"validate.io-string-primitive":1689}],1672:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1669,"./defaults.js":1670,"./factory.js":1671,"./validate.js":1673,"dup":118,"validate.io-array":1674,"validate.io-string-primitive":1689}],1673:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1678,"validate.io-object":1685,"validate.io-string-primitive":1689}],1674:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1675:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1676,"dup":34,"validate.io-integer-primitive":1677}],1676:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1677:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1684}],1678:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1679:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1680:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1681:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1682}],1682:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1683}],1683:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1684:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1685:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1686}],1686:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1687:[function(require,module,exports){
/**
*
*	VALIDATE: positive
*
*
*	DESCRIPTION:
*		- Validates if a value is a positive number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISPOSITIVE //

/**
* FUNCTION: isPositive( value )
*	Validates if a value is a positive number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a positive number
*/
function isPositive( value ) {
	return isNumber( value ) && value > 0;
} // end FUNCTION isPositive()


// EXPORTS //

module.exports = isPositive;

},{"validate.io-number":1688}],1688:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1689:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1690:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1691,"dup":132,"validate.io-integer-primitive":1692}],1691:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1692:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1684}],1693:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, lambda, accessor )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, lambda, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":1699}],1694:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, lambda )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":1699}],1695:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( arr, lambda, path[, sep] )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} lambda - rate parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function quantile( x, lambda, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( lambda );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":1699,"utils-deep-get":1750,"utils-deep-set":1756}],1696:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var quantile1 = require( './number.js' ),
	quantile2 = require( './array.js' ),
	quantile3 = require( './accessor.js' ),
	quantile4 = require( './deepset.js' ),
	quantile5 = require( './matrix.js' ),
	quantile6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: quantile( p[, opts] )
*	Evaluates the quantile function for an exponential distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} p - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.lambda=1] - rate parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} quantile function value(s)
*/
function quantile( p, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.lambda = typeof opts.lambda !== 'undefined' ? opts.lambda : 1;

	if ( isNumber( p ) ) {
		return quantile1( p, opts.lambda );
	}
	if ( isMatrixLike( p ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( p.length );
			out = matrix( d, p.shape, dt );
		} else {
			out = p;
		}
		return quantile5( out, p, opts.lambda );
	}
	if ( isTypedArrayLike( p ) ) {
		if ( opts.copy === false ) {
			out = p;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( p.length );
		}
		return quantile6( out, p, opts.lambda );
	}
	if ( isArrayLike( p ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return quantile4( p, opts.lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = p;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( p.length );
		}
		else {
			out = new Array( p.length );
		}
		if ( opts.accessor ) {
			return quantile3( out, p, opts.lambda, opts.accessor );
		}
		return quantile2( out, p, opts.lambda );
	}
	return NaN;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./accessor.js":1693,"./array.js":1694,"./deepset.js":1695,"./matrix.js":1697,"./number.js":1698,"./typedarray.js":1700,"./validate.js":1701,"compute-array-constructors":1703,"dstructs-matrix":1712,"validate.io-array-like":1759,"validate.io-matrix-like":1764,"validate.io-number-primitive":1768,"validate.io-typed-array-like":1773}],1697:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, matrix, lambda )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} lambda - rate parameter
* @returns {Matrix} output matrix
*/
function quantile( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'quantile()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( lambda );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":1699}],1698:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ln = Math.log;


// QUANTILE //

/**
* FUNCTION: quantile( p, lambda )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` at a probability `p`.
*
* @param {Number} p - input value
* @param {Number} lambda - rate parameter
* @returns {Number} evaluated quantile function
*/
function quantile( p, lambda ) {
	if ( p !== p || p < 0 || p > 1 ) {
		return NaN;
	}
	return - ln( 1 - p ) / lambda;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{}],1699:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ln = Math.log;


// PARTIAL //

/**
* FUNCTION: partial( lambda )
*	Partially applies rate parameter `lambda` and returns a function for evaluating the quantile function for an exponential distribution.
*
* @param {Number} lambda - rate parameter
* @returns {Function} quantile function
*/
function partial( lambda ) {

	/**
	* FUNCTION: quantile( p )
	*	Evaluates the quantile function for an exponential distribution.
	*
	* @private
	* @param {Number} p - input value
	* @returns {Number} evaluated quantile function
	*/
	return function quantile( p ) {
		if ( p !== p || p < 0 || p > 1 ) {
			return NaN;
		}
		return - ln( 1 - p ) / lambda;
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],1700:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, lambda )
*	Evaluates the quantile function for an exponential distribution with rate parameter `lambda` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} lambda - rate parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, lambda ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( lambda );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":1699}],1701:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.lambda] - rate parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'quantile()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'lambda' ) ) {
		opts.lambda = options.lambda;
		if ( !isPositive( opts.lambda ) ) {
			return new TypeError( 'quantile()::invalid option. Rate parameter `lambda` must be a positive number. Option: `' + opts.lambda + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'quantile()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'quantile()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'quantile()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'quantile()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'quantile()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1762,"validate.io-function":1763,"validate.io-object":1769,"validate.io-positive-primitive":1771,"validate.io-string-primitive":1772}],1702:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1703:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1702,"dup":63}],1704:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1705:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1708,"./iget.js":1710,"./iset.js":1713,"./mget.js":1717,"./mset.js":1719,"./set.js":1727,"./sget.js":1729,"./sset.js":1731,"./toString.js":1733,"dup":2}],1706:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1709,"./iget.raw.js":1711,"./iset.raw.js":1714,"./mget.raw.js":1718,"./mset.raw.js":1720,"./set.raw.js":1728,"./sget.raw.js":1730,"./sset.raw.js":1732,"./toString.js":1733,"dup":3}],1707:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1708:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1765}],1709:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1710:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1745}],1711:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1712:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1715,"./matrix.raw.js":1716,"dup":9}],1713:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1745,"validate.io-number-primitive":1768}],1714:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1715:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1704,"./ctor.js":1705,"./dtypes.js":1707,"compute-cast-arrays":1734,"compute-dtype":1737,"dup":12,"validate.io-array":1742,"validate.io-contains":1743,"validate.io-nonnegative-integer-array":1746,"validate.io-string-primitive":1772}],1716:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1704,"./ctor.raw.js":1706,"./dtypes.js":1707,"compute-dtype":1737,"dup":13,"validate.io-contains":1743,"validate.io-string-primitive":1772}],1717:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1704,"dup":14,"validate.io-nonnegative-integer-array":1746}],1718:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1704,"dup":15}],1719:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1721,"./mset2.js":1722,"./mset3.js":1723,"./mset4.js":1724,"./mset5.js":1725,"./mset6.js":1726,"dup":16,"validate.io-function":1763,"validate.io-nonnegative-integer-array":1746,"validate.io-number-primitive":1768}],1720:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1721,"./mset2.js":1722,"./mset3.js":1723,"./mset4.js":1724,"./mset5.js":1725,"./mset6.js":1726,"dup":17}],1721:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1722:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1723:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1724:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1725:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1726:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1727:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1765,"validate.io-number-primitive":1768}],1728:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1729:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1704,"compute-indexspace":1741,"dup":26,"validate.io-string-primitive":1772}],1730:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1704,"compute-indexspace":1741,"dup":27}],1731:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1741,"dup":28,"validate.io-function":1763,"validate.io-number-primitive":1768,"validate.io-string-primitive":1772}],1732:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1741,"dup":29}],1733:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1734:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1702,"compute-array-dtype/lib/dtypes":1735,"dup":31,"type-name":1736,"validate.io-array-like":1759}],1735:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1736:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1737:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1739,"dup":36,"type-name":1740}],1738:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1739:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1738,"dup":38}],1740:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1741:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1765,"validate.io-string-primitive":1772}],1742:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1743:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1742,"validate.io-nan-primitive":1744}],1744:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1745:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1768}],1746:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1742,"validate.io-nonnegative-integer":1765}],1747:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1748:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1749:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1747,"./defaults.js":1748,"./validate.js":1751,"dup":111,"validate.io-array":1752,"validate.io-string-primitive":1772}],1750:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1747,"./defaults.js":1748,"./factory.js":1749,"./validate.js":1751,"dup":112,"validate.io-array":1752,"validate.io-string-primitive":1772}],1751:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1769,"validate.io-string-primitive":1772}],1752:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1753:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1754:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1755:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1753,"./defaults.js":1754,"./validate.js":1757,"dup":117,"validate.io-array":1758,"validate.io-string-primitive":1772}],1756:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1753,"./defaults.js":1754,"./factory.js":1755,"./validate.js":1757,"dup":118,"validate.io-array":1758,"validate.io-string-primitive":1772}],1757:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1762,"validate.io-object":1769,"validate.io-string-primitive":1772}],1758:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1759:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1760,"dup":34,"validate.io-integer-primitive":1761}],1760:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1761:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1768}],1762:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1763:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1764:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1765:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1766}],1766:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1767}],1767:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1768:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1769:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1770}],1770:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1771:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1768}],1772:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1773:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1774,"dup":132,"validate.io-integer-primitive":1775}],1774:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1775:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1768}],1776:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, arr, accessor )
*	Computes the distribution skewness for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function skewness( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = SKEWNESS( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":1781}],1777:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, lambda )
*	Computes the distribution skewness for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function skewness( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = SKEWNESS( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":1781}],1778:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	SKEWNESS  = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( arr, path[, sep] )
*	Computes the distribution skewness and deep sets the input array.
*
* @param {Array} arrays - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function skewness( arr, path, sep ) {
	var len = arr.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( arr[ i ] );
			if ( typeof v === 'number' ) {
				dset( arr[i], SKEWNESS ( v ) );
			} else {
				dset( arr[i], NaN );
			}
		}
	}
	return arr;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":1781,"utils-deep-get":1832,"utils-deep-set":1838}],1779:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var skewness1 = require( './number.js' ),
	skewness2 = require( './array.js' ),
	skewness3 = require( './accessor.js' ),
	skewness4 = require( './deepset.js' ),
	skewness5 = require( './matrix.js' ),
	skewness6 = require( './typedarray.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( lambda[, opts] )
*	Computes the distribution skewness.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} lambda - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution skewness(s)
*/
function skewness( lambda, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( lambda ) || isnan( lambda ) ) {
		return skewness1( lambda );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( lambda ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( lambda.length );
			out = matrix( d, lambda.shape, dt );
		} else {
			out = lambda;
		}
		return skewness5( out, lambda );
	}
	if ( isTypedArrayLike( lambda ) ) {
		if ( opts.copy === false ) {
			out = lambda;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( lambda.length );
		}
		return skewness6( out, lambda );
	}
	if ( isArrayLike( lambda ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return skewness4( lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = lambda;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( lambda.length );
		}
		else {
			out = new Array( lambda.length );
		}
		if ( opts.accessor ) {
			return skewness3( out, lambda, opts.accessor );
		}
		return skewness2( out, lambda );
	}
	return NaN;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./accessor.js":1776,"./array.js":1777,"./deepset.js":1778,"./matrix.js":1780,"./number.js":1781,"./typedarray.js":1782,"./validate.js":1783,"compute-array-constructors":1785,"dstructs-matrix":1794,"validate.io-array-like":1841,"validate.io-matrix-like":1846,"validate.io-nan":1847,"validate.io-number-primitive":1851,"validate.io-typed-array-like":1856}],1780:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, x )
*	Computes the distribution skewness for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function skewness( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'skewness()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = SKEWNESS( x.data[ i ] );
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":1781}],1781:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// SKEWNESS //

/**
* FUNCTION skewness( lambda )
*	Computes the distribution skewness for a exponential distribution with parameter lambda.
*
* @param {Number} lambda - rate parameter
* @returns {Number} distribution skewness
*/
function skewness( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return 2;
} // end FUNCTION skewness()


// EXPORTS

module.exports =  skewness;

},{"validate.io-positive-primitive":1854}],1782:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, lambda )
*	Computes the distribution skewness for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function skewness( out, lambda ) {
	var len = lambda.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = SKEWNESS( lambda[ i ] );
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":1781}],1783:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'skewness()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'skewness()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'skewness()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'skewness()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'skewness()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'skewness()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1844,"validate.io-function":1845,"validate.io-object":1852,"validate.io-string-primitive":1855}],1784:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1785:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1784,"dup":63}],1786:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1787:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1790,"./iget.js":1792,"./iset.js":1795,"./mget.js":1799,"./mset.js":1801,"./set.js":1809,"./sget.js":1811,"./sset.js":1813,"./toString.js":1815,"dup":2}],1788:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1791,"./iget.raw.js":1793,"./iset.raw.js":1796,"./mget.raw.js":1800,"./mset.raw.js":1802,"./set.raw.js":1810,"./sget.raw.js":1812,"./sset.raw.js":1814,"./toString.js":1815,"dup":3}],1789:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1790:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1848}],1791:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1792:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1827}],1793:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1794:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1797,"./matrix.raw.js":1798,"dup":9}],1795:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1827,"validate.io-number-primitive":1851}],1796:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1797:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1786,"./ctor.js":1787,"./dtypes.js":1789,"compute-cast-arrays":1816,"compute-dtype":1819,"dup":12,"validate.io-array":1824,"validate.io-contains":1825,"validate.io-nonnegative-integer-array":1828,"validate.io-string-primitive":1855}],1798:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1786,"./ctor.raw.js":1788,"./dtypes.js":1789,"compute-dtype":1819,"dup":13,"validate.io-contains":1825,"validate.io-string-primitive":1855}],1799:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1786,"dup":14,"validate.io-nonnegative-integer-array":1828}],1800:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1786,"dup":15}],1801:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1803,"./mset2.js":1804,"./mset3.js":1805,"./mset4.js":1806,"./mset5.js":1807,"./mset6.js":1808,"dup":16,"validate.io-function":1845,"validate.io-nonnegative-integer-array":1828,"validate.io-number-primitive":1851}],1802:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1803,"./mset2.js":1804,"./mset3.js":1805,"./mset4.js":1806,"./mset5.js":1807,"./mset6.js":1808,"dup":17}],1803:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1804:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1805:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1806:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1807:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1808:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1809:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1848,"validate.io-number-primitive":1851}],1810:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1811:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1786,"compute-indexspace":1823,"dup":26,"validate.io-string-primitive":1855}],1812:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1786,"compute-indexspace":1823,"dup":27}],1813:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1823,"dup":28,"validate.io-function":1845,"validate.io-number-primitive":1851,"validate.io-string-primitive":1855}],1814:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1823,"dup":29}],1815:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1816:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1784,"compute-array-dtype/lib/dtypes":1817,"dup":31,"type-name":1818,"validate.io-array-like":1841}],1817:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1818:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1819:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1821,"dup":36,"type-name":1822}],1820:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1821:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1820,"dup":38}],1822:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1823:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1848,"validate.io-string-primitive":1855}],1824:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1825:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1824,"validate.io-nan-primitive":1826}],1826:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1827:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1851}],1828:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1824,"validate.io-nonnegative-integer":1848}],1829:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1830:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1831:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1829,"./defaults.js":1830,"./validate.js":1833,"dup":111,"validate.io-array":1834,"validate.io-string-primitive":1855}],1832:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1829,"./defaults.js":1830,"./factory.js":1831,"./validate.js":1833,"dup":112,"validate.io-array":1834,"validate.io-string-primitive":1855}],1833:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1852,"validate.io-string-primitive":1855}],1834:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1835:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1836:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1837:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1835,"./defaults.js":1836,"./validate.js":1839,"dup":117,"validate.io-array":1840,"validate.io-string-primitive":1855}],1838:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1835,"./defaults.js":1836,"./factory.js":1837,"./validate.js":1839,"dup":118,"validate.io-array":1840,"validate.io-string-primitive":1855}],1839:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1844,"validate.io-object":1852,"validate.io-string-primitive":1855}],1840:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1841:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1842,"dup":34,"validate.io-integer-primitive":1843}],1842:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1843:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1851}],1844:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1845:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1846:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1847:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1848:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1849}],1849:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1850}],1850:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1851:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1852:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1853}],1853:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1854:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1851}],1855:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1856:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1857,"dup":132,"validate.io-integer-primitive":1858}],1857:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1858:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1851}],1859:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, arr, accessor )
*	Computes the distribution variance for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function variance( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = VARIANCE( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":1864}],1860:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, lambda )
*	Computes the distribution variance for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function variance( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = VARIANCE( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":1864}],1861:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	VARIANCE  = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( arr, path[, sep] )
*	Computes the distribution variance and deep sets the input array.
*
* @param {Array} arrays - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function variance( arr, path, sep ) {
	var len = arr.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( arr[ i ] );
			if ( typeof v === 'number' ) {
				dset( arr[i], VARIANCE ( v ) );
			} else {
				dset( arr[i], NaN );
			}
		}
	}
	return arr;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":1864,"utils-deep-get":1915,"utils-deep-set":1921}],1862:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var variance1 = require( './number.js' ),
	variance2 = require( './array.js' ),
	variance3 = require( './accessor.js' ),
	variance4 = require( './deepset.js' ),
	variance5 = require( './matrix.js' ),
	variance6 = require( './typedarray.js' );


// VARIANCE //

/**
* FUNCTION: variance( lambda[, opts] )
*	Computes the distribution variance.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} lambda - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution variance(s)
*/
function variance( lambda, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( lambda ) || isnan( lambda ) ) {
		return variance1( lambda );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( lambda ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( lambda.length );
			out = matrix( d, lambda.shape, dt );
		} else {
			out = lambda;
		}
		return variance5( out, lambda );
	}
	if ( isTypedArrayLike( lambda ) ) {
		if ( opts.copy === false ) {
			out = lambda;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( lambda.length );
		}
		return variance6( out, lambda );
	}
	if ( isArrayLike( lambda ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return variance4( lambda, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = lambda;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( lambda.length );
		}
		else {
			out = new Array( lambda.length );
		}
		if ( opts.accessor ) {
			return variance3( out, lambda, opts.accessor );
		}
		return variance2( out, lambda );
	}
	return NaN;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./accessor.js":1859,"./array.js":1860,"./deepset.js":1861,"./matrix.js":1863,"./number.js":1864,"./typedarray.js":1865,"./validate.js":1866,"compute-array-constructors":1868,"dstructs-matrix":1877,"validate.io-array-like":1924,"validate.io-matrix-like":1929,"validate.io-nan":1930,"validate.io-number-primitive":1934,"validate.io-typed-array-like":1939}],1863:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, x )
*	Computes the distribution variance for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function variance( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'variance()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = VARIANCE( x.data[ i ] );
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":1864}],1864:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// FUNCTIONS //

var pow = Math.pow;


// VARIANCE //

/**
* FUNCTION variance( lambda )
*	Computes the distribution variance for an exponential distribution with parameter lambda.
*
* @param {Number} lambda - rate parameter
* @returns {Number} distribution variance
*/
function variance( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return pow( lambda, -2 );
} // end FUNCTION variance()


// EXPORTS

module.exports =  variance;

},{"validate.io-positive-primitive":1937}],1865:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, lambda )
*	Computes the distribution variance for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} lambda - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function variance( out, lambda ) {
	var len = lambda.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = VARIANCE( lambda[ i ] );
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":1864}],1866:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'variance()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'variance()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'variance()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'variance()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'variance()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'variance()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":1927,"validate.io-function":1928,"validate.io-object":1935,"validate.io-string-primitive":1938}],1867:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1868:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1867,"dup":63}],1869:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1870:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1873,"./iget.js":1875,"./iset.js":1878,"./mget.js":1882,"./mset.js":1884,"./set.js":1892,"./sget.js":1894,"./sset.js":1896,"./toString.js":1898,"dup":2}],1871:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1874,"./iget.raw.js":1876,"./iset.raw.js":1879,"./mget.raw.js":1883,"./mset.raw.js":1885,"./set.raw.js":1893,"./sget.raw.js":1895,"./sset.raw.js":1897,"./toString.js":1898,"dup":3}],1872:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1873:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":1931}],1874:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1875:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1910}],1876:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1877:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1880,"./matrix.raw.js":1881,"dup":9}],1878:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1910,"validate.io-number-primitive":1934}],1879:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1880:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1869,"./ctor.js":1870,"./dtypes.js":1872,"compute-cast-arrays":1899,"compute-dtype":1902,"dup":12,"validate.io-array":1907,"validate.io-contains":1908,"validate.io-nonnegative-integer-array":1911,"validate.io-string-primitive":1938}],1881:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1869,"./ctor.raw.js":1871,"./dtypes.js":1872,"compute-dtype":1902,"dup":13,"validate.io-contains":1908,"validate.io-string-primitive":1938}],1882:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1869,"dup":14,"validate.io-nonnegative-integer-array":1911}],1883:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1869,"dup":15}],1884:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1886,"./mset2.js":1887,"./mset3.js":1888,"./mset4.js":1889,"./mset5.js":1890,"./mset6.js":1891,"dup":16,"validate.io-function":1928,"validate.io-nonnegative-integer-array":1911,"validate.io-number-primitive":1934}],1885:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1886,"./mset2.js":1887,"./mset3.js":1888,"./mset4.js":1889,"./mset5.js":1890,"./mset6.js":1891,"dup":17}],1886:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1887:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1888:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1889:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1890:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1891:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1892:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":1931,"validate.io-number-primitive":1934}],1893:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1894:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1869,"compute-indexspace":1906,"dup":26,"validate.io-string-primitive":1938}],1895:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1869,"compute-indexspace":1906,"dup":27}],1896:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1906,"dup":28,"validate.io-function":1928,"validate.io-number-primitive":1934,"validate.io-string-primitive":1938}],1897:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1906,"dup":29}],1898:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1899:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1867,"compute-array-dtype/lib/dtypes":1900,"dup":31,"type-name":1901,"validate.io-array-like":1924}],1900:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1901:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1902:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1904,"dup":36,"type-name":1905}],1903:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1904:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1903,"dup":38}],1905:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1906:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":1931,"validate.io-string-primitive":1938}],1907:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1908:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1907,"validate.io-nan-primitive":1909}],1909:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1910:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1934}],1911:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1907,"validate.io-nonnegative-integer":1931}],1912:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1913:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1914:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1912,"./defaults.js":1913,"./validate.js":1916,"dup":111,"validate.io-array":1917,"validate.io-string-primitive":1938}],1915:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1912,"./defaults.js":1913,"./factory.js":1914,"./validate.js":1916,"dup":112,"validate.io-array":1917,"validate.io-string-primitive":1938}],1916:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":1935,"validate.io-string-primitive":1938}],1917:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1918:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],1919:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],1920:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":1918,"./defaults.js":1919,"./validate.js":1922,"dup":117,"validate.io-array":1923,"validate.io-string-primitive":1938}],1921:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":1918,"./defaults.js":1919,"./factory.js":1920,"./validate.js":1922,"dup":118,"validate.io-array":1923,"validate.io-string-primitive":1938}],1922:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":1927,"validate.io-object":1935,"validate.io-string-primitive":1938}],1923:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1924:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1925,"dup":34,"validate.io-integer-primitive":1926}],1925:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1926:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1934}],1927:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],1928:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],1929:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],1930:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],1931:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":1932}],1932:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":1933}],1933:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],1934:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],1935:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":1936}],1936:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1937:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":1934}],1938:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],1939:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":1940,"dup":132,"validate.io-integer-primitive":1941}],1940:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],1941:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":1934}],1942:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, mu, sigma, accessor )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, mu, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1948}],1943:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, mu, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1948}],1944:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( arr, mu, sigma, path[, sep] )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function cdf( x, mu, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 4 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( mu, sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1948,"utils-deep-get":2000,"utils-deep-set":2006}],1945:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var cdf1 = require( './number.js' ),
	cdf2 = require( './array.js' ),
	cdf3 = require( './accessor.js' ),
	cdf4 = require( './deepset.js' ),
	cdf5 = require( './matrix.js' ),
	cdf6 = require( './typedarray.js' );


// CDF //

/**
* FUNCTION: cdf( x[, opts] )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.mu=0] - mean
* @param {Number} [opts.sigma=1] - standard deviation
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated CDF
*/
function cdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.mu = typeof opts.mu !== 'undefined' ? opts.mu : 0;
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( x ) ) {
		return cdf1( x, opts.mu, opts.sigma );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return cdf5( out, x, opts.mu, opts.sigma );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return cdf6( out, x, opts.mu, opts.sigma );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return cdf4( x, opts.mu, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return cdf3( out, x, opts.mu, opts.sigma, opts.accessor );
		}
		return cdf2( out, x, opts.mu, opts.sigma );
	}
	return NaN;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./accessor.js":1942,"./array.js":1943,"./deepset.js":1944,"./matrix.js":1946,"./number.js":1947,"./typedarray.js":1949,"./validate.js":1950,"compute-array-constructors":1952,"dstructs-matrix":1962,"validate.io-array-like":2009,"validate.io-matrix-like":2014,"validate.io-number-primitive":2020,"validate.io-typed-array-like":2024}],1946:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, matrix, mu, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Matrix} output matrix
*/
function cdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'cdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1948}],1947:[function(require,module,exports){
'use strict';

// MODULES //

var erf = require( 'compute-erf/lib/number.js' );


// FUNCTIONS //

var sqrt = Math.sqrt;


// CDF //

/**
* FUNCTION: cdf( x, mu, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number} evaluated CDF
*/
function cdf( x, mu, sigma ) {
	if( sigma === 0 ) {
		return (x < mu) ? 0 : 1;
	}
	var A = 1 / 2,
		B = sigma * sqrt( 2 ),
		C = x - mu;
	return A * ( 1 + erf( C / B ) );
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"compute-erf/lib/number.js":1953}],1948:[function(require,module,exports){
'use strict';

// MODULES //

var erf = require( 'compute-erf/lib/number.js' );


// FUNCTIONS //

var sqrt = Math.sqrt;


// PARTIAL //

/**
* FUNCTION: partial( mu, sigma )
*	Partially applies mean `mu` and standard deviation `sigma` and returns a function for evaluating the cumulative distribution function (CDF) for a Normal distribution.
*
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Function} CDF
*/
function partial( mu, sigma ) {
	var A = 1 / 2,
		B = sigma * sqrt( 2 );
	/**
	* FUNCTION: cdf( x )
	*	Evaluates the cumulative distribution function (CDF) for a Normal distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated CDF
	*/
	if( sigma === 0 ) {
		return function cdf( x ) {
			return (x < mu) ? 0 : 1;
		};
	}
	return function cdf( x ) {
		var C = x - mu;
		return A * ( 1 + erf( C / B ) );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{"compute-erf/lib/number.js":1953}],1949:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, mu, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":1948}],1950:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isNonNegative = require( 'validate.io-nonnegative' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.mu] - mean
* @param {Number} [options.sigma] - standard deviation
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'cdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'mu' ) ) {
		opts.mu = options.mu;
		if ( !isNumber( opts.mu ) ) {
			return new TypeError( 'cdf()::invalid option. `mu` parameter must be a number primitive. Option: `' + opts.mu + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isNonNegative( opts.sigma ) ) {
			return new TypeError( 'cdf()::invalid option. `sigma` parameter must be a non-negative number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'cdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'cdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'cdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'cdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'cdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":2012,"validate.io-function":2013,"validate.io-nonnegative":2018,"validate.io-number-primitive":2020,"validate.io-object":2021,"validate.io-string-primitive":2023}],1951:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],1952:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":1951,"dup":63}],1953:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"dup":187}],1954:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],1955:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":1958,"./iget.js":1960,"./iset.js":1963,"./mget.js":1967,"./mset.js":1969,"./set.js":1977,"./sget.js":1979,"./sset.js":1981,"./toString.js":1983,"dup":2}],1956:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":1959,"./iget.raw.js":1961,"./iset.raw.js":1964,"./mget.raw.js":1968,"./mset.raw.js":1970,"./set.raw.js":1978,"./sget.raw.js":1980,"./sset.raw.js":1982,"./toString.js":1983,"dup":3}],1957:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],1958:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2015}],1959:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],1960:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":1995}],1961:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],1962:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":1965,"./matrix.raw.js":1966,"dup":9}],1963:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":1995,"validate.io-number-primitive":2020}],1964:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],1965:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":1954,"./ctor.js":1955,"./dtypes.js":1957,"compute-cast-arrays":1984,"compute-dtype":1987,"dup":12,"validate.io-array":1992,"validate.io-contains":1993,"validate.io-nonnegative-integer-array":1996,"validate.io-string-primitive":2023}],1966:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":1954,"./ctor.raw.js":1956,"./dtypes.js":1957,"compute-dtype":1987,"dup":13,"validate.io-contains":1993,"validate.io-string-primitive":2023}],1967:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":1954,"dup":14,"validate.io-nonnegative-integer-array":1996}],1968:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":1954,"dup":15}],1969:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":1971,"./mset2.js":1972,"./mset3.js":1973,"./mset4.js":1974,"./mset5.js":1975,"./mset6.js":1976,"dup":16,"validate.io-function":2013,"validate.io-nonnegative-integer-array":1996,"validate.io-number-primitive":2020}],1970:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":1971,"./mset2.js":1972,"./mset3.js":1973,"./mset4.js":1974,"./mset5.js":1975,"./mset6.js":1976,"dup":17}],1971:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],1972:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],1973:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],1974:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],1975:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1976:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],1977:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2015,"validate.io-number-primitive":2020}],1978:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],1979:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":1954,"compute-indexspace":1991,"dup":26,"validate.io-string-primitive":2023}],1980:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":1954,"compute-indexspace":1991,"dup":27}],1981:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":1991,"dup":28,"validate.io-function":2013,"validate.io-number-primitive":2020,"validate.io-string-primitive":2023}],1982:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":1991,"dup":29}],1983:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],1984:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":1951,"compute-array-dtype/lib/dtypes":1985,"dup":31,"type-name":1986,"validate.io-array-like":2009}],1985:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1986:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1987:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":1989,"dup":36,"type-name":1990}],1988:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],1989:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":1988,"dup":38}],1990:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],1991:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2015,"validate.io-string-primitive":2023}],1992:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],1993:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":1992,"validate.io-nan-primitive":1994}],1994:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],1995:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2020}],1996:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":1992,"validate.io-nonnegative-integer":2015}],1997:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],1998:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],1999:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":1997,"./defaults.js":1998,"./validate.js":2001,"dup":111,"validate.io-array":2002,"validate.io-string-primitive":2023}],2000:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":1997,"./defaults.js":1998,"./factory.js":1999,"./validate.js":2001,"dup":112,"validate.io-array":2002,"validate.io-string-primitive":2023}],2001:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2021,"validate.io-string-primitive":2023}],2002:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2003:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2004:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2005:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2003,"./defaults.js":2004,"./validate.js":2007,"dup":117,"validate.io-array":2008,"validate.io-string-primitive":2023}],2006:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2003,"./defaults.js":2004,"./factory.js":2005,"./validate.js":2007,"dup":118,"validate.io-array":2008,"validate.io-string-primitive":2023}],2007:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2012,"validate.io-object":2021,"validate.io-string-primitive":2023}],2008:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2009:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2010,"dup":34,"validate.io-integer-primitive":2011}],2010:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2011:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2020}],2012:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2013:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2014:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2015:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2016}],2016:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2017}],2017:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2018:[function(require,module,exports){
arguments[4][1110][0].apply(exports,arguments)
},{"dup":1110,"validate.io-number":2019}],2019:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2020:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2021:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2022}],2022:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2023:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2024:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2025,"dup":132,"validate.io-integer-primitive":2026}],2025:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2026:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2020}],2027:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, mu, sigma, accessor )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean 
* @param {Number} sigma - standard deviation
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, mu, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":2033}],2028:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, mu, sigma )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean 
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":2033}],2029:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( arr, mu, sigma, path[, sep] )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} mu - mean 
* @param {Number} sigma - standard deviation
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function pdf( x, mu, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 4 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( mu, sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":2033,"utils-deep-get":2084,"utils-deep-set":2090}],2030:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var pdf1 = require( './number.js' ),
	pdf2 = require( './array.js' ),
	pdf3 = require( './accessor.js' ),
	pdf4 = require( './deepset.js' ),
	pdf5 = require( './matrix.js' ),
	pdf6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: pdf( x[, opts] )
*	Evaluates the probability density function (PDF) for a Normal distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.mu=0] - mean 
* @param {Number} [opts.sigma=1] - standard deviation
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated PDF
*/
function pdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.mu = typeof opts.mu !== 'undefined' ? opts.mu : 0;
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( x ) ) {
		return pdf1( x, opts.mu, opts.sigma );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return pdf5( out, x, opts.mu, opts.sigma );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return pdf6( out, x, opts.mu, opts.sigma );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return pdf4( x, opts.mu, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return pdf3( out, x, opts.mu, opts.sigma, opts.accessor );
		}
		return pdf2( out, x, opts.mu, opts.sigma );
	}
	return NaN;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./accessor.js":2027,"./array.js":2028,"./deepset.js":2029,"./matrix.js":2031,"./number.js":2032,"./typedarray.js":2034,"./validate.js":2035,"compute-array-constructors":2037,"dstructs-matrix":2046,"validate.io-array-like":2093,"validate.io-matrix-like":2098,"validate.io-number-primitive":2104,"validate.io-typed-array-like":2108}],2031:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, matrix, mu, sigma )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} mu - mean 
* @param {Number} sigma - standard deviation
* @returns {Matrix} output matrix
*/
function pdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'pdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":2033}],2032:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp,
	pow = Math.pow,
	sqrt = Math.sqrt;


// VARIABLES //

var PI = Math.PI;


// PDF //

/**
* FUNCTION: pdf( x, mu, sigma )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number} evaluated PDF
*/
function pdf( x, mu, sigma ) {
	if ( sigma === 0 ) {
		return x === mu ? Number.POSITIVE_INFINITY : 0;
	}
	var s2 = pow( sigma, 2 ),
		A = 1 / ( sqrt( 2 * s2 * PI ) ),
		B = -1 / ( 2 * s2 );
	return A * exp( B * pow( x - mu, 2 ) );
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{}],2033:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp,
	pow = Math.pow,
	sqrt = Math.sqrt;


// VARIABLES //

var PI = Math.PI;


// PARTIAL //

/**
* FUNCTION: partial( mu, sigma )
*	Partially applies mean  `mu` and standard deviation `sigma` and returns a function for evaluating the probability density function (PDF) for a Normal distribution.
*
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Function} PDF
*/
function partial( mu, sigma ) {
	var s2 = pow( sigma, 2 ),
		A = 1 / ( sqrt( 2 * s2 * PI ) ),
		B = -1 / ( 2 * s2 );
	/**
	* FUNCTION: pdf( x )
	*	Evaluates the probability density function (PDF) for a Normal distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated PDF
	*/
	if ( sigma === 0 ) {
		return function pdf( x ) {
			return x === mu ? Number.POSITIVE_INFINITY : 0;
		};
	}
	return function pdf( x ) {
		return A * exp( B * pow( x - mu, 2 ) );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],2034:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, mu, sigma )
*	Evaluates the probability density function (PDF) for a Normal distribution with mean  `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} mu - mean 
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":2033}],2035:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isNonNegative = require( 'validate.io-nonnegative' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.mu] - mean
* @param {Number} [options.sigma] - standard deviation
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'pdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'mu' ) ) {
		opts.mu = options.mu;
		if ( !isNumber( opts.mu ) ) {
			return new TypeError( 'pdf()::invalid option. `mu` parameter must be a number primitive. Option: `' + opts.mu + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isNonNegative( opts.sigma ) ) {
			return new TypeError( 'pdf()::invalid option. `sigma` parameter must be a non-negative number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'pdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'pdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'pdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'pdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'pdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":2096,"validate.io-function":2097,"validate.io-nonnegative":2102,"validate.io-number-primitive":2104,"validate.io-object":2105,"validate.io-string-primitive":2107}],2036:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2037:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2036,"dup":63}],2038:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2039:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2042,"./iget.js":2044,"./iset.js":2047,"./mget.js":2051,"./mset.js":2053,"./set.js":2061,"./sget.js":2063,"./sset.js":2065,"./toString.js":2067,"dup":2}],2040:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2043,"./iget.raw.js":2045,"./iset.raw.js":2048,"./mget.raw.js":2052,"./mset.raw.js":2054,"./set.raw.js":2062,"./sget.raw.js":2064,"./sset.raw.js":2066,"./toString.js":2067,"dup":3}],2041:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2042:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2099}],2043:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2044:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2079}],2045:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2046:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2049,"./matrix.raw.js":2050,"dup":9}],2047:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2079,"validate.io-number-primitive":2104}],2048:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2049:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2038,"./ctor.js":2039,"./dtypes.js":2041,"compute-cast-arrays":2068,"compute-dtype":2071,"dup":12,"validate.io-array":2076,"validate.io-contains":2077,"validate.io-nonnegative-integer-array":2080,"validate.io-string-primitive":2107}],2050:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2038,"./ctor.raw.js":2040,"./dtypes.js":2041,"compute-dtype":2071,"dup":13,"validate.io-contains":2077,"validate.io-string-primitive":2107}],2051:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2038,"dup":14,"validate.io-nonnegative-integer-array":2080}],2052:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2038,"dup":15}],2053:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2055,"./mset2.js":2056,"./mset3.js":2057,"./mset4.js":2058,"./mset5.js":2059,"./mset6.js":2060,"dup":16,"validate.io-function":2097,"validate.io-nonnegative-integer-array":2080,"validate.io-number-primitive":2104}],2054:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2055,"./mset2.js":2056,"./mset3.js":2057,"./mset4.js":2058,"./mset5.js":2059,"./mset6.js":2060,"dup":17}],2055:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2056:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2057:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2058:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2059:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2060:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2061:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2099,"validate.io-number-primitive":2104}],2062:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2063:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2038,"compute-indexspace":2075,"dup":26,"validate.io-string-primitive":2107}],2064:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2038,"compute-indexspace":2075,"dup":27}],2065:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2075,"dup":28,"validate.io-function":2097,"validate.io-number-primitive":2104,"validate.io-string-primitive":2107}],2066:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2075,"dup":29}],2067:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2068:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2036,"compute-array-dtype/lib/dtypes":2069,"dup":31,"type-name":2070,"validate.io-array-like":2093}],2069:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2070:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2071:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2073,"dup":36,"type-name":2074}],2072:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2073:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2072,"dup":38}],2074:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2075:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2099,"validate.io-string-primitive":2107}],2076:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2077:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2076,"validate.io-nan-primitive":2078}],2078:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2079:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2104}],2080:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2076,"validate.io-nonnegative-integer":2099}],2081:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2082:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2083:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2081,"./defaults.js":2082,"./validate.js":2085,"dup":111,"validate.io-array":2086,"validate.io-string-primitive":2107}],2084:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2081,"./defaults.js":2082,"./factory.js":2083,"./validate.js":2085,"dup":112,"validate.io-array":2086,"validate.io-string-primitive":2107}],2085:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2105,"validate.io-string-primitive":2107}],2086:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2087:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2088:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2089:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2087,"./defaults.js":2088,"./validate.js":2091,"dup":117,"validate.io-array":2092,"validate.io-string-primitive":2107}],2090:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2087,"./defaults.js":2088,"./factory.js":2089,"./validate.js":2091,"dup":118,"validate.io-array":2092,"validate.io-string-primitive":2107}],2091:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2096,"validate.io-object":2105,"validate.io-string-primitive":2107}],2092:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2093:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2094,"dup":34,"validate.io-integer-primitive":2095}],2094:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2095:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2104}],2096:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2097:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2098:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2099:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2100}],2100:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2101}],2101:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2102:[function(require,module,exports){
arguments[4][1110][0].apply(exports,arguments)
},{"dup":1110,"validate.io-number":2103}],2103:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2104:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2105:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2106}],2106:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2107:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2108:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2109,"dup":132,"validate.io-integer-primitive":2110}],2109:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2110:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2104}],2111:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, mu, sigma, accessor )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, mu, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":2117}],2112:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, mu, sigma )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":2117}],2113:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( arr, mu, sigma, path[, sep] )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function quantile( x, mu, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 4 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( mu, sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":2117,"utils-deep-get":2172,"utils-deep-set":2178}],2114:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var quantile1 = require( './number.js' ),
	quantile2 = require( './array.js' ),
	quantile3 = require( './accessor.js' ),
	quantile4 = require( './deepset.js' ),
	quantile5 = require( './matrix.js' ),
	quantile6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: quantile( p[, opts] )
*	Evaluates the quantile function for a Normal distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} p - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.mu=0] - mean
* @param {Number} [opts.sigma=1] - standard deviation
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} quantile function value(s)
*/
function quantile( p, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.mu = typeof opts.mu !== 'undefined' ? opts.mu : 0;
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( p ) ) {
		return quantile1( p, opts.mu, opts.sigma );
	}
	if ( isMatrixLike( p ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( p.length );
			out = matrix( d, p.shape, dt );
		} else {
			out = p;
		}
		return quantile5( out, p, opts.mu, opts.sigma );
	}
	if ( isTypedArrayLike( p ) ) {
		if ( opts.copy === false ) {
			out = p;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( p.length );
		}
		return quantile6( out, p, opts.mu, opts.sigma );
	}
	if ( isArrayLike( p ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return quantile4( p, opts.mu, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = p;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( p.length );
		}
		else {
			out = new Array( p.length );
		}
		if ( opts.accessor ) {
			return quantile3( out, p, opts.mu, opts.sigma, opts.accessor );
		}
		return quantile2( out, p, opts.mu, opts.sigma );
	}
	return NaN;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./accessor.js":2111,"./array.js":2112,"./deepset.js":2113,"./matrix.js":2115,"./number.js":2116,"./typedarray.js":2118,"./validate.js":2119,"compute-array-constructors":2121,"dstructs-matrix":2134,"validate.io-array-like":2181,"validate.io-matrix-like":2186,"validate.io-number-primitive":2192,"validate.io-typed-array-like":2196}],2115:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, matrix, mu, sigma )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Matrix} output matrix
*/
function quantile( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'quantile()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":2117}],2116:[function(require,module,exports){
'use strict';

// MODULES //

var erfinv = require( 'compute-erfinv/lib/number.js' );


// FUNCTIONS //

var sqrt = Math.sqrt;


// QUANTILE //

/**
* FUNCTION: quantile( p, mu, sigma )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` at a probability `p`.
*
* @param {Number} p - input value
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number} evaluated quantile function
*/
function quantile( p, mu, sigma ) {
	if ( p !== p || p < 0 || p > 1 ) {
		return NaN;
	}
	if ( sigma === 0 ) {
		return mu;
	}

	var A = mu,
		B = sigma * sqrt( 2 );

	return A + B * erfinv( 2 * p - 1 );
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"compute-erfinv/lib/number.js":2122}],2117:[function(require,module,exports){
'use strict';

// MODULES //

var erfinv = require( 'compute-erfinv/lib/number.js' );


// FUNCTIONS //

var sqrt = Math.sqrt;


// PARTIAL //

/**
* FUNCTION: partial( mu, sigma )
*	Partially applies mean `mu` and standard deviation `sigma` and returns a function for evaluating the quantile function for a Normal distribution.
*
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Function} quantile function
*/
function partial( mu, sigma ) {
	var A = mu,
		B = sigma * sqrt( 2 );
	/**
	* FUNCTION: quantile( p )
	*	Evaluates the quantile function for a Normal distribution.
	*
	* @private
	* @param {Number} p - input value
	* @returns {Number} evaluated quantile function
	*/
	if ( sigma === 0 ) {
		return function quantile( p ) {
			if ( p !== p || p < 0 || p > 1 ) {
				return NaN;
			}
			return mu;
		};
	}
	return function quantile( p ) {
		if ( p !== p || p < 0 || p > 1 ) {
			return NaN;
		}
		return A + B * erfinv( 2 * p - 1 );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{"compute-erfinv/lib/number.js":2122}],2118:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, mu, sigma )
*	Evaluates the quantile function for a Normal distribution with mean `mu` and standard deviation `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} mu - mean
* @param {Number} sigma - standard deviation
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, mu, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( mu, sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":2117}],2119:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isNonNegative = require( 'validate.io-nonnegative' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.mu] - mean
* @param {Number} [options.sigma] - standard deviation
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'quantile()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'mu' ) ) {
		opts.mu = options.mu;
		if ( !isNumber( opts.mu ) ) {
			return new TypeError( 'quantile()::invalid option. `mu` parameter must be a number primitive. Option: `' + opts.mu + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isNonNegative( opts.sigma ) ) {
			return new TypeError( 'quantile()::invalid option. `sigma` parameter must be a non-negative number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'quantile()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'quantile()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'quantile()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'quantile()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'quantile()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":2184,"validate.io-function":2185,"validate.io-nonnegative":2190,"validate.io-number-primitive":2192,"validate.io-object":2193,"validate.io-string-primitive":2195}],2120:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2121:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2120,"dup":63}],2122:[function(require,module,exports){
arguments[4][430][0].apply(exports,arguments)
},{"compute-polynomial":2123,"dup":430}],2123:[function(require,module,exports){
arguments[4][775][0].apply(exports,arguments)
},{"dup":775,"validate.io-array":2124,"validate.io-boolean-primitive":2184,"validate.io-function":2185,"validate.io-number-primitive":2192,"validate.io-number-primitive-array":2125,"validate.io-object":2193}],2124:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2125:[function(require,module,exports){
arguments[4][779][0].apply(exports,arguments)
},{"dup":779,"validate.io-array":2124}],2126:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2127:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2130,"./iget.js":2132,"./iset.js":2135,"./mget.js":2139,"./mset.js":2141,"./set.js":2149,"./sget.js":2151,"./sset.js":2153,"./toString.js":2155,"dup":2}],2128:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2131,"./iget.raw.js":2133,"./iset.raw.js":2136,"./mget.raw.js":2140,"./mset.raw.js":2142,"./set.raw.js":2150,"./sget.raw.js":2152,"./sset.raw.js":2154,"./toString.js":2155,"dup":3}],2129:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2130:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2187}],2131:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2132:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2167}],2133:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2134:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2137,"./matrix.raw.js":2138,"dup":9}],2135:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2167,"validate.io-number-primitive":2192}],2136:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2137:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2126,"./ctor.js":2127,"./dtypes.js":2129,"compute-cast-arrays":2156,"compute-dtype":2159,"dup":12,"validate.io-array":2164,"validate.io-contains":2165,"validate.io-nonnegative-integer-array":2168,"validate.io-string-primitive":2195}],2138:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2126,"./ctor.raw.js":2128,"./dtypes.js":2129,"compute-dtype":2159,"dup":13,"validate.io-contains":2165,"validate.io-string-primitive":2195}],2139:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2126,"dup":14,"validate.io-nonnegative-integer-array":2168}],2140:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2126,"dup":15}],2141:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2143,"./mset2.js":2144,"./mset3.js":2145,"./mset4.js":2146,"./mset5.js":2147,"./mset6.js":2148,"dup":16,"validate.io-function":2185,"validate.io-nonnegative-integer-array":2168,"validate.io-number-primitive":2192}],2142:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2143,"./mset2.js":2144,"./mset3.js":2145,"./mset4.js":2146,"./mset5.js":2147,"./mset6.js":2148,"dup":17}],2143:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2144:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2145:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2146:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2147:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2148:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2149:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2187,"validate.io-number-primitive":2192}],2150:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2151:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2126,"compute-indexspace":2163,"dup":26,"validate.io-string-primitive":2195}],2152:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2126,"compute-indexspace":2163,"dup":27}],2153:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2163,"dup":28,"validate.io-function":2185,"validate.io-number-primitive":2192,"validate.io-string-primitive":2195}],2154:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2163,"dup":29}],2155:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2156:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2120,"compute-array-dtype/lib/dtypes":2157,"dup":31,"type-name":2158,"validate.io-array-like":2181}],2157:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2158:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2159:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2161,"dup":36,"type-name":2162}],2160:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2161:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2160,"dup":38}],2162:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2163:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2187,"validate.io-string-primitive":2195}],2164:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2165:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2164,"validate.io-nan-primitive":2166}],2166:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2167:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2192}],2168:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2164,"validate.io-nonnegative-integer":2187}],2169:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2170:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2171:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2169,"./defaults.js":2170,"./validate.js":2173,"dup":111,"validate.io-array":2174,"validate.io-string-primitive":2195}],2172:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2169,"./defaults.js":2170,"./factory.js":2171,"./validate.js":2173,"dup":112,"validate.io-array":2174,"validate.io-string-primitive":2195}],2173:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2193,"validate.io-string-primitive":2195}],2174:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2175:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2176:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2177:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2175,"./defaults.js":2176,"./validate.js":2179,"dup":117,"validate.io-array":2180,"validate.io-string-primitive":2195}],2178:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2175,"./defaults.js":2176,"./factory.js":2177,"./validate.js":2179,"dup":118,"validate.io-array":2180,"validate.io-string-primitive":2195}],2179:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2184,"validate.io-object":2193,"validate.io-string-primitive":2195}],2180:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2181:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2182,"dup":34,"validate.io-integer-primitive":2183}],2182:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2183:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2192}],2184:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2185:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2186:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2187:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2188}],2188:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2189}],2189:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2190:[function(require,module,exports){
arguments[4][1110][0].apply(exports,arguments)
},{"dup":1110,"validate.io-number":2191}],2191:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2192:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2193:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2194}],2194:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2195:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2196:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2197,"dup":132,"validate.io-integer-primitive":2198}],2197:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2198:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2192}],2199:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// RANDOM //

/**
* FUNCTION: random( len, mu, sigma[, rand] )
*	Creates an array of normally distributed random numbers.
*
* @param {Number} len - array length
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Number[]} array filled with normal random numbers
*/
function random( len, mu, sigma, rand ) {
	var out,
		draw,
		i;

	draw = partial( mu, sigma, rand );
	// Ensure fast elements...
	if ( len < 64000 ) {
		out = new Array( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = draw();
		}
	} else {
		out = [];
		for ( i = 0; i < len; i++ ) {
			out.push( draw() );
		}
	}
	return out;
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

},{"./partial.js":2205}],2200:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' ),
	recurse = require( './recurse.js' );


// RANDOM //

/**
* FUNCTION: random( dims, mu, sigma[, rand] )
*	Creates a multidimensional array of normally distributed random numbers.
*
* @param {Number[]} dims - dimensions
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Array} multidimensional array filled with normal random numbers
*/
function random( dims, mu, sigma, rand ) {
	var draw = partial( mu, sigma, rand );
	return recurse( dims, 0, draw );
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

},{"./partial.js":2205,"./recurse.js":2206}],2201:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ln = Math.log;


// NORMAL TAIL //

/**
* FUNCTION dRanNormalTail( dMin, iNegative, rand )
*	Transform the tail of the normal distribution to
*	the unit interval and then use rejection technique
*	to generate standar normal variable.
*	Reference:
*		Marsaclia, G. (1964). Generating a Variable from the Tail
*		of the Normal Distribution. Technometrics, 6(1),
*		101–102. doi:10.1080/00401706.1964.10490150
*
* @param {Number} dMin - start value of the right tail
* @param {Boolean} iNegative - boolean indicating which side to evaluate
* @returns {Number} standard normal variable
*/
function dRanNormalTail( dMin, iNegative, rand ) {
	var x, y;
	do {
		x = ln( rand() ) / dMin;
		y = ln( rand() );
	} while ( -2 * y < x * x );
	return iNegative ? x - dMin : dMin - x;
} // end FUNCTION dRanNormalTail()


// EXPORTS //

module.exports = dRanNormalTail;

},{}],2202:[function(require,module,exports){
'use strict';

// MODULES //

var isPositiveIntegerArray = require( 'validate.io-positive-integer-array' ),
	isPositiveInteger = require( 'validate.io-positive-integer' ),
	lcg = require( 'compute-lcg' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var array = require( './array.js' ),
	typedarray = require( './typedarray.js' ),
	arrayarray = require( './arrayarray.js' ),
	matrix = require( './matrix.js' ),
	number = require( './number.js' );


// UNIFORM GENERATOR //

var RAND = lcg();


// NORMAL RANDOM VARIATES //

/**
* FUNCTION: random( [dims][, opts] )
*	Creates a matrix or array filled with normal random numbers.
*
* @param {Number|Number[]} [dims] - dimensions
* @param {Object} [opts] - function options
* @param {Number} [opts.mu=0] - mean parameter
* @param {Number} [opts.sigma=1] - standard deviation
* @param {String} [opts.dtype="generic"] - output data type
* @param {Number} [opts.seed] - integer-valued seed
* @returns {Array|Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} random numbers
*/
function random( dims, options ) {
	var opts = {},
		isArray,
		ndims,
		err,
		len,
		mu,
		sigma,
		rand,
		dt;

	if ( arguments.length > 0 ) {
		isArray = isPositiveIntegerArray( dims );
		if ( !isArray && !isPositiveInteger( dims ) ) {
			throw new TypeError( 'random()::invalid input argument. Dimensions argument must be either a positive integer or a positive integer array. Value: `' + dims + '`.' );
		}
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}

	if ( opts.seed ) {
		rand = lcg( opts.seed );
	} else {
		rand = RAND;
	}
	dt = opts.dtype || 'generic';

	mu = typeof opts.mu !== 'undefined' ? opts.mu : 0;
	sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( arguments.length === 0 ) {
		return number( mu, sigma, rand );
	}
	if ( isArray ) {
		ndims = dims.length;
		if ( ndims < 2 ) {
			len = dims[ 0 ];
		}
	} else {
		ndims = 1;
		len = dims;
	}
	// 1-dimensional data structures...
	if ( ndims === 1 ) {
		if ( len === 1 ) {
			return number( mu, sigma, rand );
		}
		if ( dt === 'generic' ) {
			return array( len, mu, sigma, rand );
		}
		return typedarray( len, dt, mu, sigma, rand );
	}
	// Multidimensional data structures...
	if ( dt !== 'generic' ) {
		if ( ndims === 2 ) {
			return matrix( dims, dt, mu, sigma, rand );
		}
		// TODO: dstructs-ndarray support goes here. Until then, fall through to plain arrays...
	}
	return arrayarray( dims, mu, sigma, rand );
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

Object.defineProperty( module.exports, 'seed', {
	set: function ( newVal ) {
		if ( !isPositiveInteger( newVal ) ) {
			throw new TypeError( 'random()::invalid value. Seed property must be a positive integer. Option: `' + newVal + '`.' );
		}
		RAND = lcg( newVal );
	}
});

},{"./array.js":2199,"./arrayarray.js":2200,"./matrix.js":2203,"./number.js":2204,"./typedarray.js":2207,"./validate.js":2208,"compute-lcg":2211,"validate.io-positive-integer":2268,"validate.io-positive-integer-array":2266}],2203:[function(require,module,exports){
'use strict';

// MODULES //

var matrix = require( 'dstructs-matrix' ),
	partial = require( './partial.js' );


// RANDOM //

/**
* FUNCTION: random( dims, dt, mu, sigma[, rand] )
*	Creates a matrix of normally distributed random numbers.
*
* @param {Number[]} dims - dimensions
* @param {String} dt - data type
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Matrix} matrix filled with normal random numbers
*/
function random( dims, dt, mu, sigma, rand ) {
	var out,
		draw,
		i;

	draw = partial( mu, sigma, rand );
	out = matrix( dims, dt );
	for ( i = 0; i < out.length; i++ ) {
		out.data[ i ] = draw();
	}
	return out;
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

},{"./partial.js":2205,"dstructs-matrix":2220}],2204:[function(require,module,exports){
'use strict';

// MODULES //

var dRanNormalTail = require( './dRanNormalTail.js' );


// FUNCTIONS //

var abs = Math.abs,
	exp = Math.exp,
	log = Math.log,
	pow = Math.pow,
	sqrt = Math.sqrt;


// CONSTANTS //

var TWO_P_32 = pow( 2, 32);


// GENERATE NORMAL RANDOM NUMBERS //

/**
* FUNCTION random( mu, sigma[, rand] )
*	Generates a random draw from a normal distribution
*	with parameters `mu` and `sigma`. Implementation
*	of the "Improved Ziggurat Method" by J. Doornik.
*	Reference:
*		Doornik, J. a. (2005).
*		An Improved Ziggurat Method to Generate Normal Random Samples.
*
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Number} random draw from the specified distribution
*/
function random( mu, sigma, rand ) {

	if ( !rand ) {
		rand = Math.random;
	}

	var ZIGNOR_C = 128,/* number of blocks */
 		ZIGNOR_R = 3.442619855899, /* start of the right tail *
		/* (R * phi(R) + Pr(X>=R)) * sqrt(2\pi) */
		ZIGNOR_V = 9.91256303526217e-3,
		/* s_adZigX holds coordinates, such that each rectangle has
			same area; s_adZigR holds s_adZigX[i + 1] / s_adZigX[i] */
		s_adZigX = new Array( ZIGNOR_C + 1 ),
		s_adZigR = new Array( ZIGNOR_C ),
		i, f;

	f = exp( -0.5 * ZIGNOR_R * ZIGNOR_R );
	s_adZigX[0] = ZIGNOR_V / f; /* [0] is bottom block: V / f(R) */
	s_adZigX[1] = ZIGNOR_R;
	s_adZigX[ZIGNOR_C] = 0;
	for ( i = 2; i < ZIGNOR_C; i++ ) {
		s_adZigX[i] = sqrt( -2 * log( ZIGNOR_V / s_adZigX[i - 1] + f ) );
		f = exp( -0.5 * s_adZigX[i] * s_adZigX[i] );
	}
	for ( i = 0; i < ZIGNOR_C; i++ ) {
		s_adZigR[i] = s_adZigX[i + 1] / s_adZigX[i];
	}
	var x, u, f0, f1;
	for (;;) {
		u = 2 * rand() - 1;
		i = TWO_P_32 * rand() & 0x7F;
		/* first try the rectangular boxes */
		if ( abs(u) < s_adZigR[i] ) {
			return mu + sigma * u * s_adZigX[i];
		}
		/* bottom box: sample from the tail */
		if ( i === 0 ) {
			return mu + sigma * dRanNormalTail( ZIGNOR_R, u < 0, rand );
		}
		/* is this a sample from the wedges? */
		x = u * s_adZigX[i];
		f0 = exp( -0.5 * ( s_adZigX[i] * s_adZigX[i] - x * x ) );
		f1 = exp( -0.5 * ( s_adZigX[i+1] * s_adZigX[i+1] - x * x ) );
		if ( f1 + rand() * (f0 - f1) < 1.0 ) {
			return mu + sigma * x;
		}
	}
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

},{"./dRanNormalTail.js":2201}],2205:[function(require,module,exports){
'use strict';

// MODULES //

var dRanNormalTail = require( './dRanNormalTail.js' );


// FUNCTIONS  //

var abs = Math.abs,
	exp = Math.exp,
	log = Math.log,
	pow = Math.pow,
	sqrt = Math.sqrt;


// PARTIAL //

/**
* FUNCTION: partial( mu, sigma[, rand] )
*	Partially applies `mu` and `sigma` and returns a function
*	to generate random variables from the normal distribution. Implementation
*	of the "Improved Ziggurat Method" by J. Doornik.
*	Reference:
*		Doornik, J. a. (2005).
*		An Improved Ziggurat Method to Generate Normal Random Samples.
*
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Function} function which generates random draws from the specified distribution
*/
function partial( mu, sigma, rand ) {
	var random,
		ZIGNOR_C = 128,/* number of blocks */
		ZIGNOR_R = 3.442619855899, /* start of the right tail *
		/* (R * phi(R) + Pr(X>=R)) * sqrt(2\pi) */
		ZIGNOR_V = 9.91256303526217e-3,
		/* s_adZigX holds coordinates, such that each rectangle has
			same area; s_adZigR holds s_adZigX[i + 1] / s_adZigX[i] */
		s_adZigX = new Array( ZIGNOR_C + 1 ),
		s_adZigR = new Array( ZIGNOR_C ),
		i, f,
		TWO_P_32 = pow( 2, 32 );

	if ( rand ) {
		random = rand;
	} else {
		random = Math.random;
	}

	f = exp( -0.5 * ZIGNOR_R * ZIGNOR_R );
	s_adZigX[0] = ZIGNOR_V / f; /* [0] is bottom block: V / f(R) */
	s_adZigX[1] = ZIGNOR_R;
	s_adZigX[ZIGNOR_C] = 0;
	for ( i = 2; i < ZIGNOR_C; i++ ) {
		s_adZigX[i] = sqrt( -2 * log( ZIGNOR_V / s_adZigX[i - 1] + f ) );
		f = exp( -0.5 * s_adZigX[i] * s_adZigX[i] );
	}
	for ( i = 0; i < ZIGNOR_C; i++ ) {
		s_adZigR[i] = s_adZigX[i + 1] / s_adZigX[i];
	}

	/**
	* FUNCTION: draw( x )
	*	Generates a random draw for a normal distribution with parameters `mu` and `sigma`.
	*
	* @private
	* @returns {Number} random draw from the specified distribution
	*/
	return function draw() {
		var x, u, f0, f1;
		for (;;) {
			u = 2 * random() - 1;
			i = TWO_P_32 * random() & 0x7F;
			/* first try the rectangular boxes */
			if ( abs(u) < s_adZigR[i] ) {
				return mu + sigma * u * s_adZigX[i];
			}
			/* bottom box: sample from the tail */
			if ( i === 0 ) {
				return mu + sigma * dRanNormalTail( ZIGNOR_R, u < 0, rand );
			}
			/* is this a sample from the wedges? */
			x = u * s_adZigX[i];
			f0 = exp( -0.5 * ( s_adZigX[i] * s_adZigX[i] - x * x ) );
			f1 = exp( -0.5 * ( s_adZigX[i+1] * s_adZigX[i+1] - x * x ) );
			if ( f1 + random() * (f0 - f1) < 1.0 ) {
				return mu + sigma * x;
			}
		}
	}; // end FUNCTION draw()
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{"./dRanNormalTail.js":2201}],2206:[function(require,module,exports){
'use strict';

/**
* FUNCTION: recurse( dims, d, draw )
*	Recursively create a multidimensional array of normally distributed random numbers.
*
* @param {Number[]} dims - dimensions
* @param {Number} d - current recursion depth
* @param {Function} draw - function to generate normal random numbers with given `mu` and `sigma`
* @returns {Array} output array
*/
function recurse( dims, d, draw ) {
	var out = [],
		len,
		i;

	len = dims[ d ];
	d += 1;
	if ( d < dims.length ) {
		for ( i = 0; i < len; i++ ) {
			out.push( recurse( dims, d, draw ) );
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			out.push( draw() );
		}
	}
	return out;
} // end FUNCTION recurse()


// EXPORTS //

module.exports = recurse;

},{}],2207:[function(require,module,exports){
'use strict';

// MODULES //

var ctors = require( 'compute-array-constructors' ),
	partial = require( './partial.js' );


// RANDOM //

/**
* FUNCTION: random( len, dt, mu, sigma[, rand] )
*	Creates a typed array of normally distributed random numbers.
*
* @param {Number} len - array length
* @param {String} dt - data type
* @param {Number} mu - mean parameter
* @param {Number} sigma - standard deviation
* @param {Function} [rand=Math.random] - random number generator
* @returns {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} typed array filled with normal random numbers
*/
function random( len, dt, mu, sigma, rand ) {
	/* jshint newcap:false */
	var ctor,
		out,
		draw,
		i;

	draw = partial( mu, sigma, rand );
	ctor = ctors( dt );
	if ( ctor === null ) {
		throw new Error( 'random()::invalid value. Data type does not have a corresponding array constructor. Value: `' + dt + '`.' );
	}
	out = new ctor( len );
	for ( i = 0; i < len; i++ ) {
		out[ i ] = draw();
	}
	return out;
} // end FUNCTION random()


// EXPORTS //

module.exports = random;

},{"./partial.js":2205,"compute-array-constructors":2210}],2208:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isNonNegative = require( 'validate.io-nonnegative' ),
	isNumber = require( 'validate.io-number-primitive' ),
	isPositiveInteger = require( 'validate.io-positive-integer' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.mu] - mean parameter
* @param {Number} [options.sigma] - standard deviation
* @param {String} [options.dtype] - output data type
* @param {Number} [options.seed] - integer-valued seed
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'random()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'mu' ) ) {
		opts.mu = options.mu;
		if ( !isNumber( opts.mu ) ) {
			return new TypeError( 'random()::invalid option. `mu` parameter must be a number primitive. Option: `' + opts.mu + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isNonNegative( opts.sigma ) ) {
			return new TypeError( 'random()::invalid option. `sigma` parameter must be a non-negative number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'random()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'seed' ) ) {
		opts.seed = options.seed;
		if ( !isPositiveInteger( opts.seed ) ) {
			return new TypeError( 'random()::invalid option. Seed option must be a positive integer. Option: `' + opts.seed + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-nonnegative":2262,"validate.io-number-primitive":3439,"validate.io-object":2264,"validate.io-positive-integer":2268,"validate.io-string-primitive":2271}],2209:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2210:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2209,"dup":63}],2211:[function(require,module,exports){
/**
*
*	COMPUTE: lcg
*
*
*	DESCRIPTION:
*		- A linear congruential pseudorandom number generator (lcg).
*
*
*	NOTES:
*		[1] Based on W. Press, et al., Numerical Recipes in C (2d ed. 1992)
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. rgizz.
*
*
*	AUTHOR:
*		rgizz. gztown2216@yahoo.com. 2014.
*
*/

'use strict';

// VARIABLES //

var MASK = 123459876,
	M = 2147483647,
	A = 16807;


// LCG //

/**
* FUNCTION: lcg( [seed] )
*	Returns a linear congruential pseudorandom number generator. If not provided a seed, a seed is generated based on the current time.
*
* @param {Number} [seed] - random number generator seed
* @returns {Function} generator
*/
function lcg( val ) {
	var seed;
	if ( arguments.length ) {
		if ( typeof val !== 'number' || val !== val || val % 1 !== 0 || val < 1 ) {
			throw new TypeError( 'lcg()::invalid input argument. Seed must be a positive integer.' );
		}
		seed = val;
	} else {
		seed = Date.now() % 100000000;
	}
	/**
	* FUNCTION: lcg( [N] )
	*	Linear congruential pseudorandom number generator.
	*
	* @param {Number} [N] - number of pseudorandom numbers to return
	* @returns {Number|Array} pseudorandom floating-point number(s) between 0 and 1
	*/
	return function lcg( N ) {
		var arr,
			rand;
		if ( !arguments.length ) {
			seed = seed ^ MASK;
			seed = ( A * seed ) % M;
			rand = seed / M;
			seed = seed ^ MASK;
			return rand;
		}
		if ( typeof N !== 'number' || N !== N || N%1 !== 0 || N < 1 ) {
			throw new TypeError( 'lcg()::invalid input argument. Array length must be a positive integer.' );
		}
		arr = new Array( N );
		for ( var i = 0; i < N; i++ ) {
			seed = seed ^ MASK;
			seed = ( A * seed ) % M;
			arr[ i ] = seed / M;
			seed = seed ^ MASK;
		}
		return arr;
	};
} // end FUNCTION lcg()


// EXPORTS //

module.exports = lcg;



},{}],2212:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2213:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2216,"./iget.js":2218,"./iset.js":2221,"./mget.js":2225,"./mset.js":2227,"./set.js":2235,"./sget.js":2237,"./sset.js":2239,"./toString.js":2241,"dup":2}],2214:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2217,"./iget.raw.js":2219,"./iset.raw.js":2222,"./mget.raw.js":2226,"./mset.raw.js":2228,"./set.raw.js":2236,"./sget.raw.js":2238,"./sset.raw.js":2240,"./toString.js":2241,"dup":3}],2215:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2216:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2258}],2217:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2218:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2256}],2219:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2220:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2223,"./matrix.raw.js":2224,"dup":9}],2221:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2256,"validate.io-number-primitive":2261}],2222:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2223:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2212,"./ctor.js":2213,"./dtypes.js":2215,"compute-cast-arrays":2242,"compute-dtype":2247,"dup":12,"validate.io-array":2252,"validate.io-contains":2253,"validate.io-nonnegative-integer-array":2257,"validate.io-string-primitive":2271}],2224:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2212,"./ctor.raw.js":2214,"./dtypes.js":2215,"compute-dtype":2247,"dup":13,"validate.io-contains":2253,"validate.io-string-primitive":2271}],2225:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2212,"dup":14,"validate.io-nonnegative-integer-array":2257}],2226:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2212,"dup":15}],2227:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2229,"./mset2.js":2230,"./mset3.js":2231,"./mset4.js":2232,"./mset5.js":2233,"./mset6.js":2234,"dup":16,"validate.io-function":2255,"validate.io-nonnegative-integer-array":2257,"validate.io-number-primitive":2261}],2228:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2229,"./mset2.js":2230,"./mset3.js":2231,"./mset4.js":2232,"./mset5.js":2233,"./mset6.js":2234,"dup":17}],2229:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2230:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2231:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2232:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2233:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2234:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2235:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2258,"validate.io-number-primitive":2261}],2236:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2237:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2212,"compute-indexspace":2251,"dup":26,"validate.io-string-primitive":2271}],2238:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2212,"compute-indexspace":2251,"dup":27}],2239:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2251,"dup":28,"validate.io-function":2255,"validate.io-number-primitive":2261,"validate.io-string-primitive":2271}],2240:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2251,"dup":29}],2241:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2242:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2209,"compute-array-dtype/lib/dtypes":2243,"dup":31,"type-name":2244,"validate.io-array-like":2245}],2243:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2244:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2245:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2246,"dup":34,"validate.io-integer-primitive":2256}],2246:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2247:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2249,"dup":36,"type-name":2250}],2248:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2249:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2248,"dup":38}],2250:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2251:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2258,"validate.io-string-primitive":2271}],2252:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2253:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2252,"validate.io-nan-primitive":2254}],2254:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2255:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2256:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2261}],2257:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2252,"validate.io-nonnegative-integer":2258}],2258:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2259}],2259:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2260}],2260:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2261:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2262:[function(require,module,exports){
arguments[4][1110][0].apply(exports,arguments)
},{"dup":1110,"validate.io-number":2263}],2263:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2264:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2265}],2265:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2266:[function(require,module,exports){
arguments[4][521][0].apply(exports,arguments)
},{"dup":521,"validate.io-array":2267,"validate.io-positive-integer":2268}],2267:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2268:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"dup":522,"validate.io-integer":2269}],2269:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2270}],2270:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2271:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2272:[function(require,module,exports){
arguments[4][1277][0].apply(exports,arguments)
},{"./number.js":2277,"dup":1277}],2273:[function(require,module,exports){
arguments[4][1278][0].apply(exports,arguments)
},{"./number.js":2277,"dup":1278}],2274:[function(require,module,exports){
arguments[4][1279][0].apply(exports,arguments)
},{"./number.js":2277,"dup":1279,"utils-deep-get":2328,"utils-deep-set":2334}],2275:[function(require,module,exports){
arguments[4][1280][0].apply(exports,arguments)
},{"./accessor.js":2272,"./array.js":2273,"./deepset.js":2274,"./matrix.js":2276,"./number.js":2277,"./typedarray.js":2278,"./validate.js":2279,"compute-array-constructors":2281,"dstructs-matrix":2290,"dup":1280,"validate.io-array-like":2337,"validate.io-matrix-like":2342,"validate.io-nan":2343,"validate.io-number-primitive":2347,"validate.io-typed-array-like":2352}],2276:[function(require,module,exports){
arguments[4][1281][0].apply(exports,arguments)
},{"./number.js":2277,"dup":1281}],2277:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// EKURTOSIS //

/**
* FUNCTION ekurtosis( lambda )
*	Computes the distribution ekurtosis for a Poisson distribution with parameter lambda.
*
* @param {Number} lambda - mean parameter
* @returns {Number} distribution ekurtosis
*/
function ekurtosis( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return 1 / lambda;
} // end FUNCTION ekurtosis()


// EXPORTS

module.exports =  ekurtosis;

},{"validate.io-positive-primitive":2350}],2278:[function(require,module,exports){
arguments[4][1283][0].apply(exports,arguments)
},{"./number.js":2277,"dup":1283}],2279:[function(require,module,exports){
arguments[4][1284][0].apply(exports,arguments)
},{"dup":1284,"validate.io-boolean-primitive":2340,"validate.io-function":2341,"validate.io-object":2348,"validate.io-string-primitive":2351}],2280:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2281:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2280,"dup":63}],2282:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2283:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2286,"./iget.js":2288,"./iset.js":2291,"./mget.js":2295,"./mset.js":2297,"./set.js":2305,"./sget.js":2307,"./sset.js":2309,"./toString.js":2311,"dup":2}],2284:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2287,"./iget.raw.js":2289,"./iset.raw.js":2292,"./mget.raw.js":2296,"./mset.raw.js":2298,"./set.raw.js":2306,"./sget.raw.js":2308,"./sset.raw.js":2310,"./toString.js":2311,"dup":3}],2285:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2286:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2344}],2287:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2288:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2323}],2289:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2290:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2293,"./matrix.raw.js":2294,"dup":9}],2291:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2323,"validate.io-number-primitive":2347}],2292:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2293:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2282,"./ctor.js":2283,"./dtypes.js":2285,"compute-cast-arrays":2312,"compute-dtype":2315,"dup":12,"validate.io-array":2320,"validate.io-contains":2321,"validate.io-nonnegative-integer-array":2324,"validate.io-string-primitive":2351}],2294:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2282,"./ctor.raw.js":2284,"./dtypes.js":2285,"compute-dtype":2315,"dup":13,"validate.io-contains":2321,"validate.io-string-primitive":2351}],2295:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2282,"dup":14,"validate.io-nonnegative-integer-array":2324}],2296:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2282,"dup":15}],2297:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2299,"./mset2.js":2300,"./mset3.js":2301,"./mset4.js":2302,"./mset5.js":2303,"./mset6.js":2304,"dup":16,"validate.io-function":2341,"validate.io-nonnegative-integer-array":2324,"validate.io-number-primitive":2347}],2298:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2299,"./mset2.js":2300,"./mset3.js":2301,"./mset4.js":2302,"./mset5.js":2303,"./mset6.js":2304,"dup":17}],2299:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2300:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2301:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2302:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2303:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2304:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2305:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2344,"validate.io-number-primitive":2347}],2306:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2307:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2282,"compute-indexspace":2319,"dup":26,"validate.io-string-primitive":2351}],2308:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2282,"compute-indexspace":2319,"dup":27}],2309:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2319,"dup":28,"validate.io-function":2341,"validate.io-number-primitive":2347,"validate.io-string-primitive":2351}],2310:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2319,"dup":29}],2311:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2312:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2280,"compute-array-dtype/lib/dtypes":2313,"dup":31,"type-name":2314,"validate.io-array-like":2337}],2313:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2314:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2315:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2317,"dup":36,"type-name":2318}],2316:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2317:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2316,"dup":38}],2318:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2319:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2344,"validate.io-string-primitive":2351}],2320:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2321:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2320,"validate.io-nan-primitive":2322}],2322:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2323:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2347}],2324:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2320,"validate.io-nonnegative-integer":2344}],2325:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2326:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2327:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2325,"./defaults.js":2326,"./validate.js":2329,"dup":111,"validate.io-array":2330,"validate.io-string-primitive":2351}],2328:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2325,"./defaults.js":2326,"./factory.js":2327,"./validate.js":2329,"dup":112,"validate.io-array":2330,"validate.io-string-primitive":2351}],2329:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2348,"validate.io-string-primitive":2351}],2330:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2331:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2332:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2333:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2331,"./defaults.js":2332,"./validate.js":2335,"dup":117,"validate.io-array":2336,"validate.io-string-primitive":2351}],2334:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2331,"./defaults.js":2332,"./factory.js":2333,"./validate.js":2335,"dup":118,"validate.io-array":2336,"validate.io-string-primitive":2351}],2335:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2340,"validate.io-object":2348,"validate.io-string-primitive":2351}],2336:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2337:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2338,"dup":34,"validate.io-integer-primitive":2339}],2338:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2339:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2347}],2340:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2341:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2342:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2343:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2344:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2345}],2345:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2346}],2346:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2347:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2348:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2349}],2349:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2350:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2347}],2351:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2352:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2353,"dup":132,"validate.io-integer-primitive":2354}],2353:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2354:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2347}],2355:[function(require,module,exports){
arguments[4][1360][0].apply(exports,arguments)
},{"./number.js":2360,"dup":1360}],2356:[function(require,module,exports){
arguments[4][1361][0].apply(exports,arguments)
},{"./number.js":2360,"dup":1361}],2357:[function(require,module,exports){
arguments[4][1362][0].apply(exports,arguments)
},{"./number.js":2360,"dup":1362,"utils-deep-get":2411,"utils-deep-set":2417}],2358:[function(require,module,exports){
arguments[4][1363][0].apply(exports,arguments)
},{"./accessor.js":2355,"./array.js":2356,"./deepset.js":2357,"./matrix.js":2359,"./number.js":2360,"./typedarray.js":2361,"./validate.js":2362,"compute-array-constructors":2364,"dstructs-matrix":2373,"dup":1363,"validate.io-array-like":2420,"validate.io-matrix-like":2425,"validate.io-nan":2426,"validate.io-number-primitive":2430,"validate.io-typed-array-like":2435}],2359:[function(require,module,exports){
arguments[4][1364][0].apply(exports,arguments)
},{"./number.js":2360,"dup":1364}],2360:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// MEAN //

/**
* FUNCTION mean( lambda )
*	Computes the distribution mean for a Poisson with parameter lambda.
*
* @param {Number} lambda - mean parameter
* @returns {Number} distribution mean
*/
function mean( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return lambda;
} // end FUNCTION mean()


// EXPORTS

module.exports =  mean;

},{"validate.io-positive-primitive":2433}],2361:[function(require,module,exports){
arguments[4][1366][0].apply(exports,arguments)
},{"./number.js":2360,"dup":1366}],2362:[function(require,module,exports){
arguments[4][1367][0].apply(exports,arguments)
},{"dup":1367,"validate.io-boolean-primitive":2423,"validate.io-function":2424,"validate.io-object":2431,"validate.io-string-primitive":2434}],2363:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2364:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2363,"dup":63}],2365:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2366:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2369,"./iget.js":2371,"./iset.js":2374,"./mget.js":2378,"./mset.js":2380,"./set.js":2388,"./sget.js":2390,"./sset.js":2392,"./toString.js":2394,"dup":2}],2367:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2370,"./iget.raw.js":2372,"./iset.raw.js":2375,"./mget.raw.js":2379,"./mset.raw.js":2381,"./set.raw.js":2389,"./sget.raw.js":2391,"./sset.raw.js":2393,"./toString.js":2394,"dup":3}],2368:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2369:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2427}],2370:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2371:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2406}],2372:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2373:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2376,"./matrix.raw.js":2377,"dup":9}],2374:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2406,"validate.io-number-primitive":2430}],2375:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2376:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2365,"./ctor.js":2366,"./dtypes.js":2368,"compute-cast-arrays":2395,"compute-dtype":2398,"dup":12,"validate.io-array":2403,"validate.io-contains":2404,"validate.io-nonnegative-integer-array":2407,"validate.io-string-primitive":2434}],2377:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2365,"./ctor.raw.js":2367,"./dtypes.js":2368,"compute-dtype":2398,"dup":13,"validate.io-contains":2404,"validate.io-string-primitive":2434}],2378:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2365,"dup":14,"validate.io-nonnegative-integer-array":2407}],2379:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2365,"dup":15}],2380:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2382,"./mset2.js":2383,"./mset3.js":2384,"./mset4.js":2385,"./mset5.js":2386,"./mset6.js":2387,"dup":16,"validate.io-function":2424,"validate.io-nonnegative-integer-array":2407,"validate.io-number-primitive":2430}],2381:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2382,"./mset2.js":2383,"./mset3.js":2384,"./mset4.js":2385,"./mset5.js":2386,"./mset6.js":2387,"dup":17}],2382:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2383:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2384:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2385:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2386:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2387:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2388:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2427,"validate.io-number-primitive":2430}],2389:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2390:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2365,"compute-indexspace":2402,"dup":26,"validate.io-string-primitive":2434}],2391:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2365,"compute-indexspace":2402,"dup":27}],2392:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2402,"dup":28,"validate.io-function":2424,"validate.io-number-primitive":2430,"validate.io-string-primitive":2434}],2393:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2402,"dup":29}],2394:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2395:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2363,"compute-array-dtype/lib/dtypes":2396,"dup":31,"type-name":2397,"validate.io-array-like":2420}],2396:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2397:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2398:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2400,"dup":36,"type-name":2401}],2399:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2400:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2399,"dup":38}],2401:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2402:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2427,"validate.io-string-primitive":2434}],2403:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2404:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2403,"validate.io-nan-primitive":2405}],2405:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2406:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2430}],2407:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2403,"validate.io-nonnegative-integer":2427}],2408:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2409:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2410:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2408,"./defaults.js":2409,"./validate.js":2412,"dup":111,"validate.io-array":2413,"validate.io-string-primitive":2434}],2411:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2408,"./defaults.js":2409,"./factory.js":2410,"./validate.js":2412,"dup":112,"validate.io-array":2413,"validate.io-string-primitive":2434}],2412:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2431,"validate.io-string-primitive":2434}],2413:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2414:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2415:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2416:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2414,"./defaults.js":2415,"./validate.js":2418,"dup":117,"validate.io-array":2419,"validate.io-string-primitive":2434}],2417:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2414,"./defaults.js":2415,"./factory.js":2416,"./validate.js":2418,"dup":118,"validate.io-array":2419,"validate.io-string-primitive":2434}],2418:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2423,"validate.io-object":2431,"validate.io-string-primitive":2434}],2419:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2420:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2421,"dup":34,"validate.io-integer-primitive":2422}],2421:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2422:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2430}],2423:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2424:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2425:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2426:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2427:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2428}],2428:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2429}],2429:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2430:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2431:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2432}],2432:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2433:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2430}],2434:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2435:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2436,"dup":132,"validate.io-integer-primitive":2437}],2436:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2437:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2430}],2438:[function(require,module,exports){
arguments[4][1443][0].apply(exports,arguments)
},{"./number.js":2443,"dup":1443}],2439:[function(require,module,exports){
arguments[4][1444][0].apply(exports,arguments)
},{"./number.js":2443,"dup":1444}],2440:[function(require,module,exports){
arguments[4][1445][0].apply(exports,arguments)
},{"./number.js":2443,"dup":1445,"utils-deep-get":2494,"utils-deep-set":2500}],2441:[function(require,module,exports){
arguments[4][1446][0].apply(exports,arguments)
},{"./accessor.js":2438,"./array.js":2439,"./deepset.js":2440,"./matrix.js":2442,"./number.js":2443,"./typedarray.js":2444,"./validate.js":2445,"compute-array-constructors":2447,"dstructs-matrix":2456,"dup":1446,"validate.io-array-like":2503,"validate.io-matrix-like":2508,"validate.io-nan":2509,"validate.io-number-primitive":2513,"validate.io-typed-array-like":2518}],2442:[function(require,module,exports){
arguments[4][1447][0].apply(exports,arguments)
},{"./number.js":2443,"dup":1447}],2443:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// FUNCTIONS //

var floor = Math.floor;


// MEDIAN //

/**
* FUNCTION median( lambda )
*	Computes the distribution median for a Poisson distribution with parameter lambda.
*
* @param {Number} lambda - mean parameter
* @returns {Number} distribution median
*/
function median( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return floor( lambda + 1/3 - 0.02/lambda );
} // end FUNCTION median()


// EXPORTS

module.exports =  median;

},{"validate.io-positive-primitive":2516}],2444:[function(require,module,exports){
arguments[4][1449][0].apply(exports,arguments)
},{"./number.js":2443,"dup":1449}],2445:[function(require,module,exports){
arguments[4][1450][0].apply(exports,arguments)
},{"dup":1450,"validate.io-boolean-primitive":2506,"validate.io-function":2507,"validate.io-object":2514,"validate.io-string-primitive":2517}],2446:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2447:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2446,"dup":63}],2448:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2449:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2452,"./iget.js":2454,"./iset.js":2457,"./mget.js":2461,"./mset.js":2463,"./set.js":2471,"./sget.js":2473,"./sset.js":2475,"./toString.js":2477,"dup":2}],2450:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2453,"./iget.raw.js":2455,"./iset.raw.js":2458,"./mget.raw.js":2462,"./mset.raw.js":2464,"./set.raw.js":2472,"./sget.raw.js":2474,"./sset.raw.js":2476,"./toString.js":2477,"dup":3}],2451:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2452:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2510}],2453:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2454:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2489}],2455:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2456:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2459,"./matrix.raw.js":2460,"dup":9}],2457:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2489,"validate.io-number-primitive":2513}],2458:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2459:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2448,"./ctor.js":2449,"./dtypes.js":2451,"compute-cast-arrays":2478,"compute-dtype":2481,"dup":12,"validate.io-array":2486,"validate.io-contains":2487,"validate.io-nonnegative-integer-array":2490,"validate.io-string-primitive":2517}],2460:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2448,"./ctor.raw.js":2450,"./dtypes.js":2451,"compute-dtype":2481,"dup":13,"validate.io-contains":2487,"validate.io-string-primitive":2517}],2461:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2448,"dup":14,"validate.io-nonnegative-integer-array":2490}],2462:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2448,"dup":15}],2463:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2465,"./mset2.js":2466,"./mset3.js":2467,"./mset4.js":2468,"./mset5.js":2469,"./mset6.js":2470,"dup":16,"validate.io-function":2507,"validate.io-nonnegative-integer-array":2490,"validate.io-number-primitive":2513}],2464:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2465,"./mset2.js":2466,"./mset3.js":2467,"./mset4.js":2468,"./mset5.js":2469,"./mset6.js":2470,"dup":17}],2465:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2466:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2467:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2468:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2469:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2470:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2471:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2510,"validate.io-number-primitive":2513}],2472:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2473:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2448,"compute-indexspace":2485,"dup":26,"validate.io-string-primitive":2517}],2474:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2448,"compute-indexspace":2485,"dup":27}],2475:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2485,"dup":28,"validate.io-function":2507,"validate.io-number-primitive":2513,"validate.io-string-primitive":2517}],2476:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2485,"dup":29}],2477:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2478:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2446,"compute-array-dtype/lib/dtypes":2479,"dup":31,"type-name":2480,"validate.io-array-like":2503}],2479:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2480:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2481:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2483,"dup":36,"type-name":2484}],2482:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2483:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2482,"dup":38}],2484:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2485:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2510,"validate.io-string-primitive":2517}],2486:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2487:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2486,"validate.io-nan-primitive":2488}],2488:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2489:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2513}],2490:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2486,"validate.io-nonnegative-integer":2510}],2491:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2492:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2493:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2491,"./defaults.js":2492,"./validate.js":2495,"dup":111,"validate.io-array":2496,"validate.io-string-primitive":2517}],2494:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2491,"./defaults.js":2492,"./factory.js":2493,"./validate.js":2495,"dup":112,"validate.io-array":2496,"validate.io-string-primitive":2517}],2495:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2514,"validate.io-string-primitive":2517}],2496:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2497:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2498:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2499:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2497,"./defaults.js":2498,"./validate.js":2501,"dup":117,"validate.io-array":2502,"validate.io-string-primitive":2517}],2500:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2497,"./defaults.js":2498,"./factory.js":2499,"./validate.js":2501,"dup":118,"validate.io-array":2502,"validate.io-string-primitive":2517}],2501:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2506,"validate.io-object":2514,"validate.io-string-primitive":2517}],2502:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2503:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2504,"dup":34,"validate.io-integer-primitive":2505}],2504:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2505:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2513}],2506:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2507:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2508:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2509:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2510:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2511}],2511:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2512}],2512:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2513:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2514:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2515}],2515:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2516:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2513}],2517:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2518:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2519,"dup":132,"validate.io-integer-primitive":2520}],2519:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2520:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2513}],2521:[function(require,module,exports){
arguments[4][1859][0].apply(exports,arguments)
},{"./number.js":2526,"dup":1859}],2522:[function(require,module,exports){
arguments[4][1860][0].apply(exports,arguments)
},{"./number.js":2526,"dup":1860}],2523:[function(require,module,exports){
arguments[4][1861][0].apply(exports,arguments)
},{"./number.js":2526,"dup":1861,"utils-deep-get":2577,"utils-deep-set":2583}],2524:[function(require,module,exports){
arguments[4][1862][0].apply(exports,arguments)
},{"./accessor.js":2521,"./array.js":2522,"./deepset.js":2523,"./matrix.js":2525,"./number.js":2526,"./typedarray.js":2527,"./validate.js":2528,"compute-array-constructors":2530,"dstructs-matrix":2539,"dup":1862,"validate.io-array-like":2586,"validate.io-matrix-like":2591,"validate.io-nan":2592,"validate.io-number-primitive":2596,"validate.io-typed-array-like":2601}],2525:[function(require,module,exports){
arguments[4][1863][0].apply(exports,arguments)
},{"./number.js":2526,"dup":1863}],2526:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// VARIANCE //

/**
* FUNCTION variance( lambda )
*	Computes the distribution variance for a Poisson distribution with parameter lambda.
*
* @param {Number} lambda - mean parameter
* @returns {Number} distribution variance
*/
function variance( lambda ) {
	if ( !isPositive( lambda ) ) {
		return NaN;
	}
	return lambda;
} // end FUNCTION variance()


// EXPORTS

module.exports =  variance;

},{"validate.io-positive-primitive":2599}],2527:[function(require,module,exports){
arguments[4][1865][0].apply(exports,arguments)
},{"./number.js":2526,"dup":1865}],2528:[function(require,module,exports){
arguments[4][1866][0].apply(exports,arguments)
},{"dup":1866,"validate.io-boolean-primitive":2589,"validate.io-function":2590,"validate.io-object":2597,"validate.io-string-primitive":2600}],2529:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2530:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2529,"dup":63}],2531:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2532:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2535,"./iget.js":2537,"./iset.js":2540,"./mget.js":2544,"./mset.js":2546,"./set.js":2554,"./sget.js":2556,"./sset.js":2558,"./toString.js":2560,"dup":2}],2533:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2536,"./iget.raw.js":2538,"./iset.raw.js":2541,"./mget.raw.js":2545,"./mset.raw.js":2547,"./set.raw.js":2555,"./sget.raw.js":2557,"./sset.raw.js":2559,"./toString.js":2560,"dup":3}],2534:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2535:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2593}],2536:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2537:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2572}],2538:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2539:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2542,"./matrix.raw.js":2543,"dup":9}],2540:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2572,"validate.io-number-primitive":2596}],2541:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2542:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2531,"./ctor.js":2532,"./dtypes.js":2534,"compute-cast-arrays":2561,"compute-dtype":2564,"dup":12,"validate.io-array":2569,"validate.io-contains":2570,"validate.io-nonnegative-integer-array":2573,"validate.io-string-primitive":2600}],2543:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2531,"./ctor.raw.js":2533,"./dtypes.js":2534,"compute-dtype":2564,"dup":13,"validate.io-contains":2570,"validate.io-string-primitive":2600}],2544:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2531,"dup":14,"validate.io-nonnegative-integer-array":2573}],2545:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2531,"dup":15}],2546:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2548,"./mset2.js":2549,"./mset3.js":2550,"./mset4.js":2551,"./mset5.js":2552,"./mset6.js":2553,"dup":16,"validate.io-function":2590,"validate.io-nonnegative-integer-array":2573,"validate.io-number-primitive":2596}],2547:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2548,"./mset2.js":2549,"./mset3.js":2550,"./mset4.js":2551,"./mset5.js":2552,"./mset6.js":2553,"dup":17}],2548:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2549:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2550:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2551:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2552:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2553:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2554:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2593,"validate.io-number-primitive":2596}],2555:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2556:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2531,"compute-indexspace":2568,"dup":26,"validate.io-string-primitive":2600}],2557:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2531,"compute-indexspace":2568,"dup":27}],2558:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2568,"dup":28,"validate.io-function":2590,"validate.io-number-primitive":2596,"validate.io-string-primitive":2600}],2559:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2568,"dup":29}],2560:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2561:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2529,"compute-array-dtype/lib/dtypes":2562,"dup":31,"type-name":2563,"validate.io-array-like":2586}],2562:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2563:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2564:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2566,"dup":36,"type-name":2567}],2565:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2566:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2565,"dup":38}],2567:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2568:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2593,"validate.io-string-primitive":2600}],2569:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2570:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2569,"validate.io-nan-primitive":2571}],2571:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2572:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2596}],2573:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2569,"validate.io-nonnegative-integer":2593}],2574:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2575:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2576:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2574,"./defaults.js":2575,"./validate.js":2578,"dup":111,"validate.io-array":2579,"validate.io-string-primitive":2600}],2577:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2574,"./defaults.js":2575,"./factory.js":2576,"./validate.js":2578,"dup":112,"validate.io-array":2579,"validate.io-string-primitive":2600}],2578:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2597,"validate.io-string-primitive":2600}],2579:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2580:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2581:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2582:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2580,"./defaults.js":2581,"./validate.js":2584,"dup":117,"validate.io-array":2585,"validate.io-string-primitive":2600}],2583:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2580,"./defaults.js":2581,"./factory.js":2582,"./validate.js":2584,"dup":118,"validate.io-array":2585,"validate.io-string-primitive":2600}],2584:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2589,"validate.io-object":2597,"validate.io-string-primitive":2600}],2585:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2586:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2587,"dup":34,"validate.io-integer-primitive":2588}],2587:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2588:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2596}],2589:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2590:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2591:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2592:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2593:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2594}],2594:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2595}],2595:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2596:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2597:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2598}],2598:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2599:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2596}],2600:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2601:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2602,"dup":132,"validate.io-integer-primitive":2603}],2602:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2603:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2596}],2604:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, sigma, accessor )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":2610}],2605:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":2610}],2606:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( arr, sigma, path[, sep] )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function cdf( x, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":2610,"utils-deep-get":2661,"utils-deep-set":2667}],2607:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var cdf1 = require( './number.js' ),
	cdf2 = require( './array.js' ),
	cdf3 = require( './accessor.js' ),
	cdf4 = require( './deepset.js' ),
	cdf5 = require( './matrix.js' ),
	cdf6 = require( './typedarray.js' );


// CDF //

/**
* FUNCTION: cdf( x[, opts] )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.sigma=1] - scale parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated CDF
*/
function cdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( x ) ) {
		return cdf1( x, opts.sigma );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return cdf5( out, x, opts.sigma );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return cdf6( out, x, opts.sigma );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return cdf4( x, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'cdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return cdf3( out, x, opts.sigma, opts.accessor );
		}
		return cdf2( out, x, opts.sigma );
	}
	return NaN;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./accessor.js":2604,"./array.js":2605,"./deepset.js":2606,"./matrix.js":2608,"./number.js":2609,"./typedarray.js":2611,"./validate.js":2612,"compute-array-constructors":2614,"dstructs-matrix":2623,"validate.io-array-like":2670,"validate.io-matrix-like":2675,"validate.io-number-primitive":2679,"validate.io-typed-array-like":2684}],2608:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, matrix, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} sigma - scale parameter
* @returns {Matrix} output matrix
*/
function cdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'cdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":2610}],2609:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var expm1 = Math.expm1 || function(x) {
  return Math.exp(x) - 1;
};
var pow = Math.pow;



// CDF //

/**
* FUNCTION: cdf( x, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} sigma - scale parameter
* @returns {Number} evaluated CDF
*/
function cdf( x, sigma ) {
	if ( x < 0 ) {
		return 0;
	}
	var s2 = pow( sigma, 2 );
	return -expm1( - pow( x, 2) / ( 2 * s2 ) );
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{}],2610:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var expm1 = Math.expm1 || function(x) {
  return Math.exp(x) - 1;
};
var pow = Math.pow;


// PARTIAL //

/**
* FUNCTION: partial( sigma )
*	Partially applies scale parameter `sigma` and returns a function for evaluating the cumulative distribution function (CDF) for a Rayleigh distribution.
*
* @param {Number} sigma - scale parameter
* @returns {Function} CDF
*/
function partial( sigma ) {
	var s2 = pow( sigma, 2 );
	/**
	* FUNCTION: cdf( x )
	*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated CDF
	*/
	return function cdf( x ) {
		if ( x < 0 ) {
			return 0;
		}
		return -expm1( - pow( x, 2) / ( 2 * s2 ) ) ;
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],2611:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// CDF //

/**
* FUNCTION: cdf( out, arr, sigma )
*	Evaluates the cumulative distribution function (CDF) for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function cdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;

},{"./partial.js":2610}],2612:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.sigma=1] - scale parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'cdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isPositive( opts.sigma ) ) {
			return new TypeError( 'cdf()::invalid option. `sigma` parameter must be a positive number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'cdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'cdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'cdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'cdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'cdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":2673,"validate.io-function":2674,"validate.io-object":2680,"validate.io-positive-primitive":2682,"validate.io-string-primitive":2683}],2613:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2614:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2613,"dup":63}],2615:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2616:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2619,"./iget.js":2621,"./iset.js":2624,"./mget.js":2628,"./mset.js":2630,"./set.js":2638,"./sget.js":2640,"./sset.js":2642,"./toString.js":2644,"dup":2}],2617:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2620,"./iget.raw.js":2622,"./iset.raw.js":2625,"./mget.raw.js":2629,"./mset.raw.js":2631,"./set.raw.js":2639,"./sget.raw.js":2641,"./sset.raw.js":2643,"./toString.js":2644,"dup":3}],2618:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2619:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2676}],2620:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2621:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2656}],2622:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2623:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2626,"./matrix.raw.js":2627,"dup":9}],2624:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2656,"validate.io-number-primitive":2679}],2625:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2626:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2615,"./ctor.js":2616,"./dtypes.js":2618,"compute-cast-arrays":2645,"compute-dtype":2648,"dup":12,"validate.io-array":2653,"validate.io-contains":2654,"validate.io-nonnegative-integer-array":2657,"validate.io-string-primitive":2683}],2627:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2615,"./ctor.raw.js":2617,"./dtypes.js":2618,"compute-dtype":2648,"dup":13,"validate.io-contains":2654,"validate.io-string-primitive":2683}],2628:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2615,"dup":14,"validate.io-nonnegative-integer-array":2657}],2629:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2615,"dup":15}],2630:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2632,"./mset2.js":2633,"./mset3.js":2634,"./mset4.js":2635,"./mset5.js":2636,"./mset6.js":2637,"dup":16,"validate.io-function":2674,"validate.io-nonnegative-integer-array":2657,"validate.io-number-primitive":2679}],2631:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2632,"./mset2.js":2633,"./mset3.js":2634,"./mset4.js":2635,"./mset5.js":2636,"./mset6.js":2637,"dup":17}],2632:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2633:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2634:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2635:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2636:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2637:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2638:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2676,"validate.io-number-primitive":2679}],2639:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2640:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2615,"compute-indexspace":2652,"dup":26,"validate.io-string-primitive":2683}],2641:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2615,"compute-indexspace":2652,"dup":27}],2642:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2652,"dup":28,"validate.io-function":2674,"validate.io-number-primitive":2679,"validate.io-string-primitive":2683}],2643:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2652,"dup":29}],2644:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2645:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2613,"compute-array-dtype/lib/dtypes":2646,"dup":31,"type-name":2647,"validate.io-array-like":2670}],2646:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2647:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2648:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2650,"dup":36,"type-name":2651}],2649:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2650:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2649,"dup":38}],2651:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2652:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2676,"validate.io-string-primitive":2683}],2653:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2654:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2653,"validate.io-nan-primitive":2655}],2655:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2656:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2679}],2657:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2653,"validate.io-nonnegative-integer":2676}],2658:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2659:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2660:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2658,"./defaults.js":2659,"./validate.js":2662,"dup":111,"validate.io-array":2663,"validate.io-string-primitive":2683}],2661:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2658,"./defaults.js":2659,"./factory.js":2660,"./validate.js":2662,"dup":112,"validate.io-array":2663,"validate.io-string-primitive":2683}],2662:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2680,"validate.io-string-primitive":2683}],2663:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2664:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2665:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2666:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2664,"./defaults.js":2665,"./validate.js":2668,"dup":117,"validate.io-array":2669,"validate.io-string-primitive":2683}],2667:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2664,"./defaults.js":2665,"./factory.js":2666,"./validate.js":2668,"dup":118,"validate.io-array":2669,"validate.io-string-primitive":2683}],2668:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2673,"validate.io-object":2680,"validate.io-string-primitive":2683}],2669:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2670:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2671,"dup":34,"validate.io-integer-primitive":2672}],2671:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2672:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2679}],2673:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2674:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2675:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2676:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2677}],2677:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2678}],2678:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2679:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2680:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2681}],2681:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2682:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2679}],2683:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2684:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2685,"dup":132,"validate.io-integer-primitive":2686}],2685:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2686:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2679}],2687:[function(require,module,exports){
arguments[4][1277][0].apply(exports,arguments)
},{"./number.js":2692,"dup":1277}],2688:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, sigma )
*	Computes the distribution ekurtosis for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function ekurtosis( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = EKURTOSIS( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":2692}],2689:[function(require,module,exports){
arguments[4][1279][0].apply(exports,arguments)
},{"./number.js":2692,"dup":1279,"utils-deep-get":2743,"utils-deep-set":2749}],2690:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var ekurtosis1 = require( './number.js' ),
	ekurtosis2 = require( './array.js' ),
	ekurtosis3 = require( './accessor.js' ),
	ekurtosis4 = require( './deepset.js' ),
	ekurtosis5 = require( './matrix.js' ),
	ekurtosis6 = require( './typedarray.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( sigma[, opts] )
*	Computes the distribution ekurtosis.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution ekurtosis(s)
*/
function ekurtosis( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return ekurtosis1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return ekurtosis5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return ekurtosis6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return ekurtosis4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return ekurtosis3( out, sigma, opts.accessor );
		}
		return ekurtosis2( out, sigma );
	}
	return NaN;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./accessor.js":2687,"./array.js":2688,"./deepset.js":2689,"./matrix.js":2691,"./number.js":2692,"./typedarray.js":2693,"./validate.js":2694,"compute-array-constructors":2696,"dstructs-matrix":2705,"validate.io-array-like":2752,"validate.io-matrix-like":2757,"validate.io-nan":2758,"validate.io-number-primitive":2762,"validate.io-typed-array-like":2767}],2691:[function(require,module,exports){
arguments[4][1281][0].apply(exports,arguments)
},{"./number.js":2692,"dup":1281}],2692:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );

// FUNCTIONS //

var pow = Math.pow;


// CONSTANTS //

var PI = Math.PI,
	PI2 = pow( PI, 2 ),
	EKURTOSIS_RAYLEIGH = - ( 6 * PI2 - 24 * PI + 16 ) / pow( 4 - PI, 2 );


// EKURTOSIS //

/**
* FUNCTION ekurtosis( sigma )
*	Computes the distribution ekurtosis for a Rayleigh distribution with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution ekurtosis
*/
function ekurtosis( sigma ) {
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	return EKURTOSIS_RAYLEIGH;
} // end FUNCTION ekurtosis()


// EXPORTS

module.exports =  ekurtosis;

},{"validate.io-positive-primitive":2765}],2693:[function(require,module,exports){
'use strict';

// MODULES //

var EKURTOSIS = require( './number.js' );


// EKURTOSIS //

/**
* FUNCTION: ekurtosis( out, sigma )
*	Computes the distribution ekurtosis for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function ekurtosis( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = EKURTOSIS( sigma[ i ] );
	}
	return out;
} // end FUNCTION ekurtosis()


// EXPORTS //

module.exports = ekurtosis;

},{"./number.js":2692}],2694:[function(require,module,exports){
arguments[4][1284][0].apply(exports,arguments)
},{"dup":1284,"validate.io-boolean-primitive":2755,"validate.io-function":2756,"validate.io-object":2763,"validate.io-string-primitive":2766}],2695:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2696:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2695,"dup":63}],2697:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2698:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2701,"./iget.js":2703,"./iset.js":2706,"./mget.js":2710,"./mset.js":2712,"./set.js":2720,"./sget.js":2722,"./sset.js":2724,"./toString.js":2726,"dup":2}],2699:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2702,"./iget.raw.js":2704,"./iset.raw.js":2707,"./mget.raw.js":2711,"./mset.raw.js":2713,"./set.raw.js":2721,"./sget.raw.js":2723,"./sset.raw.js":2725,"./toString.js":2726,"dup":3}],2700:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2701:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2759}],2702:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2703:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2738}],2704:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2705:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2708,"./matrix.raw.js":2709,"dup":9}],2706:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2738,"validate.io-number-primitive":2762}],2707:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2708:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2697,"./ctor.js":2698,"./dtypes.js":2700,"compute-cast-arrays":2727,"compute-dtype":2730,"dup":12,"validate.io-array":2735,"validate.io-contains":2736,"validate.io-nonnegative-integer-array":2739,"validate.io-string-primitive":2766}],2709:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2697,"./ctor.raw.js":2699,"./dtypes.js":2700,"compute-dtype":2730,"dup":13,"validate.io-contains":2736,"validate.io-string-primitive":2766}],2710:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2697,"dup":14,"validate.io-nonnegative-integer-array":2739}],2711:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2697,"dup":15}],2712:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2714,"./mset2.js":2715,"./mset3.js":2716,"./mset4.js":2717,"./mset5.js":2718,"./mset6.js":2719,"dup":16,"validate.io-function":2756,"validate.io-nonnegative-integer-array":2739,"validate.io-number-primitive":2762}],2713:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2714,"./mset2.js":2715,"./mset3.js":2716,"./mset4.js":2717,"./mset5.js":2718,"./mset6.js":2719,"dup":17}],2714:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2715:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2716:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2717:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2718:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2719:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2720:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2759,"validate.io-number-primitive":2762}],2721:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2722:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2697,"compute-indexspace":2734,"dup":26,"validate.io-string-primitive":2766}],2723:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2697,"compute-indexspace":2734,"dup":27}],2724:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2734,"dup":28,"validate.io-function":2756,"validate.io-number-primitive":2762,"validate.io-string-primitive":2766}],2725:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2734,"dup":29}],2726:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2727:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2695,"compute-array-dtype/lib/dtypes":2728,"dup":31,"type-name":2729,"validate.io-array-like":2752}],2728:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2729:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2730:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2732,"dup":36,"type-name":2733}],2731:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2732:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2731,"dup":38}],2733:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2734:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2759,"validate.io-string-primitive":2766}],2735:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2736:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2735,"validate.io-nan-primitive":2737}],2737:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2738:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2762}],2739:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2735,"validate.io-nonnegative-integer":2759}],2740:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2741:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2742:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2740,"./defaults.js":2741,"./validate.js":2744,"dup":111,"validate.io-array":2745,"validate.io-string-primitive":2766}],2743:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2740,"./defaults.js":2741,"./factory.js":2742,"./validate.js":2744,"dup":112,"validate.io-array":2745,"validate.io-string-primitive":2766}],2744:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2763,"validate.io-string-primitive":2766}],2745:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2746:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2747:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2748:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2746,"./defaults.js":2747,"./validate.js":2750,"dup":117,"validate.io-array":2751,"validate.io-string-primitive":2766}],2749:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2746,"./defaults.js":2747,"./factory.js":2748,"./validate.js":2750,"dup":118,"validate.io-array":2751,"validate.io-string-primitive":2766}],2750:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2755,"validate.io-object":2763,"validate.io-string-primitive":2766}],2751:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2752:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2753,"dup":34,"validate.io-integer-primitive":2754}],2753:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2754:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2762}],2755:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2756:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2757:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2758:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2759:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2760}],2760:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2761}],2761:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2762:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2763:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2764}],2764:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2765:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2762}],2766:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2767:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2768,"dup":132,"validate.io-integer-primitive":2769}],2768:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2769:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2762}],2770:[function(require,module,exports){
'use strict';

// MODULES //

var ENTROPY = require( './number.js' );


// ENTROPY //

/**
* FUNCTION: entropy( out, arr, accessor )
*	Computes the distribution entropy for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function entropy( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = ENTROPY( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./number.js":2775}],2771:[function(require,module,exports){
'use strict';

// MODULES //

var ENTROPY = require( './number.js' );


// ENTROPY //

/**
* FUNCTION: entropy( out, sigma )
*	Computes the distribution entropy for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function entropy( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = ENTROPY( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./number.js":2775}],2772:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	ENTROPY  = require( './number.js' );


// ENTROPY //

/**
* FUNCTION: entropy( arr, path[, sep] )
*	Computes the distribution entropy and deep sets the input array.
*
* @param {Array} arrays - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function entropy( arr, path, sep ) {
	var len = arr.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( arr[ i ] );
			if ( typeof v === 'number' ) {
				dset( arr[i], ENTROPY ( v ) );
			} else {
				dset( arr[i], NaN );
			}
		}
	}
	return arr;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./number.js":2775,"utils-deep-get":2827,"utils-deep-set":2833}],2773:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var entropy1 = require( './number.js' ),
	entropy2 = require( './array.js' ),
	entropy3 = require( './accessor.js' ),
	entropy4 = require( './deepset.js' ),
	entropy5 = require( './matrix.js' ),
	entropy6 = require( './typedarray.js' );


// ENTROPY //

/**
* FUNCTION: entropy( sigma[, opts] )
*	Computes the distribution entropy.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution entropy(s)
*/
function entropy( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return entropy1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'entropy()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return entropy5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'entropy()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return entropy6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return entropy4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'entropy()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return entropy3( out, sigma, opts.accessor );
		}
		return entropy2( out, sigma );
	}
	return NaN;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./accessor.js":2770,"./array.js":2771,"./deepset.js":2772,"./matrix.js":2774,"./number.js":2775,"./typedarray.js":2776,"./validate.js":2777,"compute-array-constructors":2779,"dstructs-matrix":2789,"validate.io-array-like":2836,"validate.io-matrix-like":2841,"validate.io-nan":2842,"validate.io-number-primitive":2846,"validate.io-typed-array-like":2851}],2774:[function(require,module,exports){
'use strict';

// MODULES //

var ENTROPY = require( './number.js' );


// ENTROPY //

/**
* FUNCTION: entropy( out, x )
*	Computes the distribution entropy for each parameter stored in a matrix.
*
* @param {Matrix} out - output matrix
* @param {Matrix} x - input matrix
* @returns {Matrix} output matrix
*/
function entropy( out, x ) {
	var len = x.length,
		i;
	if ( out.length !== len ) {
		throw new Error( 'entropy()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	for ( i = 0; i < len; i++ ) {
		out.data[ i ] = ENTROPY( x.data[ i ] );
	}
	return out;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./number.js":2775}],2775:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' ),
	gamma = require( 'compute-const-eulergamma' );


// FUNCTIONS //

var ln = Math.log,
	sqrt = Math.sqrt;


// CONSTANTS //

var CONST_PART = 1 + gamma / 2,
	SQRT_TWO = sqrt( 2 );


// ENTROPY //

/**
* FUNCTION entropy( sigma )
*	Computes the distribution entropy for a Rayleigh distribution with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution entropy
*/
function entropy( sigma ) {
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	return CONST_PART + ln( sigma / SQRT_TWO );
} // end FUNCTION entropy()


// EXPORTS

module.exports =  entropy;

},{"compute-const-eulergamma":2780,"validate.io-positive-primitive":2849}],2776:[function(require,module,exports){
'use strict';

// MODULES //

var ENTROPY = require( './number.js' );


// ENTROPY //

/**
* FUNCTION: entropy( out, sigma )
*	Computes the distribution entropy for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function entropy( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = ENTROPY( sigma[ i ] );
	}
	return out;
} // end FUNCTION entropy()


// EXPORTS //

module.exports = entropy;

},{"./number.js":2775}],2777:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'entropy()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'entropy()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'entropy()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'entropy()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'entropy()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'entropy()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":2839,"validate.io-function":2840,"validate.io-object":2847,"validate.io-string-primitive":2850}],2778:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2779:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2778,"dup":63}],2780:[function(require,module,exports){
'use strict';

// EXPORTS //

// http://oeis.org/A001620
module.exports = 0.577215664901532860606512090082402431042;

},{}],2781:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2782:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2785,"./iget.js":2787,"./iset.js":2790,"./mget.js":2794,"./mset.js":2796,"./set.js":2804,"./sget.js":2806,"./sset.js":2808,"./toString.js":2810,"dup":2}],2783:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2786,"./iget.raw.js":2788,"./iset.raw.js":2791,"./mget.raw.js":2795,"./mset.raw.js":2797,"./set.raw.js":2805,"./sget.raw.js":2807,"./sset.raw.js":2809,"./toString.js":2810,"dup":3}],2784:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2785:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2843}],2786:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2787:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2822}],2788:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2789:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2792,"./matrix.raw.js":2793,"dup":9}],2790:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2822,"validate.io-number-primitive":2846}],2791:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2792:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2781,"./ctor.js":2782,"./dtypes.js":2784,"compute-cast-arrays":2811,"compute-dtype":2814,"dup":12,"validate.io-array":2819,"validate.io-contains":2820,"validate.io-nonnegative-integer-array":2823,"validate.io-string-primitive":2850}],2793:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2781,"./ctor.raw.js":2783,"./dtypes.js":2784,"compute-dtype":2814,"dup":13,"validate.io-contains":2820,"validate.io-string-primitive":2850}],2794:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2781,"dup":14,"validate.io-nonnegative-integer-array":2823}],2795:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2781,"dup":15}],2796:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2798,"./mset2.js":2799,"./mset3.js":2800,"./mset4.js":2801,"./mset5.js":2802,"./mset6.js":2803,"dup":16,"validate.io-function":2840,"validate.io-nonnegative-integer-array":2823,"validate.io-number-primitive":2846}],2797:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2798,"./mset2.js":2799,"./mset3.js":2800,"./mset4.js":2801,"./mset5.js":2802,"./mset6.js":2803,"dup":17}],2798:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2799:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2800:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2801:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2802:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2803:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2804:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2843,"validate.io-number-primitive":2846}],2805:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2806:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2781,"compute-indexspace":2818,"dup":26,"validate.io-string-primitive":2850}],2807:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2781,"compute-indexspace":2818,"dup":27}],2808:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2818,"dup":28,"validate.io-function":2840,"validate.io-number-primitive":2846,"validate.io-string-primitive":2850}],2809:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2818,"dup":29}],2810:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2811:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2778,"compute-array-dtype/lib/dtypes":2812,"dup":31,"type-name":2813,"validate.io-array-like":2836}],2812:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2813:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2814:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2816,"dup":36,"type-name":2817}],2815:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2816:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2815,"dup":38}],2817:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2818:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2843,"validate.io-string-primitive":2850}],2819:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2820:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2819,"validate.io-nan-primitive":2821}],2821:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2822:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2846}],2823:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2819,"validate.io-nonnegative-integer":2843}],2824:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2825:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2826:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2824,"./defaults.js":2825,"./validate.js":2828,"dup":111,"validate.io-array":2829,"validate.io-string-primitive":2850}],2827:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2824,"./defaults.js":2825,"./factory.js":2826,"./validate.js":2828,"dup":112,"validate.io-array":2829,"validate.io-string-primitive":2850}],2828:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2847,"validate.io-string-primitive":2850}],2829:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2830:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2831:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2832:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2830,"./defaults.js":2831,"./validate.js":2834,"dup":117,"validate.io-array":2835,"validate.io-string-primitive":2850}],2833:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2830,"./defaults.js":2831,"./factory.js":2832,"./validate.js":2834,"dup":118,"validate.io-array":2835,"validate.io-string-primitive":2850}],2834:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2839,"validate.io-object":2847,"validate.io-string-primitive":2850}],2835:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2836:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2837,"dup":34,"validate.io-integer-primitive":2838}],2837:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2838:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2846}],2839:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2840:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2841:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2842:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2843:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2844}],2844:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2845}],2845:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2846:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2847:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2848}],2848:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2849:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2846}],2850:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2851:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2852,"dup":132,"validate.io-integer-primitive":2853}],2852:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2853:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2846}],2854:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, sigma, accessor )
*	Computes the distribution mean for parameters stored in an array using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, arr, clbk ) {
	var len = arr.length,
		v, i;
	for ( i = 0; i < len; i++ ) {
		v = clbk( arr[ i ], i );
		if ( typeof v === 'number' ) {
			out[ i ] = MEAN( v );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":2859}],2855:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, sigma )
*	Computes the distribution mean for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = MEAN( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":2859}],2856:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	MEAN  = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( sigma, path[, sep] )
*	Computes the distribution mean and deep sets the input array.
*
* @param {Array} sigma - input array
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function mean( sigma, path, sep ) {
	var len = sigma.length,
		opts = {},
		dget,
		dset,
		v, i;
	if ( arguments.length > 2 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		for ( i = 0; i < len; i++ ) {
			v = dget( sigma[ i ] );
			if ( typeof v === 'number' ) {
				dset( sigma[i], MEAN ( v ) );
			} else {
				dset( sigma[i], NaN );
			}
		}
	}
	return sigma;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":2859,"utils-deep-get":2910,"utils-deep-set":2916}],2857:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var mean1 = require( './number.js' ),
	mean2 = require( './array.js' ),
	mean3 = require( './accessor.js' ),
	mean4 = require( './deepset.js' ),
	mean5 = require( './matrix.js' ),
	mean6 = require( './typedarray.js' );


// MEAN //

/**
* FUNCTION: mean( sigma[, opts] )
*	Computes the distribution mean.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution mean(s)
*/
function mean( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return mean1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return mean5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return mean6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return mean4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'mean()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return mean3( out, sigma, opts.accessor );
		}
		return mean2( out, sigma );
	}
	return NaN;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./accessor.js":2854,"./array.js":2855,"./deepset.js":2856,"./matrix.js":2858,"./number.js":2859,"./typedarray.js":2860,"./validate.js":2861,"compute-array-constructors":2863,"dstructs-matrix":2872,"validate.io-array-like":2919,"validate.io-matrix-like":2924,"validate.io-nan":2925,"validate.io-number-primitive":2929,"validate.io-typed-array-like":2934}],2858:[function(require,module,exports){
arguments[4][1364][0].apply(exports,arguments)
},{"./number.js":2859,"dup":1364}],2859:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// FUNCTIONS //

var sqrt = Math.sqrt;


// CONSTANTS //

var PI = Math.PI;


// MEAN //

/**
* FUNCTION mean( sigma )
*	Computes the distribution mean for a Rayleigh with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution mean
*/
function mean( sigma ) {
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	return sigma * sqrt( PI / 2 );
} // end FUNCTION mean()


// EXPORTS

module.exports =  mean;

},{"validate.io-positive-primitive":2932}],2860:[function(require,module,exports){
'use strict';

// MODULES //

var MEAN = require( './number.js' );


// MEAN //

/**
* FUNCTION: mean( out, sigma )
*	Computes the distribution mean for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function mean( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = MEAN( sigma[ i ] );
	}
	return out;
} // end FUNCTION mean()


// EXPORTS //

module.exports = mean;

},{"./number.js":2859}],2861:[function(require,module,exports){
arguments[4][1367][0].apply(exports,arguments)
},{"dup":1367,"validate.io-boolean-primitive":2922,"validate.io-function":2923,"validate.io-object":2930,"validate.io-string-primitive":2933}],2862:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2863:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2862,"dup":63}],2864:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2865:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2868,"./iget.js":2870,"./iset.js":2873,"./mget.js":2877,"./mset.js":2879,"./set.js":2887,"./sget.js":2889,"./sset.js":2891,"./toString.js":2893,"dup":2}],2866:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2869,"./iget.raw.js":2871,"./iset.raw.js":2874,"./mget.raw.js":2878,"./mset.raw.js":2880,"./set.raw.js":2888,"./sget.raw.js":2890,"./sset.raw.js":2892,"./toString.js":2893,"dup":3}],2867:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2868:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":2926}],2869:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2870:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2905}],2871:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2872:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2875,"./matrix.raw.js":2876,"dup":9}],2873:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2905,"validate.io-number-primitive":2929}],2874:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2875:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2864,"./ctor.js":2865,"./dtypes.js":2867,"compute-cast-arrays":2894,"compute-dtype":2897,"dup":12,"validate.io-array":2902,"validate.io-contains":2903,"validate.io-nonnegative-integer-array":2906,"validate.io-string-primitive":2933}],2876:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2864,"./ctor.raw.js":2866,"./dtypes.js":2867,"compute-dtype":2897,"dup":13,"validate.io-contains":2903,"validate.io-string-primitive":2933}],2877:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2864,"dup":14,"validate.io-nonnegative-integer-array":2906}],2878:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2864,"dup":15}],2879:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2881,"./mset2.js":2882,"./mset3.js":2883,"./mset4.js":2884,"./mset5.js":2885,"./mset6.js":2886,"dup":16,"validate.io-function":2923,"validate.io-nonnegative-integer-array":2906,"validate.io-number-primitive":2929}],2880:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2881,"./mset2.js":2882,"./mset3.js":2883,"./mset4.js":2884,"./mset5.js":2885,"./mset6.js":2886,"dup":17}],2881:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2882:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2883:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2884:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2885:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2886:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2887:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":2926,"validate.io-number-primitive":2929}],2888:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2889:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2864,"compute-indexspace":2901,"dup":26,"validate.io-string-primitive":2933}],2890:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2864,"compute-indexspace":2901,"dup":27}],2891:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2901,"dup":28,"validate.io-function":2923,"validate.io-number-primitive":2929,"validate.io-string-primitive":2933}],2892:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2901,"dup":29}],2893:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2894:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2862,"compute-array-dtype/lib/dtypes":2895,"dup":31,"type-name":2896,"validate.io-array-like":2919}],2895:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2896:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2897:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2899,"dup":36,"type-name":2900}],2898:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2899:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2898,"dup":38}],2900:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2901:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":2926,"validate.io-string-primitive":2933}],2902:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2903:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2902,"validate.io-nan-primitive":2904}],2904:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2905:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2929}],2906:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2902,"validate.io-nonnegative-integer":2926}],2907:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2908:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2909:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2907,"./defaults.js":2908,"./validate.js":2911,"dup":111,"validate.io-array":2912,"validate.io-string-primitive":2933}],2910:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2907,"./defaults.js":2908,"./factory.js":2909,"./validate.js":2911,"dup":112,"validate.io-array":2912,"validate.io-string-primitive":2933}],2911:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":2930,"validate.io-string-primitive":2933}],2912:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2913:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2914:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2915:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2913,"./defaults.js":2914,"./validate.js":2917,"dup":117,"validate.io-array":2918,"validate.io-string-primitive":2933}],2916:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2913,"./defaults.js":2914,"./factory.js":2915,"./validate.js":2917,"dup":118,"validate.io-array":2918,"validate.io-string-primitive":2933}],2917:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":2922,"validate.io-object":2930,"validate.io-string-primitive":2933}],2918:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2919:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2920,"dup":34,"validate.io-integer-primitive":2921}],2920:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2921:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2929}],2922:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],2923:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],2924:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],2925:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],2926:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":2927}],2927:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":2928}],2928:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],2929:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],2930:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":2931}],2931:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2932:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":2929}],2933:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],2934:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":2935,"dup":132,"validate.io-integer-primitive":2936}],2935:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],2936:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":2929}],2937:[function(require,module,exports){
arguments[4][1443][0].apply(exports,arguments)
},{"./number.js":2942,"dup":1443}],2938:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, sigma )
*	Computes the distribution median for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function median( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = MEDIAN( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":2942}],2939:[function(require,module,exports){
arguments[4][1445][0].apply(exports,arguments)
},{"./number.js":2942,"dup":1445,"utils-deep-get":2993,"utils-deep-set":2999}],2940:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var median1 = require( './number.js' ),
	median2 = require( './array.js' ),
	median3 = require( './accessor.js' ),
	median4 = require( './deepset.js' ),
	median5 = require( './matrix.js' ),
	median6 = require( './typedarray.js' );


// MEDIAN //

/**
* FUNCTION: median( sigma[, opts] )
*	Computes the distribution median.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution median(s)
*/
function median( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return median1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return median5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return median6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return median4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'median()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return median3( out, sigma, opts.accessor );
		}
		return median2( out, sigma );
	}
	return NaN;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./accessor.js":2937,"./array.js":2938,"./deepset.js":2939,"./matrix.js":2941,"./number.js":2942,"./typedarray.js":2943,"./validate.js":2944,"compute-array-constructors":2946,"dstructs-matrix":2955,"validate.io-array-like":3002,"validate.io-matrix-like":3007,"validate.io-nan":3008,"validate.io-number-primitive":3012,"validate.io-typed-array-like":3017}],2941:[function(require,module,exports){
arguments[4][1447][0].apply(exports,arguments)
},{"./number.js":2942,"dup":1447}],2942:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );


// FUNCTIONS //

var ln = Math.log,
	sqrt = Math.sqrt;


// MEDIAN //

/**
* FUNCTION median( sigma )
*	Computes the distribution median for a Rayleigh distribution with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution median
*/
function median( sigma ) {
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	return sigma * sqrt( 2 * ln( 2 ) );
} // end FUNCTION median()


// EXPORTS

module.exports =  median;

},{"validate.io-positive-primitive":3015}],2943:[function(require,module,exports){
'use strict';

// MODULES //

var MEDIAN = require( './number.js' );


// MEDIAN //

/**
* FUNCTION: median( out, sigma )
*	Computes the distribution median for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function median( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = MEDIAN( sigma[ i ] );
	}
	return out;
} // end FUNCTION median()


// EXPORTS //

module.exports = median;

},{"./number.js":2942}],2944:[function(require,module,exports){
arguments[4][1450][0].apply(exports,arguments)
},{"dup":1450,"validate.io-boolean-primitive":3005,"validate.io-function":3006,"validate.io-object":3013,"validate.io-string-primitive":3016}],2945:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],2946:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":2945,"dup":63}],2947:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],2948:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":2951,"./iget.js":2953,"./iset.js":2956,"./mget.js":2960,"./mset.js":2962,"./set.js":2970,"./sget.js":2972,"./sset.js":2974,"./toString.js":2976,"dup":2}],2949:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":2952,"./iget.raw.js":2954,"./iset.raw.js":2957,"./mget.raw.js":2961,"./mset.raw.js":2963,"./set.raw.js":2971,"./sget.raw.js":2973,"./sset.raw.js":2975,"./toString.js":2976,"dup":3}],2950:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],2951:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3009}],2952:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],2953:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":2988}],2954:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],2955:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":2958,"./matrix.raw.js":2959,"dup":9}],2956:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":2988,"validate.io-number-primitive":3012}],2957:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],2958:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":2947,"./ctor.js":2948,"./dtypes.js":2950,"compute-cast-arrays":2977,"compute-dtype":2980,"dup":12,"validate.io-array":2985,"validate.io-contains":2986,"validate.io-nonnegative-integer-array":2989,"validate.io-string-primitive":3016}],2959:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":2947,"./ctor.raw.js":2949,"./dtypes.js":2950,"compute-dtype":2980,"dup":13,"validate.io-contains":2986,"validate.io-string-primitive":3016}],2960:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":2947,"dup":14,"validate.io-nonnegative-integer-array":2989}],2961:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":2947,"dup":15}],2962:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":2964,"./mset2.js":2965,"./mset3.js":2966,"./mset4.js":2967,"./mset5.js":2968,"./mset6.js":2969,"dup":16,"validate.io-function":3006,"validate.io-nonnegative-integer-array":2989,"validate.io-number-primitive":3012}],2963:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":2964,"./mset2.js":2965,"./mset3.js":2966,"./mset4.js":2967,"./mset5.js":2968,"./mset6.js":2969,"dup":17}],2964:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],2965:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],2966:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],2967:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],2968:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],2969:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],2970:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3009,"validate.io-number-primitive":3012}],2971:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],2972:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":2947,"compute-indexspace":2984,"dup":26,"validate.io-string-primitive":3016}],2973:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":2947,"compute-indexspace":2984,"dup":27}],2974:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":2984,"dup":28,"validate.io-function":3006,"validate.io-number-primitive":3012,"validate.io-string-primitive":3016}],2975:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":2984,"dup":29}],2976:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],2977:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":2945,"compute-array-dtype/lib/dtypes":2978,"dup":31,"type-name":2979,"validate.io-array-like":3002}],2978:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2979:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2980:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":2982,"dup":36,"type-name":2983}],2981:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],2982:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":2981,"dup":38}],2983:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],2984:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3009,"validate.io-string-primitive":3016}],2985:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2986:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":2985,"validate.io-nan-primitive":2987}],2987:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],2988:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3012}],2989:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":2985,"validate.io-nonnegative-integer":3009}],2990:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],2991:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],2992:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":2990,"./defaults.js":2991,"./validate.js":2994,"dup":111,"validate.io-array":2995,"validate.io-string-primitive":3016}],2993:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":2990,"./defaults.js":2991,"./factory.js":2992,"./validate.js":2994,"dup":112,"validate.io-array":2995,"validate.io-string-primitive":3016}],2994:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3013,"validate.io-string-primitive":3016}],2995:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],2996:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],2997:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],2998:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":2996,"./defaults.js":2997,"./validate.js":3000,"dup":117,"validate.io-array":3001,"validate.io-string-primitive":3016}],2999:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":2996,"./defaults.js":2997,"./factory.js":2998,"./validate.js":3000,"dup":118,"validate.io-array":3001,"validate.io-string-primitive":3016}],3000:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3005,"validate.io-object":3013,"validate.io-string-primitive":3016}],3001:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3002:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3003,"dup":34,"validate.io-integer-primitive":3004}],3003:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3004:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3012}],3005:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3006:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3007:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3008:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],3009:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3010}],3010:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3011}],3011:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3012:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3013:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3014}],3014:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3015:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3012}],3016:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3017:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3018,"dup":132,"validate.io-integer-primitive":3019}],3018:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3019:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3012}],3020:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, sigma, accessor )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3026}],3021:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, sigma )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3026}],3022:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( arr, sigma, path[, sep] )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function pdf( x, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3026,"utils-deep-get":3077,"utils-deep-set":3083}],3023:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var pdf1 = require( './number.js' ),
	pdf2 = require( './array.js' ),
	pdf3 = require( './accessor.js' ),
	pdf4 = require( './deepset.js' ),
	pdf5 = require( './matrix.js' ),
	pdf6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: pdf( x[, opts] )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.sigma=1] - scale parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated PDF
*/
function pdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( x ) ) {
		return pdf1( x, opts.sigma );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return pdf5( out, x, opts.sigma );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return pdf6( out, x, opts.sigma );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return pdf4( x, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return pdf3( out, x, opts.sigma, opts.accessor );
		}
		return pdf2( out, x, opts.sigma );
	}
	return NaN;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./accessor.js":3020,"./array.js":3021,"./deepset.js":3022,"./matrix.js":3024,"./number.js":3025,"./typedarray.js":3027,"./validate.js":3028,"compute-array-constructors":3030,"dstructs-matrix":3039,"validate.io-array-like":3086,"validate.io-matrix-like":3091,"validate.io-number-primitive":3095,"validate.io-typed-array-like":3100}],3024:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, matrix, sigma )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} sigma - scale parameter
* @returns {Matrix} output matrix
*/
function pdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'pdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3026}],3025:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp,
	pow = Math.pow;


// PDF //

/**
* FUNCTION: pdf( x, sigma )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} sigma - scale parameter
* @returns {Number} evaluated PDF
*/
function pdf( x, sigma ) {
	var s2 = pow( sigma, 2 );
	if ( x < 0 ) {
		return 0;
	}
	return (1/s2) * x * exp( -pow( x, 2 ) / ( 2 * s2 ) );
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{}],3026:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var exp = Math.exp,
	pow = Math.pow;


// PARTIAL //

/**
* FUNCTION: partial( sigma )
*	Partially applies scale parameter `sigma` and returns a function for evaluating the probability density function (PDF) for a Rayleigh distribution.
*
* @param {Number} sigma - scale parameter
* @returns {Function} PDF
*/
function partial( sigma ) {
	var s2 = pow( sigma, 2 );
	/**
	* FUNCTION: pdf( x )
	*	Evaluates the probability density function (PDF) for a Rayleigh distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated PDF
	*/
	return function pdf( x ) {
		if ( x < 0 ) {
			return 0;
		}
		return (1/s2) * x * exp( -pow( x, 2 ) / ( 2 * s2 ) );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],3027:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, sigma )
*	Evaluates the probability density function (PDF) for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3026}],3028:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.sigma=1] - scale parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'pdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isPositive( opts.sigma ) ) {
			return new TypeError( 'pdf()::invalid option. `sigma` parameter must be a positive number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'pdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'pdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'pdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'pdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'pdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":3089,"validate.io-function":3090,"validate.io-object":3096,"validate.io-positive-primitive":3098,"validate.io-string-primitive":3099}],3029:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],3030:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":3029,"dup":63}],3031:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],3032:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":3035,"./iget.js":3037,"./iset.js":3040,"./mget.js":3044,"./mset.js":3046,"./set.js":3054,"./sget.js":3056,"./sset.js":3058,"./toString.js":3060,"dup":2}],3033:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":3036,"./iget.raw.js":3038,"./iset.raw.js":3041,"./mget.raw.js":3045,"./mset.raw.js":3047,"./set.raw.js":3055,"./sget.raw.js":3057,"./sset.raw.js":3059,"./toString.js":3060,"dup":3}],3034:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],3035:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3092}],3036:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],3037:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":3072}],3038:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],3039:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":3042,"./matrix.raw.js":3043,"dup":9}],3040:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":3072,"validate.io-number-primitive":3095}],3041:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],3042:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":3031,"./ctor.js":3032,"./dtypes.js":3034,"compute-cast-arrays":3061,"compute-dtype":3064,"dup":12,"validate.io-array":3069,"validate.io-contains":3070,"validate.io-nonnegative-integer-array":3073,"validate.io-string-primitive":3099}],3043:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":3031,"./ctor.raw.js":3033,"./dtypes.js":3034,"compute-dtype":3064,"dup":13,"validate.io-contains":3070,"validate.io-string-primitive":3099}],3044:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":3031,"dup":14,"validate.io-nonnegative-integer-array":3073}],3045:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":3031,"dup":15}],3046:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":3048,"./mset2.js":3049,"./mset3.js":3050,"./mset4.js":3051,"./mset5.js":3052,"./mset6.js":3053,"dup":16,"validate.io-function":3090,"validate.io-nonnegative-integer-array":3073,"validate.io-number-primitive":3095}],3047:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":3048,"./mset2.js":3049,"./mset3.js":3050,"./mset4.js":3051,"./mset5.js":3052,"./mset6.js":3053,"dup":17}],3048:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],3049:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],3050:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],3051:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],3052:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],3053:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],3054:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3092,"validate.io-number-primitive":3095}],3055:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],3056:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":3031,"compute-indexspace":3068,"dup":26,"validate.io-string-primitive":3099}],3057:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":3031,"compute-indexspace":3068,"dup":27}],3058:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":3068,"dup":28,"validate.io-function":3090,"validate.io-number-primitive":3095,"validate.io-string-primitive":3099}],3059:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":3068,"dup":29}],3060:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],3061:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":3029,"compute-array-dtype/lib/dtypes":3062,"dup":31,"type-name":3063,"validate.io-array-like":3086}],3062:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3063:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3064:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":3066,"dup":36,"type-name":3067}],3065:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3066:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":3065,"dup":38}],3067:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3068:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3092,"validate.io-string-primitive":3099}],3069:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3070:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":3069,"validate.io-nan-primitive":3071}],3071:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],3072:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3095}],3073:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":3069,"validate.io-nonnegative-integer":3092}],3074:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],3075:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],3076:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":3074,"./defaults.js":3075,"./validate.js":3078,"dup":111,"validate.io-array":3079,"validate.io-string-primitive":3099}],3077:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":3074,"./defaults.js":3075,"./factory.js":3076,"./validate.js":3078,"dup":112,"validate.io-array":3079,"validate.io-string-primitive":3099}],3078:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3096,"validate.io-string-primitive":3099}],3079:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3080:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],3081:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],3082:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":3080,"./defaults.js":3081,"./validate.js":3084,"dup":117,"validate.io-array":3085,"validate.io-string-primitive":3099}],3083:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":3080,"./defaults.js":3081,"./factory.js":3082,"./validate.js":3084,"dup":118,"validate.io-array":3085,"validate.io-string-primitive":3099}],3084:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3089,"validate.io-object":3096,"validate.io-string-primitive":3099}],3085:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3086:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3087,"dup":34,"validate.io-integer-primitive":3088}],3087:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3088:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3095}],3089:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3090:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3091:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3092:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3093}],3093:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3094}],3094:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3095:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3096:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3097}],3097:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3098:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3095}],3099:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3100:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3101,"dup":132,"validate.io-integer-primitive":3102}],3101:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3102:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3095}],3103:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, sigma, accessor )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, sigma, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":3109}],3104:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, sigma )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":3109}],3105:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( arr, sigma, path[, sep] )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} sigma - scale parameter
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function quantile( x, sigma, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( sigma );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":3109,"utils-deep-get":3160,"utils-deep-set":3166}],3106:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var quantile1 = require( './number.js' ),
	quantile2 = require( './array.js' ),
	quantile3 = require( './accessor.js' ),
	quantile4 = require( './deepset.js' ),
	quantile5 = require( './matrix.js' ),
	quantile6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: quantile( p[, opts] )
*	Evaluates the quantile function for a Rayleigh distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} p - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.sigma=1] - scale parameter
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} quantile function value(s)
*/
function quantile( p, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.sigma = typeof opts.sigma !== 'undefined' ? opts.sigma : 1;

	if ( isNumber( p ) ) {
		return quantile1( p, opts.sigma );
	}
	if ( isMatrixLike( p ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( p.length );
			out = matrix( d, p.shape, dt );
		} else {
			out = p;
		}
		return quantile5( out, p, opts.sigma );
	}
	if ( isTypedArrayLike( p ) ) {
		if ( opts.copy === false ) {
			out = p;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( p.length );
		}
		return quantile6( out, p, opts.sigma );
	}
	if ( isArrayLike( p ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return quantile4( p, opts.sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = p;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'quantile()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( p.length );
		}
		else {
			out = new Array( p.length );
		}
		if ( opts.accessor ) {
			return quantile3( out, p, opts.sigma, opts.accessor );
		}
		return quantile2( out, p, opts.sigma );
	}
	return NaN;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./accessor.js":3103,"./array.js":3104,"./deepset.js":3105,"./matrix.js":3107,"./number.js":3108,"./typedarray.js":3110,"./validate.js":3111,"compute-array-constructors":3113,"dstructs-matrix":3122,"validate.io-array-like":3169,"validate.io-matrix-like":3174,"validate.io-number-primitive":3178,"validate.io-typed-array-like":3183}],3107:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, matrix, sigma )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} sigma - scale parameter
* @returns {Matrix} output matrix
*/
function quantile( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'quantile()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( sigma );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":3109}],3108:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ln = Math.log,
	pow = Math.pow,
	sqrt = Math.sqrt;
	

// QUANTILE //

/**
* FUNCTION: quantile( p, sigma )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` at a probability `p`.
*
* @param {Number} p - input value
* @param {Number} sigma - scale parameter
* @returns {Number} evaluated quantile function
*/
function quantile( p, sigma ) {
	if ( p !== p || p < 0 || p > 1 ) {
		return NaN;
	}
	return sigma * sqrt( -ln( pow( 1 - p, 2 ) ) );
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{}],3109:[function(require,module,exports){
'use strict';

// FUNCTIONS //

var ln = Math.log,
	pow = Math.pow,
	sqrt = Math.sqrt;


// PARTIAL //

/**
* FUNCTION: partial( sigma )
*	Partially applies scale parameter `sigma` and returns a function for evaluating the quantile function for a Rayleigh distribution.
*
* @param {Number} sigma - scale parameter
* @returns {Function} quantile function
*/
function partial( sigma ) {

	/**
	* FUNCTION: quantile( p )
	*	Evaluates the quantile function for a Rayleigh distribution.
	*
	* @private
	* @param {Number} p - input value
	* @returns {Number} evaluated quantile function
	*/
	return function quantile( p ) {
		if ( p !== p || p < 0 || p > 1 ) {
			return NaN;
		}
		return sigma * sqrt( -ln( pow( 1 - p, 2 ) ) );
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{}],3110:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// QUANTILE //

/**
* FUNCTION: quantile( out, arr, sigma )
*	Evaluates the quantile function for a Rayleigh distribution with scale parameter `sigma` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} sigma - scale parameter
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function quantile( y, x, sigma ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( sigma );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION quantile()


// EXPORTS //

module.exports = quantile;

},{"./partial.js":3109}],3111:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.sigma=1] - scale parameter
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'quantile()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'sigma' ) ) {
		opts.sigma = options.sigma;
		if ( !isPositive( opts.sigma ) ) {
			return new TypeError( 'quantile()::invalid option. `sigma` parameter must be a positive number. Option: `' + opts.sigma + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'quantile()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'quantile()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'quantile()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'quantile()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'quantile()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":3172,"validate.io-function":3173,"validate.io-object":3179,"validate.io-positive-primitive":3181,"validate.io-string-primitive":3182}],3112:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],3113:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":3112,"dup":63}],3114:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],3115:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":3118,"./iget.js":3120,"./iset.js":3123,"./mget.js":3127,"./mset.js":3129,"./set.js":3137,"./sget.js":3139,"./sset.js":3141,"./toString.js":3143,"dup":2}],3116:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":3119,"./iget.raw.js":3121,"./iset.raw.js":3124,"./mget.raw.js":3128,"./mset.raw.js":3130,"./set.raw.js":3138,"./sget.raw.js":3140,"./sset.raw.js":3142,"./toString.js":3143,"dup":3}],3117:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],3118:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3175}],3119:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],3120:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":3155}],3121:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],3122:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":3125,"./matrix.raw.js":3126,"dup":9}],3123:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":3155,"validate.io-number-primitive":3178}],3124:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],3125:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":3114,"./ctor.js":3115,"./dtypes.js":3117,"compute-cast-arrays":3144,"compute-dtype":3147,"dup":12,"validate.io-array":3152,"validate.io-contains":3153,"validate.io-nonnegative-integer-array":3156,"validate.io-string-primitive":3182}],3126:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":3114,"./ctor.raw.js":3116,"./dtypes.js":3117,"compute-dtype":3147,"dup":13,"validate.io-contains":3153,"validate.io-string-primitive":3182}],3127:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":3114,"dup":14,"validate.io-nonnegative-integer-array":3156}],3128:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":3114,"dup":15}],3129:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":3131,"./mset2.js":3132,"./mset3.js":3133,"./mset4.js":3134,"./mset5.js":3135,"./mset6.js":3136,"dup":16,"validate.io-function":3173,"validate.io-nonnegative-integer-array":3156,"validate.io-number-primitive":3178}],3130:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":3131,"./mset2.js":3132,"./mset3.js":3133,"./mset4.js":3134,"./mset5.js":3135,"./mset6.js":3136,"dup":17}],3131:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],3132:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],3133:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],3134:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],3135:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],3136:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],3137:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3175,"validate.io-number-primitive":3178}],3138:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],3139:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":3114,"compute-indexspace":3151,"dup":26,"validate.io-string-primitive":3182}],3140:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":3114,"compute-indexspace":3151,"dup":27}],3141:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":3151,"dup":28,"validate.io-function":3173,"validate.io-number-primitive":3178,"validate.io-string-primitive":3182}],3142:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":3151,"dup":29}],3143:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],3144:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":3112,"compute-array-dtype/lib/dtypes":3145,"dup":31,"type-name":3146,"validate.io-array-like":3169}],3145:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3146:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3147:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":3149,"dup":36,"type-name":3150}],3148:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3149:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":3148,"dup":38}],3150:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3151:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3175,"validate.io-string-primitive":3182}],3152:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3153:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":3152,"validate.io-nan-primitive":3154}],3154:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],3155:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3178}],3156:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":3152,"validate.io-nonnegative-integer":3175}],3157:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],3158:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],3159:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":3157,"./defaults.js":3158,"./validate.js":3161,"dup":111,"validate.io-array":3162,"validate.io-string-primitive":3182}],3160:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":3157,"./defaults.js":3158,"./factory.js":3159,"./validate.js":3161,"dup":112,"validate.io-array":3162,"validate.io-string-primitive":3182}],3161:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3179,"validate.io-string-primitive":3182}],3162:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3163:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],3164:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],3165:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":3163,"./defaults.js":3164,"./validate.js":3167,"dup":117,"validate.io-array":3168,"validate.io-string-primitive":3182}],3166:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":3163,"./defaults.js":3164,"./factory.js":3165,"./validate.js":3167,"dup":118,"validate.io-array":3168,"validate.io-string-primitive":3182}],3167:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3172,"validate.io-object":3179,"validate.io-string-primitive":3182}],3168:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3169:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3170,"dup":34,"validate.io-integer-primitive":3171}],3170:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3171:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3178}],3172:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3173:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3174:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3175:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3176}],3176:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3177}],3177:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3178:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3179:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3180}],3180:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3181:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3178}],3182:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3183:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3184,"dup":132,"validate.io-integer-primitive":3185}],3184:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3185:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3178}],3186:[function(require,module,exports){
arguments[4][1776][0].apply(exports,arguments)
},{"./number.js":3191,"dup":1776}],3187:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, sigma )
*	Computes the distribution skewness for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function skewness( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = SKEWNESS( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":3191}],3188:[function(require,module,exports){
arguments[4][1778][0].apply(exports,arguments)
},{"./number.js":3191,"dup":1778,"utils-deep-get":3242,"utils-deep-set":3248}],3189:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var skewness1 = require( './number.js' ),
	skewness2 = require( './array.js' ),
	skewness3 = require( './accessor.js' ),
	skewness4 = require( './deepset.js' ),
	skewness5 = require( './matrix.js' ),
	skewness6 = require( './typedarray.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( sigma[, opts] )
*	Computes the distribution skewness.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution skewness(s)
*/
function skewness( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return skewness1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return skewness5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return skewness6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return skewness4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'skewness()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return skewness3( out, sigma, opts.accessor );
		}
		return skewness2( out, sigma );
	}
	return NaN;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./accessor.js":3186,"./array.js":3187,"./deepset.js":3188,"./matrix.js":3190,"./number.js":3191,"./typedarray.js":3192,"./validate.js":3193,"compute-array-constructors":3195,"dstructs-matrix":3204,"validate.io-array-like":3251,"validate.io-matrix-like":3256,"validate.io-nan":3257,"validate.io-number-primitive":3261,"validate.io-typed-array-like":3266}],3190:[function(require,module,exports){
arguments[4][1780][0].apply(exports,arguments)
},{"./number.js":3191,"dup":1780}],3191:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );

// FUNCTIONS //

var pow = Math.pow,
	sqrt = Math.sqrt;


// CONSTANTS //

var PI = Math.PI,
	SKEWNESS = 2 * sqrt(PI) * ( PI - 3 ) / pow( 4 - PI, 3/2 );


// SKEWNESS //

/**
* FUNCTION skewness( sigma )
*	Computes the distribution skewness for a Rayleigh distribution with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution skewness
*/
function skewness( sigma ) {
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	return SKEWNESS;
} // end FUNCTION skewness()


// EXPORTS

module.exports =  skewness;

},{"validate.io-positive-primitive":3264}],3192:[function(require,module,exports){
'use strict';

// MODULES //

var SKEWNESS = require( './number.js' );


// SKEWNESS //

/**
* FUNCTION: skewness( out, sigma )
*	Computes the distribution skewness for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function skewness( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = SKEWNESS( sigma[ i ] );
	}
	return out;
} // end FUNCTION skewness()


// EXPORTS //

module.exports = skewness;

},{"./number.js":3191}],3193:[function(require,module,exports){
arguments[4][1783][0].apply(exports,arguments)
},{"dup":1783,"validate.io-boolean-primitive":3254,"validate.io-function":3255,"validate.io-object":3262,"validate.io-string-primitive":3265}],3194:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],3195:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":3194,"dup":63}],3196:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],3197:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":3200,"./iget.js":3202,"./iset.js":3205,"./mget.js":3209,"./mset.js":3211,"./set.js":3219,"./sget.js":3221,"./sset.js":3223,"./toString.js":3225,"dup":2}],3198:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":3201,"./iget.raw.js":3203,"./iset.raw.js":3206,"./mget.raw.js":3210,"./mset.raw.js":3212,"./set.raw.js":3220,"./sget.raw.js":3222,"./sset.raw.js":3224,"./toString.js":3225,"dup":3}],3199:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],3200:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3258}],3201:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],3202:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":3237}],3203:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],3204:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":3207,"./matrix.raw.js":3208,"dup":9}],3205:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":3237,"validate.io-number-primitive":3261}],3206:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],3207:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":3196,"./ctor.js":3197,"./dtypes.js":3199,"compute-cast-arrays":3226,"compute-dtype":3229,"dup":12,"validate.io-array":3234,"validate.io-contains":3235,"validate.io-nonnegative-integer-array":3238,"validate.io-string-primitive":3265}],3208:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":3196,"./ctor.raw.js":3198,"./dtypes.js":3199,"compute-dtype":3229,"dup":13,"validate.io-contains":3235,"validate.io-string-primitive":3265}],3209:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":3196,"dup":14,"validate.io-nonnegative-integer-array":3238}],3210:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":3196,"dup":15}],3211:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":3213,"./mset2.js":3214,"./mset3.js":3215,"./mset4.js":3216,"./mset5.js":3217,"./mset6.js":3218,"dup":16,"validate.io-function":3255,"validate.io-nonnegative-integer-array":3238,"validate.io-number-primitive":3261}],3212:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":3213,"./mset2.js":3214,"./mset3.js":3215,"./mset4.js":3216,"./mset5.js":3217,"./mset6.js":3218,"dup":17}],3213:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],3214:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],3215:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],3216:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],3217:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],3218:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],3219:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3258,"validate.io-number-primitive":3261}],3220:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],3221:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":3196,"compute-indexspace":3233,"dup":26,"validate.io-string-primitive":3265}],3222:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":3196,"compute-indexspace":3233,"dup":27}],3223:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":3233,"dup":28,"validate.io-function":3255,"validate.io-number-primitive":3261,"validate.io-string-primitive":3265}],3224:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":3233,"dup":29}],3225:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],3226:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":3194,"compute-array-dtype/lib/dtypes":3227,"dup":31,"type-name":3228,"validate.io-array-like":3251}],3227:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3228:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3229:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":3231,"dup":36,"type-name":3232}],3230:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3231:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":3230,"dup":38}],3232:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3233:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3258,"validate.io-string-primitive":3265}],3234:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3235:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":3234,"validate.io-nan-primitive":3236}],3236:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],3237:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3261}],3238:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":3234,"validate.io-nonnegative-integer":3258}],3239:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],3240:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],3241:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":3239,"./defaults.js":3240,"./validate.js":3243,"dup":111,"validate.io-array":3244,"validate.io-string-primitive":3265}],3242:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":3239,"./defaults.js":3240,"./factory.js":3241,"./validate.js":3243,"dup":112,"validate.io-array":3244,"validate.io-string-primitive":3265}],3243:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3262,"validate.io-string-primitive":3265}],3244:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3245:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],3246:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],3247:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":3245,"./defaults.js":3246,"./validate.js":3249,"dup":117,"validate.io-array":3250,"validate.io-string-primitive":3265}],3248:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":3245,"./defaults.js":3246,"./factory.js":3247,"./validate.js":3249,"dup":118,"validate.io-array":3250,"validate.io-string-primitive":3265}],3249:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3254,"validate.io-object":3262,"validate.io-string-primitive":3265}],3250:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3251:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3252,"dup":34,"validate.io-integer-primitive":3253}],3252:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3253:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3261}],3254:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3255:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3256:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3257:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],3258:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3259}],3259:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3260}],3260:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3261:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3262:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3263}],3263:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3264:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3261}],3265:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3266:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3267,"dup":132,"validate.io-integer-primitive":3268}],3267:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3268:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3261}],3269:[function(require,module,exports){
arguments[4][1859][0].apply(exports,arguments)
},{"./number.js":3274,"dup":1859}],3270:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, sigma )
*	Computes the distribution variance for parameters stored in an array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function variance( out, arr ) {
	var len = arr.length,
		i;
	for ( i = 0; i < len; i++ ) {
		if ( typeof arr[ i ] === 'number' ) {
			out[ i ] = VARIANCE( arr[ i ] );
		} else {
			out[ i ] = NaN;
		}
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":3274}],3271:[function(require,module,exports){
arguments[4][1861][0].apply(exports,arguments)
},{"./number.js":3274,"dup":1861,"utils-deep-get":3325,"utils-deep-set":3331}],3272:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isnan = require( 'validate.io-nan' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var variance1 = require( './number.js' ),
	variance2 = require( './array.js' ),
	variance3 = require( './accessor.js' ),
	variance4 = require( './deepset.js' ),
	variance5 = require( './matrix.js' ),
	variance6 = require( './typedarray.js' );


// VARIANCE //

/**
* FUNCTION: variance( sigma[, opts] )
*	Computes the distribution variance.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} sigma - input value
* @param {Object} [opts] - function options
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} distribution variance(s)
*/
function variance( sigma, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( isNumber( sigma ) || isnan( sigma ) ) {
		return variance1( sigma );
	}
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( isMatrixLike( sigma ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( sigma.length );
			out = matrix( d, sigma.shape, dt );
		} else {
			out = sigma;
		}
		return variance5( out, sigma );
	}
	if ( isTypedArrayLike( sigma ) ) {
		if ( opts.copy === false ) {
			out = sigma;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( sigma.length );
		}
		return variance6( out, sigma );
	}
	if ( isArrayLike( sigma ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return variance4( sigma, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = sigma;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'variance()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( sigma.length );
		}
		else {
			out = new Array( sigma.length );
		}
		if ( opts.accessor ) {
			return variance3( out, sigma, opts.accessor );
		}
		return variance2( out, sigma );
	}
	return NaN;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./accessor.js":3269,"./array.js":3270,"./deepset.js":3271,"./matrix.js":3273,"./number.js":3274,"./typedarray.js":3275,"./validate.js":3276,"compute-array-constructors":3278,"dstructs-matrix":3287,"validate.io-array-like":3334,"validate.io-matrix-like":3339,"validate.io-nan":3340,"validate.io-number-primitive":3344,"validate.io-typed-array-like":3349}],3273:[function(require,module,exports){
arguments[4][1863][0].apply(exports,arguments)
},{"./number.js":3274,"dup":1863}],3274:[function(require,module,exports){
'use strict';

// MODULES //

var isPositive = require( 'validate.io-positive-primitive' );

// FUNCTIONS //

var pow = Math.pow;


// CONSTANTS //

var PI = Math.PI;


// VARIANCE //

/**
* FUNCTION variance( sigma )
*	Computes the distribution variance for a Rayleigh distribution with parameter sigma.
*
* @param {Number} sigma - scale parameter
* @returns {Number} distribution variance
*/
function variance( sigma ) {
	var s2;
	if ( !isPositive( sigma ) ) {
		return NaN;
	}
	s2 = pow( sigma, 2 );
	return ( ( 4 - PI ) / 2 ) * s2;
} // end FUNCTION variance()


// EXPORTS

module.exports =  variance;

},{"validate.io-positive-primitive":3347}],3275:[function(require,module,exports){
'use strict';

// MODULES //

var VARIANCE = require( './number.js' );


// VARIANCE //

/**
* FUNCTION: variance( out, sigma )
*	Computes the distribution variance for parameters stored in a typed array.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} sigma - input array
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function variance( out, sigma ) {
	var len = sigma.length,
		i;
	for ( i = 0; i < len; i++ ) {
		out[ i ] = VARIANCE( sigma[ i ] );
	}
	return out;
} // end FUNCTION variance()


// EXPORTS //

module.exports = variance;

},{"./number.js":3274}],3276:[function(require,module,exports){
arguments[4][1866][0].apply(exports,arguments)
},{"dup":1866,"validate.io-boolean-primitive":3337,"validate.io-function":3338,"validate.io-object":3345,"validate.io-string-primitive":3348}],3277:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],3278:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":3277,"dup":63}],3279:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],3280:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":3283,"./iget.js":3285,"./iset.js":3288,"./mget.js":3292,"./mset.js":3294,"./set.js":3302,"./sget.js":3304,"./sset.js":3306,"./toString.js":3308,"dup":2}],3281:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":3284,"./iget.raw.js":3286,"./iset.raw.js":3289,"./mget.raw.js":3293,"./mset.raw.js":3295,"./set.raw.js":3303,"./sget.raw.js":3305,"./sset.raw.js":3307,"./toString.js":3308,"dup":3}],3282:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],3283:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3341}],3284:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],3285:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":3320}],3286:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],3287:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":3290,"./matrix.raw.js":3291,"dup":9}],3288:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":3320,"validate.io-number-primitive":3344}],3289:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],3290:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":3279,"./ctor.js":3280,"./dtypes.js":3282,"compute-cast-arrays":3309,"compute-dtype":3312,"dup":12,"validate.io-array":3317,"validate.io-contains":3318,"validate.io-nonnegative-integer-array":3321,"validate.io-string-primitive":3348}],3291:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":3279,"./ctor.raw.js":3281,"./dtypes.js":3282,"compute-dtype":3312,"dup":13,"validate.io-contains":3318,"validate.io-string-primitive":3348}],3292:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":3279,"dup":14,"validate.io-nonnegative-integer-array":3321}],3293:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":3279,"dup":15}],3294:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":3296,"./mset2.js":3297,"./mset3.js":3298,"./mset4.js":3299,"./mset5.js":3300,"./mset6.js":3301,"dup":16,"validate.io-function":3338,"validate.io-nonnegative-integer-array":3321,"validate.io-number-primitive":3344}],3295:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":3296,"./mset2.js":3297,"./mset3.js":3298,"./mset4.js":3299,"./mset5.js":3300,"./mset6.js":3301,"dup":17}],3296:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],3297:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],3298:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],3299:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],3300:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],3301:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],3302:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3341,"validate.io-number-primitive":3344}],3303:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],3304:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":3279,"compute-indexspace":3316,"dup":26,"validate.io-string-primitive":3348}],3305:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":3279,"compute-indexspace":3316,"dup":27}],3306:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":3316,"dup":28,"validate.io-function":3338,"validate.io-number-primitive":3344,"validate.io-string-primitive":3348}],3307:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":3316,"dup":29}],3308:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],3309:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":3277,"compute-array-dtype/lib/dtypes":3310,"dup":31,"type-name":3311,"validate.io-array-like":3334}],3310:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3311:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3312:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":3314,"dup":36,"type-name":3315}],3313:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3314:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":3313,"dup":38}],3315:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3316:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3341,"validate.io-string-primitive":3348}],3317:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3318:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":3317,"validate.io-nan-primitive":3319}],3319:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],3320:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3344}],3321:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":3317,"validate.io-nonnegative-integer":3341}],3322:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],3323:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],3324:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":3322,"./defaults.js":3323,"./validate.js":3326,"dup":111,"validate.io-array":3327,"validate.io-string-primitive":3348}],3325:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":3322,"./defaults.js":3323,"./factory.js":3324,"./validate.js":3326,"dup":112,"validate.io-array":3327,"validate.io-string-primitive":3348}],3326:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3345,"validate.io-string-primitive":3348}],3327:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3328:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],3329:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],3330:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":3328,"./defaults.js":3329,"./validate.js":3332,"dup":117,"validate.io-array":3333,"validate.io-string-primitive":3348}],3331:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":3328,"./defaults.js":3329,"./factory.js":3330,"./validate.js":3332,"dup":118,"validate.io-array":3333,"validate.io-string-primitive":3348}],3332:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3337,"validate.io-object":3345,"validate.io-string-primitive":3348}],3333:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3334:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3335,"dup":34,"validate.io-integer-primitive":3336}],3335:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3336:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3344}],3337:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3338:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3339:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3340:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],3341:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3342}],3342:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3343}],3343:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3344:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3345:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3346}],3346:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3347:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3344}],3348:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3349:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3350,"dup":132,"validate.io-integer-primitive":3351}],3350:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3351:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3344}],3352:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, v, accessor )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` using an accessor function.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} v - degrees of freedom
* @param {Function} accessor - accessor function for accessing array values
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, v, clbk ) {
	var len = x.length,
		fcn,
		v, i;

	fcn = partial( v );
	for ( i = 0; i < len; i++ ) {
		v = clbk( x[ i ], i );
		if ( typeof v === 'number' ) {
			y[ i ] = fcn( v );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3358}],3353:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, v )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Array} arr - input array
* @param {Number} v - degrees of freedom
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, v ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial( v );
	for ( i = 0; i < len; i++ ) {
		if ( typeof x[ i ] === 'number' ) {
			y[ i ] = fcn( x[ i ] );
		} else {
			y[ i ] = NaN;
		}
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3358}],3354:[function(require,module,exports){
'use strict';

// MODULES //

var deepSet = require( 'utils-deep-set' ).factory,
	deepGet = require( 'utils-deep-get' ).factory,
	partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( arr, v, path[, sep] )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` for each array element and sets the input array.
*
* @param {Array} arr - input array
* @param {Number} v - degrees of freedom
* @param {String} path - key path used when deep getting and setting
* @param {String} [sep] - key path separator
* @returns {Array} input array
*/
function pdf( x, v, path, sep ) {
	var len = x.length,
		opts = {},
		dget,
		dset,
		fcn,
		v, i;
	if ( arguments.length > 3 ) {
		opts.sep = sep;
	}
	if ( len ) {
		dget = deepGet( path, opts );
		dset = deepSet( path, opts );
		fcn = partial( v );
		for ( i = 0; i < len; i++ ) {
			v = dget( x[ i ] );
			if ( typeof v === 'number' ) {
				dset( x[i], fcn( v ) );
			} else {
				dset( x[i], NaN );
			}
		}
	}
	return x;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3358,"utils-deep-get":3412,"utils-deep-set":3418}],3355:[function(require,module,exports){
'use strict';

// MODULES //

var isNumber = require( 'validate.io-number-primitive' ),
	isArrayLike = require( 'validate.io-array-like' ),
	isTypedArrayLike = require( 'validate.io-typed-array-like' ),
	isMatrixLike = require( 'validate.io-matrix-like' ),
	ctors = require( 'compute-array-constructors' ),
	matrix = require( 'dstructs-matrix' ),
	validate = require( './validate.js' );


// FUNCTIONS //

var pdf1 = require( './number.js' ),
	pdf2 = require( './array.js' ),
	pdf3 = require( './accessor.js' ),
	pdf4 = require( './deepset.js' ),
	pdf5 = require( './matrix.js' ),
	pdf6 = require( './typedarray.js' );


// PDF //

/**
* FUNCTION: pdf( x[, opts] )
*	Evaluates the probability density function (PDF) for a Student t distribution.
*
* @param {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} x - input value
* @param {Object} [opts] - function options
* @param {Number} [opts.v=1] - degrees of freedom
* @param {Boolean} [opts.copy=true] - boolean indicating if the function should return a new data structure
* @param {Function} [opts.accessor] - accessor function for accessing array values
* @param {String} [opts.path] - deep get/set key path
* @param {String} [opts.sep="."] - deep get/set key path separator
* @param {String} [opts.dtype="float64"] - output data type
* @returns {Number|Number[]|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Matrix} evaluated PDF
*/
function pdf( x, options ) {
	/* jshint newcap:false */
	var opts = {},
		ctor,
		err,
		out,
		dt,
		d;

	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.v = typeof opts.v !== 'undefined' ? opts.v : 1;

	if ( isNumber( x ) ) {
		return pdf1( x, opts.v );
	}
	if ( isMatrixLike( x ) ) {
		if ( opts.copy !== false ) {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			// Create an output matrix:
			d = new ctor( x.length );
			out = matrix( d, x.shape, dt );
		} else {
			out = x;
		}
		return pdf5( out, x, opts.v );
	}
	if ( isTypedArrayLike( x ) ) {
		if ( opts.copy === false ) {
			out = x;
		} else {
			dt = opts.dtype || 'float64';
			ctor = ctors( dt );
			if ( ctor === null ) {
				throw new Error( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' );
			}
			out = new ctor( x.length );
		}
		return pdf6( out, x, opts.v );
	}
	if ( isArrayLike( x ) ) {
		// Handle deepset first...
		if ( opts.path ) {
			opts.sep = opts.sep || '.';
			return pdf4( x, opts.v, opts.path, opts.sep );
		}
		// Handle regular and accessor arrays next...
		if ( opts.copy === false ) {
			out = x;
		}
		else if ( opts.dtype ) {
			ctor = ctors( opts.dtype );
			if ( ctor === null ) {
				throw new TypeError( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + opts.dtype + '`.' );
			}
			out = new ctor( x.length );
		}
		else {
			out = new Array( x.length );
		}
		if ( opts.accessor ) {
			return pdf3( out, x, opts.v, opts.accessor );
		}
		return pdf2( out, x, opts.v );
	}
	return NaN;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./accessor.js":3352,"./array.js":3353,"./deepset.js":3354,"./matrix.js":3356,"./number.js":3357,"./typedarray.js":3359,"./validate.js":3360,"compute-array-constructors":3362,"dstructs-matrix":3374,"validate.io-array-like":3421,"validate.io-matrix-like":3426,"validate.io-number-primitive":3430,"validate.io-typed-array-like":3435}],3356:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, matrix, v )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` for each matrix element.
*
* @param {Matrix} out - output matrix
* @param {Matrix} arr - input matrix
* @param {Number} v - degrees of freedom
* @returns {Matrix} output matrix
*/
function pdf( y, x, v ) {
	var len = x.length,
		fcn,
		i;
	if ( y.length !== len ) {
		throw new Error( 'pdf()::invalid input arguments. Input and output matrices must be the same length.' );
	}
	fcn = partial( v );
	for ( i = 0; i < len; i++ ) {
		y.data[ i ] = fcn( x.data[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3358}],3357:[function(require,module,exports){
'use strict';

// MODULES //

var beta = require( 'compute-beta/lib/number-number.js' );


// FUNCTIONS //

var pow = Math.pow,
	sqrt = Math.sqrt;


// PDF //

/**
* FUNCTION: pdf( x, v )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` at a value `x`.
*
* @param {Number} x - input value
* @param {Number} v - degrees of freedom
* @returns {Number} evaluated PDF
*/
function pdf( x, v ) {
	return pow( v / ( v + pow( x, 2 ) ), ( 1 + v ) / 2 ) / ( sqrt(v) * beta( v/2, 0.5 ) );
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"compute-beta/lib/number-number.js":3364}],3358:[function(require,module,exports){
'use strict';

// MODULES //

var beta = require( 'compute-beta/lib/number-number.js' );


// FUNCTIONS //

var pow = Math.pow,
	sqrt = Math.sqrt;


// PARTIAL //

/**
* FUNCTION: partial( v )
*	Partially applies degrees of freedom `v` and returns a function for evaluating the probability density function (PDF) for a Student t distribution.
*
* @param {Number} v - degrees of freedom
* @returns {Function} PDF
*/
function partial( v ) {
	var betaTerm =  sqrt(v) * beta( v/2, 0.5 ),
		exponent =  ( 1 + v ) / 2;
	/**
	* FUNCTION: pdf( x )
	*	Evaluates the probability density function (PDF) for a Student's t distribution.
	*
	* @private
	* @param {Number} x - input value
	* @returns {Number} evaluated PDF
	*/
	return function pdf( x ) {
		return pow( v / ( v + pow( x, 2 ) ), exponent ) / betaTerm;
	};
} // end FUNCTION partial()


// EXPORTS //

module.exports = partial;

},{"compute-beta/lib/number-number.js":3364}],3359:[function(require,module,exports){
'use strict';

// MODULES //

var partial = require( './partial.js' );


// PDF //

/**
* FUNCTION: pdf( out, arr, v )
*	Evaluates the probability density function (PDF) for a Student t distribution with degrees of freedom `v` for each array element.
*
* @param {Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} out - output array
* @param {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} arr - input array
* @param {Number} v - degrees of freedom
* @returns {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} output array
*/
function pdf( y, x, v ) {
	var len = x.length,
		fcn,
		i;

	fcn = partial ( v );
	for ( i = 0; i < len; i++ ) {
		y[ i ] = fcn( x[ i ] );
	}
	return y;
} // end FUNCTION pdf()


// EXPORTS //

module.exports = pdf;

},{"./partial.js":3358}],3360:[function(require,module,exports){
'use strict';

// MODULES //

var isObject = require( 'validate.io-object' ),
	isPositive = require( 'validate.io-positive-primitive' ),
	isBoolean = require( 'validate.io-boolean-primitive' ),
	isFunction = require( 'validate.io-function' ),
	isString = require( 'validate.io-string-primitive' );


// VALIDATE //

/**
* FUNCTION: validate( opts, options )
*	Validates function options.
*
* @param {Object} opts - destination for validated options
* @param {Object} options - function options
* @param {Number} [options.v] - degrees of freedom
* @param {Boolean} [options.copy] - boolean indicating if the function should return a new data structure
* @param {Function} [options.accessor] - accessor function for accessing array values
* @param {String} [options.sep] - deep get/set key path separator
* @param {String} [options.path] - deep get/set key path
* @param {String} [options.dtype] - output data type
* @returns {Null|Error} null or an error
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'pdf()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( options.hasOwnProperty( 'v' ) ) {
		opts.v = options.v;
		if ( !isPositive( opts.v ) ) {
			return new TypeError( 'pdf()::invalid option. `v` parameter must be a positive number. Option: `' + opts.v + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'copy' ) ) {
		opts.copy = options.copy;
		if ( !isBoolean( opts.copy ) ) {
			return new TypeError( 'pdf()::invalid option. Copy option must be a boolean primitive. Option: `' + opts.copy + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'accessor' ) ) {
		opts.accessor = options.accessor;
		if ( !isFunction( opts.accessor ) ) {
			return new TypeError( 'pdf()::invalid option. Accessor must be a function. Option: `' + opts.accessor + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'path' ) ) {
		opts.path = options.path;
		if ( !isString( opts.path ) ) {
			return new TypeError( 'pdf()::invalid option. Key path option must be a string primitive. Option: `' + opts.path + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'sep' ) ) {
		opts.sep = options.sep;
		if ( !isString( opts.sep ) ) {
			return new TypeError( 'pdf()::invalid option. Separator option must be a string primitive. Option: `' + opts.sep + '`.' );
		}
	}
	if ( options.hasOwnProperty( 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isString( opts.dtype ) ) {
			return new TypeError( 'pdf()::invalid option. Data type option must be a string primitive. Option: `' + opts.dtype + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;

},{"validate.io-boolean-primitive":3424,"validate.io-function":3425,"validate.io-object":3431,"validate.io-positive-primitive":3433,"validate.io-string-primitive":3434}],3361:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],3362:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./ctors.js":3361,"dup":63}],3363:[function(require,module,exports){
'use strict';

function betaln() {
	return 1;
}


// EXPORTS //

module.exports = betaln;

},{}],3364:[function(require,module,exports){
'use strict';

// MODULES //

var gamma = require( 'gamma' ),
	betaln = require( './betaln.js' ); //require( 'compute-betaln/lib/number.js' );


// FUNCTIONS //

var EXP = Math.exp;


// VARIABLES //

var GAMMA_XMAX = 171.61447887182298;


// BETA //

/**
* FUNCTION: beta( x, y )
*	Evaluates the beta function.
*
* @param {Number} x - input value
* @param {Number} y - input value
* @returns {Number} evaluated beta function
*/
function beta( x, y  ) {
	if ( x !== x || y !== y || x < 0 || y < 0 ) {
		return NaN;
	}
	if ( x === 0 || y === 0 ) {
		return Number.POSITIVE_INFINITY;
	}
	if ( x + y > GAMMA_XMAX ) {
		return EXP( betaln( x, y ) );
	}
	return gamma( x ) * gamma( y ) / gamma( x + y );
} // end FUNCTION beta()


// EXPORTS //

module.exports = beta;

},{"./betaln.js":3363,"gamma":3365}],3365:[function(require,module,exports){
// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
];

var g_ln = 607/128;
var p_ln = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.21743961811521264320e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.26190838401581408670e-4,
    0.36899182659531622704e-5
];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if(z < 0) return Number('0/0');
    var x = p_ln[0];
    for(var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5*Math.log(2*Math.PI)+(z+.5)*Math.log(t)-t+Math.log(x)-Math.log(z);
}

module.exports = function gamma (z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    }
    else if(z > 100) return Math.exp(lngamma(z));
    else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI)
            * Math.pow(t, z + 0.5)
            * Math.exp(-t)
            * x
        ;
    }
};

module.exports.log = lngamma;

},{}],3366:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],3367:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./get.js":3370,"./iget.js":3372,"./iset.js":3375,"./mget.js":3379,"./mset.js":3381,"./set.js":3389,"./sget.js":3391,"./sset.js":3393,"./toString.js":3395,"dup":2}],3368:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./get.raw.js":3371,"./iget.raw.js":3373,"./iset.raw.js":3376,"./mget.raw.js":3380,"./mset.raw.js":3382,"./set.raw.js":3390,"./sget.raw.js":3392,"./sset.raw.js":3394,"./toString.js":3395,"dup":3}],3369:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],3370:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"validate.io-nonnegative-integer":3427}],3371:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],3372:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7,"validate.io-integer-primitive":3407}],3373:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],3374:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./matrix.js":3377,"./matrix.raw.js":3378,"dup":9}],3375:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"validate.io-integer-primitive":3407,"validate.io-number-primitive":3430}],3376:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],3377:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./btypes.js":3366,"./ctor.js":3367,"./dtypes.js":3369,"compute-cast-arrays":3396,"compute-dtype":3399,"dup":12,"validate.io-array":3404,"validate.io-contains":3405,"validate.io-nonnegative-integer-array":3408,"validate.io-string-primitive":3434}],3378:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./btypes.js":3366,"./ctor.raw.js":3368,"./dtypes.js":3369,"compute-dtype":3399,"dup":13,"validate.io-contains":3405,"validate.io-string-primitive":3434}],3379:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./btypes.js":3366,"dup":14,"validate.io-nonnegative-integer-array":3408}],3380:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./btypes.js":3366,"dup":15}],3381:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./mset1.js":3383,"./mset2.js":3384,"./mset3.js":3385,"./mset4.js":3386,"./mset5.js":3387,"./mset6.js":3388,"dup":16,"validate.io-function":3425,"validate.io-nonnegative-integer-array":3408,"validate.io-number-primitive":3430}],3382:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./mset1.js":3383,"./mset2.js":3384,"./mset3.js":3385,"./mset4.js":3386,"./mset5.js":3387,"./mset6.js":3388,"dup":17}],3383:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],3384:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],3385:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],3386:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],3387:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],3388:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],3389:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"validate.io-nonnegative-integer":3427,"validate.io-number-primitive":3430}],3390:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],3391:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./btypes.js":3366,"compute-indexspace":3403,"dup":26,"validate.io-string-primitive":3434}],3392:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./btypes.js":3366,"compute-indexspace":3403,"dup":27}],3393:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"compute-indexspace":3403,"dup":28,"validate.io-function":3425,"validate.io-number-primitive":3430,"validate.io-string-primitive":3434}],3394:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"compute-indexspace":3403,"dup":29}],3395:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],3396:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"compute-array-constructors/lib/ctors":3361,"compute-array-dtype/lib/dtypes":3397,"dup":31,"type-name":3398,"validate.io-array-like":3421}],3397:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3398:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3399:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"compute-array-dtype":3401,"dup":36,"type-name":3402}],3400:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],3401:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./dtypes.js":3400,"dup":38}],3402:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"dup":96}],3403:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"validate.io-nonnegative-integer":3427,"validate.io-string-primitive":3434}],3404:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3405:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"validate.io-array":3404,"validate.io-nan-primitive":3406}],3406:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],3407:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3430}],3408:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"validate.io-array":3404,"validate.io-nonnegative-integer":3427}],3409:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],3410:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],3411:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./deepget.js":3409,"./defaults.js":3410,"./validate.js":3413,"dup":111,"validate.io-array":3414,"validate.io-string-primitive":3434}],3412:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./deepget.js":3409,"./defaults.js":3410,"./factory.js":3411,"./validate.js":3413,"dup":112,"validate.io-array":3414,"validate.io-string-primitive":3434}],3413:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113,"validate.io-object":3431,"validate.io-string-primitive":3434}],3414:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3415:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],3416:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],3417:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./deepset.js":3415,"./defaults.js":3416,"./validate.js":3419,"dup":117,"validate.io-array":3420,"validate.io-string-primitive":3434}],3418:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./deepset.js":3415,"./defaults.js":3416,"./factory.js":3417,"./validate.js":3419,"dup":118,"validate.io-array":3420,"validate.io-string-primitive":3434}],3419:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"dup":119,"validate.io-boolean-primitive":3424,"validate.io-object":3431,"validate.io-string-primitive":3434}],3420:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3421:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3422,"dup":34,"validate.io-integer-primitive":3423}],3422:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3423:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3430}],3424:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],3425:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],3426:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],3427:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"validate.io-integer":3428}],3428:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"validate.io-number":3429}],3429:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],3430:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],3431:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129,"validate.io-array":3432}],3432:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],3433:[function(require,module,exports){
arguments[4][1272][0].apply(exports,arguments)
},{"dup":1272,"validate.io-number-primitive":3430}],3434:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],3435:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"compute-const-max-safe-integer":3436,"dup":132,"validate.io-integer-primitive":3437}],3436:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],3437:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"validate.io-number-primitive":3430}],3438:[function(require,module,exports){
(function (global){
global.distributions = require( 'distributions.io' );
global.compute = require( 'compute.io' );
global.matrix = require( 'dstructs-matrix' ); 

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"compute.io":53,"distributions.io":1193,"dstructs-matrix":9}],3439:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}]},{},[3438]);
